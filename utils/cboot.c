/** \file
 *
 * This file implements a utility for running and managing a canister
 * in an independent measurement domain.  After creating an
 * independent measurement domain the utility forks and then executes
 * the boot of the canister in the subordinate process.  The parent
 * process monitors the following file:
 *
 * /sys/fs/iso-identity/update
 *
 * For measurement domain updates.
 *
 * The domain is managed through a UNIX domain socket which is created
 * in the following location:
 *
 * /var/run/cboot.PIDNUM
 */

/**************************************************************************
 * (C)Copyright 2017, IDfusion, LLC. All rights reserved.
 *
 * Please refer to the file named COPYING in the top of the source tree
 * for licensing information.
 **************************************************************************/


/* Local defines. */
#define SGX_DEVICE "/dev/isgx"
#define SGX_ENCLAVE "/lib/sgx-pcr.signed.so"


/* Include files. */
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include <unistd.h>
#include <errno.h>
#include <poll.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <linux/un.h>

#include <HurdLib.h>
#include <Buffer.h>
#include <String.h>
#include <File.h>

#include <NAAAIM.h>
#include <Buffer.h>
#include <LocalDuct.h>
#include <SHA256.h>

#include "../SGX/SGX.h"
#include "../SGX/SGXenclave.h"

#include "cboot.h"


/**
 * The following variable holds the current measurement.
 */
static unsigned char Measurement[32];

/**
 * The following variable holds booleans which describe signals
 * which were received.
 */
struct {
	_Bool sigint;
	_Bool sigterm;
	_Bool sighup;
	_Bool sigquit;

	_Bool stop;
} Signals;

/**
 * The following enumeration type specifies whether or not
 * the measurements are being managed internally or by an SGX enclave.
 */
 enum {
	 internal,
	 sgx
} Mode = internal;

/**
 * The following object is used to manage the measurement enclave
 * when running in SGX mode.
 */
SGXenclave Enclave = NULL;

/* Define the OCALL interface for the 'print string' call. */
struct ocall1_interface {
	char* str;
} ocall1_string;

int ocall1_handler(struct ocall1_interface *interface)

{
	fprintf(stdout, "%s", interface->str);
	return 0;
}

static const struct OCALL_api ocall_table = {
	1, {ocall1_handler}
};


/* Define the ECALL interfaces .*/
static struct ecall0_table {
	uint8_t *buffer;
	size_t len;
} ecall0_table;

static struct ecall1_table {
	uint8_t *buffer;
	size_t len;
} ecall1_table;


/**
 * Private function.
 *
 * This function implements the signal handler for the utility.  It
 * sets the signal type in the Signals structure.
 *
 * \param signal	The number of the signal which caused the
 *			handler to execute.
 */

void signal_handler(int signal)

{
	switch ( signal ) {
		case SIGINT:
			Signals.stop = true;
			break;
		case SIGTERM:
			Signals.stop = true;
			break;
		case SIGHUP:
			Signals.stop = true;
			break;
		case SIGQUIT:
			Signals.stop = true;
			break;
	}

	return;
}


/**
 * Private function.
 *
 * This function is responsible for loading an SGX enclave
 * which will be used to hold the measurement status of the canister
 * which is being booted.
 *
 * \param token		A pointer to the SGX EINITTOKEN which will
 *			be used to initialize the measurement enclave.
 *
 * \return		A boolean value is returned to indicate whether
 *			or not setup of the enclave succeeded.  A false
 *			value indicates there was a failure in the
 *			enclave setup, a true value indicates the enclave
 *			is ready to accept commands.
 */

static _Bool load_enclave(CO(char *, token))

{
	_Bool retn = false;

	struct SGX_einittoken *einit_token;

	Buffer tbufr = NULL;

	File token_file = NULL;


	/* Load the EINITTOKEN. */
	INIT(HurdLib, File, token_file, ERR(goto done));
	INIT(HurdLib, Buffer, tbufr, ERR(goto done));

	if ( !token_file->open_ro(token_file, token) )
		ERR(goto done);
	if ( !token_file->slurp(token_file, tbufr) )
		ERR(goto done);
	einit_token = (struct SGX_einittoken *) tbufr->get(tbufr);


	/* Load and initialize the enclave. */
	INIT(NAAAIM, SGXenclave, Enclave, ERR(goto done));

	if ( !Enclave->open_enclave(Enclave, SGX_DEVICE, SGX_ENCLAVE, true) )
		ERR(goto done);

	if ( !Enclave->create_enclave(Enclave) )
		ERR(goto done);

	if ( !Enclave->load_enclave(Enclave) )
		ERR(goto done);

	if ( !Enclave->init_enclave(Enclave, einit_token) )
		ERR(goto done);

	retn = true;


 done:
	WHACK(tbufr);
	WHACK(token_file);

	return retn;
}


/**
 * Private function.
 *
 * This function carries out the addition of a measurement value
 * generated by the kernel to the current measurement state of the
 * canister.
 *
 * \param bufr		A pointer to the character buffer containing
 *			the hexadecimally encoded measurement from
 *			the canister.
 *
 * \return		A boolean value is returned to indicate whether
 *			or not addition of the measurement succeeded.  A
 *			false value indicates the addition of the
 *			measurement failed while a true value indicates
 *			the measurement had succeeded.
 */

static _Bool add_measurement(CO(char *, bufr))

{
	_Bool retn = false;

	char *p;

	int rc;

	Buffer bf,
	       input = NULL;

	SHA256 sha256 = NULL;


	/* Convert the ASCII measurement into a binary buffer. */
	if ( (p = strchr(bufr, '\n')) == NULL )
		ERR(goto done);
	*p = '\0';

	INIT(HurdLib, Buffer, input, ERR(goto done));
	if ( !input->add_hexstring(input, bufr) )
		ERR(goto done);


	/* Update the enclave measurement if we are running in SGX mode. */
	if ( Mode == sgx ) {
		ecall0_table.len    = input->size(input);
		ecall0_table.buffer = input->get(input);
		if ( !Enclave->boot_slot(Enclave, 0, &ocall_table, \
					 &ecall0_table, &rc) ) {
			fprintf(stderr, "Enclave returned: %d\n", rc);
			ERR(goto done);
		}

		return true;
	}


	/* Update the internal measurement. */
	INIT(NAAAIM, SHA256, sha256, ERR(goto done));

	sha256->add(sha256, input);
	if ( !sha256->compute(sha256) )
		ERR(goto done);
	bf = sha256->get_Buffer(sha256);

	input->reset(input);
	input->add(input, Measurement, sizeof(Measurement));
	input->add_Buffer(input, bf);

	sha256->reset(sha256);
	sha256->add(sha256, input);
	if ( !sha256->compute(sha256) )
		ERR(goto done);

	memcpy(Measurement, bf->get(bf), bf->size(bf));
	retn = true;


 done:
	WHACK(input);
	WHACK(sha256);

	return retn;
}


/**
 * Private function.
 *
 * This function is responsible for issueing an ECALL to obtain the
 * current canister measurement state maintained in the enclave.
 *
 * \param bufr		The object which the measurement will be
 *			loaded into.
 *
 * \return		A boolean value is returned to indicate whether
 *			or not the measurement was properly returned.
 *			A false value indicates an error was
 *			encountered while retrieving the measurement.
 */

static _Bool get_enclave_measurement(CO(Buffer, bufr))
{
	_Bool retn = false;

	unsigned char inbufr[32];

	int rc;


	memset(inbufr, '\0', sizeof(inbufr));
	ecall1_table.len    = sizeof(inbufr);
	ecall1_table.buffer = (uint8_t *) inbufr;
	if ( !Enclave->boot_slot(Enclave, 1, &ocall_table, \
				 &ecall1_table, &rc) ) {
		fprintf(stderr, "Enclave returned: %d\n", rc);
		goto done;
	}

	if ( !bufr->add(bufr, inbufr, sizeof(inbufr)) )
		ERR(goto done);
	retn = true;


 done:
	return retn;
}


/**
 * Private function.
 *
 * This function implements the processing of a command from the
 * canister management utility.  This command comes in the form
 * of a binary encoding of the desired command to be run.
 *
 * \param mgmt		The socket object used to communicate with
 *			the canister management instance.
 *
 * \param cmdbufr	The object containing the command to be
 *			processed.
 *
 * \return		A boolean value is returned to indicate whether
 *			or not the command was processed.  A false value
 *			indicates the processing of commands should be
 *			terminated while a true value indicates an
 *			additional command cycle should be processed.
 */

static _Bool process_command(CO(LocalDuct, mgmt), CO(Buffer, cmdbufr))

{
	_Bool retn = false;

	int *cp;


	if ( cmdbufr->size(cmdbufr) != sizeof(int) )
		ERR(goto done);

	cp = (int *) cmdbufr->get(cmdbufr);
	switch ( *cp ) {
		case show_measurement:
			cmdbufr->reset(cmdbufr);
			if ( Mode == sgx )
				get_enclave_measurement(cmdbufr);
			else
				cmdbufr->add(cmdbufr, Measurement, \
					     sizeof(Measurement));

			if ( !mgmt->send_Buffer(mgmt, cmdbufr) )
				ERR(goto done);
			retn = true;
			break;
	}

	retn = true;


 done:
	return retn;
}


/*
 * Program entry point begins here.
 */

extern int main(int argc, char *argv[])

{
	_Bool connected = false;

	char *token	  = NULL,
	     *update_file = NULL,
	     bufr[20 * 2 + 2],
	     sockname[UNIX_PATH_MAX];

	int opt,
	    fd	 = 0,
	    retn = 1;

	struct pollfd poll_data[2];

	struct sigaction signal_action;


	Buffer cmdbufr = NULL;

	LocalDuct mgmt = NULL;


	while ( (opt = getopt(argc, argv, "Sf:t:")) != EOF )
		switch ( opt ) {
			case 'S':
				Mode = sgx;
				break;

			case 'f':
				update_file = optarg;
				break;

			case 't':
				token = optarg;
				break;
		}


	/* Setup signal handling. */
	if ( sigemptyset(&signal_action.sa_mask) == -1 )
		ERR(goto done);

	signal_action.sa_flags = 0;
	signal_action.sa_handler = signal_handler;
	if ( sigaction(SIGINT, &signal_action, NULL) == -1 )
		goto done;
	if ( sigaction(SIGTERM, &signal_action, NULL) == -1 )
		goto done;
	if ( sigaction(SIGHUP, &signal_action, NULL) == -1 )
		goto done;
	if ( sigaction(SIGQUIT, &signal_action, NULL) == -1 )
		goto done;


	/* Setup measurement enclave if SGX is being used. */
	if ( Mode == sgx ) {
		if ( token == NULL ) {
			fputs("SGX mode but no token specified.\n", stderr);
			goto done;
		}

		if ( !load_enclave(token) ) {
			fputs("SGX enclave initialization failure.\n", stderr);
			goto done;
		}
	}


	/* Open a connection to the update file. */
	if ( update_file == NULL ) {
		fputs("No update file specified.\n", stderr);
		goto done;
	}

	if ( (fd = open(update_file, O_RDONLY)) < 0 ) {
		fprintf(stderr, "Cannot open update file: errno=%d - %s\n", \
			errno, strerror(errno));
		goto done;
	}
	poll_data[0].fd = fd;
	poll_data[0].events = POLLPRI;


	/* Setup the management socket. */
	if ( snprintf(sockname, sizeof(sockname), "%s.%u", SOCKNAME, getpid())
	     >= sizeof(sockname) ) {
		fputs("Socket name overflow.\n", stderr);
		goto done;
	}

	if ( (mgmt = NAAAIM_LocalDuct_Init()) == NULL ) {
		fputs("Error creating management socket.\n", stderr);
		goto done;
	}

	if ( !mgmt->init_server(mgmt) ) {
		fputs("Cannot set server mode.\n", stderr);
		goto done;
	}

	if ( !mgmt->init_port(mgmt, sockname) ) {
		fputs("Cannot initialize port.\n", stderr);
		goto done;
	}

	if ( !mgmt->get_socket(mgmt, &poll_data[1].fd) ) {
		fputs("Error setting up polling data.\n", stderr);
		goto done;
	}
	poll_data[1].events = POLLIN;


	/* Dispatch loop. */
	fputs("Calling loop\n", stderr);
	fprintf(stderr, "descriptor 1: %d, descriptor 2: %d\n", \
		poll_data[0].fd, poll_data[1].fd);

	INIT(HurdLib, Buffer, cmdbufr, ERR(goto done));

	opt = 0;
	while ( 1 ) {
		fprintf(stderr, "Poll cycle: %d\n", ++opt);
		retn = poll(poll_data, 2, -1);
		if ( retn < 0 ) {
			if ( Signals.stop )
				break;
			fprintf(stderr, "Poll error: cause=%s\n", \
				strerror(errno));
			goto done;
		}
		if ( retn == 0 ) {
			fputs("Poll timeout.\n", stderr);
			continue;
		}

		fprintf(stderr, "Events: %d, Data poll=%0x, Mgmt poll=%0x\n", \
			retn, poll_data[0].revents, poll_data[1].revents);

		if ( poll_data[0].revents & POLLPRI ) {
			do {
				memset(bufr, '\0', sizeof(bufr));
				retn = read(fd, bufr, sizeof(bufr) - 1);
				if ( retn != (sizeof(bufr) - 1) ) {
					fprintf(stderr, "Have error: "	     \
						"retn=%d, error=%s\n", retn, \
						strerror(errno));
					if ( (retn < 0) && (errno == ENODATA) )
						continue;
				}

				if ( add_measurement(bufr) ) {
					if ( lseek(fd, 0, SEEK_SET) < 0 ) {
						fputs("Seek error.\n", stderr);
						break;
					}
				}
			} while ( errno != ENODATA );
		}

		if ( poll_data[1].revents & POLLIN ) {
			if ( !connected ) {
				fputs("Have socket connection.\n", stderr);
				if ( !mgmt->accept_connection(mgmt) )
					ERR(goto done);
				if ( !mgmt->get_fd(mgmt, &poll_data[1].fd) )
					ERR(goto done);
				poll_data[1].events = POLLIN;
				connected = true;
				continue;
			}
			if ( !mgmt->receive_Buffer(mgmt, cmdbufr) )
				continue;
			if ( mgmt->eof(mgmt) ) {
				fputs("Terminating management.\n", \
				      stderr);
				mgmt->reset(mgmt);
				if ( !mgmt->get_socket(mgmt, \
						       &poll_data[1].fd) )
					ERR(goto done);
				poll_data[1].events = POLLIN;
				connected = false;
				continue;
			}

			if ( !process_command(mgmt, cmdbufr) )
				ERR(goto done);
			cmdbufr->reset(cmdbufr);
		}
	}


 done:
	WHACK(cmdbufr);
	WHACK(mgmt);

	if ( fd > 0 )
		close(fd);

	return retn;
}
