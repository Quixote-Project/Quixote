/** \file
 *
 * This file implements a utility for running and managing a canister
 * in an independent measurement domain.  After creating an
 * independent measurement domain the utility forks and then executes
 * the boot of the canister in the subordinate process.  The parent
 * process monitors the following file:
 *
 * /sys/fs/iso-identity/update
 *
 * For measurement domain updates.
 *
 * The domain is managed through a UNIX domain socket which is created
 * in the following location:
 *
 * /var/run/cboot.PIDNUM
 */

/**************************************************************************
 * (C)Copyright 2017, IDfusion, LLC. All rights reserved.
 *
 * Please refer to the file named COPYING in the top of the source tree
 * for licensing information.
 **************************************************************************/


/* Include files. */
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <stdbool.h>
#include <unistd.h>
#include <errno.h>
#include <poll.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <linux/un.h>

#include <HurdLib.h>
#include <Buffer.h>
#include <String.h>
#include <File.h>

#include <NAAAIM.h>
#include <Buffer.h>
#include <LocalDuct.h>
#include <SHA256.h>

#include "cboot.h"


/**
 * The following variable holds the current measurement.
 */
static unsigned char Measurement[32];


/**
 * Private function.
 *
 * This function carries out the addition of a measurement value
 * generated by the kernel to the current measurement state of the
 * canister.
 *
 * \param bufr		A pointer to the character buffer containing
 *			the hexadecimally encoded measurement from
 *			the canister.
 *
 * \return		A boolean value is returned to indicate whether
 *			or not addition of the measurement succeeded.  A
 *			false value indicates the addition of the
 *			measurement failed while a true value indicates
 *			the measurement had succeeded.
 */

static _Bool add_measurement(CO(char *, bufr))

{
	_Bool retn = false;

	char *p;

	Buffer bf,
	       input = NULL;

	SHA256 sha256 = NULL;


	if ( (p = strchr(bufr, '\n')) == NULL )
		ERR(goto done);
	*p = '\0';


	INIT(HurdLib, Buffer, input, ERR(goto done));
	INIT(NAAAIM, SHA256, sha256, ERR(goto done));

	input->add_hexstring(input, bufr);
	sha256->add(sha256, input);
	if ( !sha256->compute(sha256) )
		ERR(goto done);
	bf = sha256->get_Buffer(sha256);

	input->reset(input);
	input->add(input, Measurement, sizeof(Measurement));
	input->add_Buffer(input, bf);

	sha256->reset(sha256);
	sha256->add(sha256, input);
	if ( !sha256->compute(sha256) )
		ERR(goto done);

	memcpy(Measurement, bf->get(bf), bf->size(bf));
	retn = true;


 done:
	WHACK(input);
	WHACK(sha256);

	return retn;
}


/**
 * Private function.
 *
 * This function implements the processing of a command from the
 * canister management utility.  This command comes in the form
 * of a binary encoding of the desired command to be run.
 *
 * \param mgmt		The socket object used to communicate with
 *			the canister management instance.
 *
 * \param cmdbufr	The object containing the command to be
 *			processed.
 *
 * \return		A boolean value is returned to indicate whether
 *			or not the command was processed.  A false value
 *			indicates the processing of commands should be
 *			terminated while a true value indicates an
 *			additional command cycle should be processed.
 */

static _Bool process_command(CO(LocalDuct, mgmt), CO(Buffer, cmdbufr))

{
	_Bool retn = false;

	int *cp;


	if ( cmdbufr->size(cmdbufr) != sizeof(int) )
		ERR(goto done);

	cp = (int *) cmdbufr->get(cmdbufr);
	switch ( *cp ) {
		case show_measurement:
			cmdbufr->reset(cmdbufr);
			cmdbufr->add(cmdbufr, Measurement, \
				     sizeof(Measurement));
			if ( !mgmt->send_Buffer(mgmt, cmdbufr) )
				ERR(goto done);
			retn = true;
			break;
	}

	retn = true;


 done:
	return retn;
}


/*
 * Program entry point begins here.
 */

extern int main(int argc, char *argv[])

{
	_Bool connected = false;

	char *update_file = NULL,
	     bufr[20 * 2 + 2],
	     sockname[UNIX_PATH_MAX];

	int opt,
	    fd	 = 0,
	    retn = 1;

	struct pollfd poll_data[2];

	Buffer cmdbufr = NULL;

	LocalDuct mgmt = NULL;


	while ( (opt = getopt(argc, argv, "f:")) != EOF )
		switch ( opt ) {
			case 'f':
				update_file = optarg;
				break;
		}


	/* Open a connection to the update file. */
	if ( update_file == NULL ) {
		fputs("No update file specified.\n", stderr);
		goto done;
	}

	if ( (fd = open(update_file, O_RDONLY)) < 0 ) {
		fprintf(stderr, "Cannot open update file: errno=%d - %s\n", \
			errno, strerror(errno));
		goto done;
	}
	poll_data[0].fd = fd;
	poll_data[0].events = POLLPRI;


	/* Setup the management socket. */
	if ( snprintf(sockname, sizeof(sockname), "%s.%u", SOCKNAME, getpid())
	     >= sizeof(sockname) ) {
		fputs("Socket name overflow.\n", stderr);
		goto done;
	}

	if ( (mgmt = NAAAIM_LocalDuct_Init()) == NULL ) {
		fputs("Error creating management socket.\n", stderr);
		goto done;
	}

	if ( !mgmt->init_server(mgmt) ) {
		fputs("Cannot set server mode.\n", stderr);
		goto done;
	}

	if ( !mgmt->init_port(mgmt, sockname) ) {
		fputs("Cannot initialize port.\n", stderr);
		goto done;
	}

	if ( !mgmt->get_socket(mgmt, &poll_data[1].fd) ) {
		fputs("Error setting up polling data.\n", stderr);
		goto done;
	}
	poll_data[1].events = POLLIN;


	/* Dispatch loop. */
	fputs("Calling loop\n", stderr);
	fprintf(stderr, "descriptor 1: %d, descriptor 2: %d\n", \
		poll_data[0].fd, poll_data[1].fd);

	INIT(HurdLib, Buffer, cmdbufr, ERR(goto done));

	opt = 0;
	while ( 1 ) {
		fprintf(stderr, "Poll cycle: %d\n", ++opt);
		retn = poll(poll_data, 2, -1);
		if ( retn < 0 ) {
			fprintf(stderr, "Poll error: cause=%s\n", \
				strerror(errno));
			goto done;
		}
		if ( retn == 0 ) {
			fputs("Poll timeout.\n", stderr);
			continue;
		}

		fprintf(stderr, "Events: %d, Data poll=%0x, Mgmt poll=%0x\n", \
			retn, poll_data[0].revents, poll_data[1].revents);

		if ( poll_data[0].revents & POLLPRI ) {
			do {
				memset(bufr, '\0', sizeof(bufr));
				retn = read(fd, bufr, sizeof(bufr) - 1);
				if ( retn != (sizeof(bufr) - 1) ) {
					fprintf(stderr, "Have error: "	     \
						"retn=%d, error=%s\n", retn, \
						strerror(errno));
					if ( (retn < 0) && (errno == ENODATA) )
						continue;
				}

				if ( add_measurement(bufr) ) {
					if ( lseek(fd, 0, SEEK_SET) < 0 ) {
						fputs("Seek error.\n", stderr);
						break;
					}
				}
			} while ( errno != ENODATA );
		}

		if ( poll_data[1].revents & POLLIN ) {
			if ( !connected ) {
				fputs("Have socket connection.\n", stderr);
				if ( !mgmt->accept_connection(mgmt) )
					ERR(goto done);
				if ( !mgmt->get_fd(mgmt, &poll_data[1].fd) )
					ERR(goto done);
				poll_data[1].events = POLLIN;
				connected = true;
				continue;
			}
			if ( !mgmt->receive_Buffer(mgmt, cmdbufr) )
				continue;
			if ( mgmt->eof(mgmt) ) {
				fputs("Terminating management.\n", \
				      stderr);
				mgmt->reset(mgmt);
				if ( !mgmt->get_socket(mgmt, \
						       &poll_data[1].fd) )
					ERR(goto done);
				poll_data[1].events = POLLIN;
				connected = false;
				continue;
			}

			if ( !process_command(mgmt, cmdbufr) )
				ERR(goto done);
			cmdbufr->reset(cmdbufr);
		}
	}


 done:
	WHACK(cmdbufr);
	WHACK(mgmt);

	if ( fd > 0 )
		close(fd);

	return retn;
}
