From 48aa8e0965b8c30b08e74a7adf193d96810c2aea Mon Sep 17 00:00:00 2001
From: "Dr. Greg Wettstein" <greg@enjellic.com>
Date: Sat, 11 Mar 2017 17:16:38 -0600
Subject: [PATCH 13/24] Expose actor/subject identity element to contour
 mapping.

The purpose of the changes in this commit are to expose the
identity characteristics of the actor and subjects which are
involved in the information exchange event which is being mapped.

This was accomplished primarily by adding a void pointer to the
ima_field_data structure which is used to reference the identity
characteristics of the entity being mapped, this case either the
actor or subject identities.

The imap_map_identity() function was previously declared to be an
externally visible function but work in this update indicated
there was no longer a need for the function to have global scope
so it was converted to static scope.  In addition the
imap_map_identity() function was modified to take pointers to the
actor and subject identity structures so those structures can be
returned to the caller.
---
 security/integrity/ima/ima.h              |   7 +-
 security/integrity/ima/ima_api.c          |   4 +-
 security/integrity/ima/ima_identity.c     | 109 +++++++++++++++++++-----------
 security/integrity/ima/ima_template_lib.c |   4 +-
 4 files changed, 77 insertions(+), 47 deletions(-)

diff --git a/security/integrity/ima/ima.h b/security/integrity/ima/ima.h
index fed46fd498a7..34b08dcf2c8e 100644
--- a/security/integrity/ima/ima.h
+++ b/security/integrity/ima/ima.h
@@ -64,6 +64,7 @@ struct ima_event_data {
 
 /* IMA template field data definition */
 struct ima_field_data {
+	void *identity;
 	u8 *data;
 	u32 len;
 };
@@ -126,10 +127,8 @@ struct ima_template_desc *ima_template_desc_current(void);
 int ima_init_template(void);
 int ima_identity_init(void);
 int ima_identity_genhash(struct ima_template_entry *, char *);
-int ima_get_actor(char *);
-int ima_get_subject(struct ima_event_data *, char *);
-int ima_map_identity(int, struct integrity_iint_cache *iint,
-		     struct file *file, const char *pathname, char *mapping);
+int ima_get_actor(struct ima_field_data *, char *);
+int ima_get_subject(struct ima_event_data *, struct ima_field_data *, char *);
 int ima_identity_is_mapped(int, struct integrity_iint_cache *iint,
 			   struct file *file, const char *pathname);
 int ima_fs_init(void);
diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 5a2108293647..35dbc1db4e82 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -28,8 +28,10 @@ void ima_free_template_entry(struct ima_template_entry *entry)
 {
 	int i;
 
-	for (i = 0; i < entry->template_desc->num_fields; i++)
+	for (i = 0; i < entry->template_desc->num_fields; i++) {
+		kfree(entry->template_data[i].identity);
 		kfree(entry->template_data[i].data);
+	}
 
 	kfree(entry);
 }
diff --git a/security/integrity/ima/ima_identity.c b/security/integrity/ima/ima_identity.c
index 234e61c364a8..4c24ae732223 100644
--- a/security/integrity/ima/ima_identity.c
+++ b/security/integrity/ima/ima_identity.c
@@ -771,14 +771,15 @@ int ima_identity_genhash(struct ima_template_entry *entry, char *tpm_digest)
 	return retn;
 }
 
-static int ima_get_actor_identity(struct crypto_shash *tfm, char *mapping)
+static int ima_get_actor_identity(struct crypto_shash *tfm,
+				  struct actor_identity *identity,
+				  char *mapping)
 {
 	int retn = 0;
 	struct {
 		struct shash_desc shash;
 		char ctx[crypto_shash_descsize(tfm)];
 	} desc;
-	struct actor_identity identity;
 
 	desc.shash.tfm = tfm;
 	desc.shash.flags = 0;
@@ -786,9 +787,9 @@ static int ima_get_actor_identity(struct crypto_shash *tfm, char *mapping)
 	if (retn != 0)
 		goto done;
 
-	get_identity(&identity);
-	retn = crypto_shash_finup(&desc.shash, (char *) &identity,
-				  sizeof(identity), mapping);
+	get_identity(identity);
+	retn = crypto_shash_finup(&desc.shash, (char *) identity,
+				  sizeof(*identity), mapping);
 #if 0
 	pr_info("IMA[%s]: comm=%s, pid=%d, [ue]id=%d/%d, caps=%llx\n",
 		__func__, current->comm, current->pid, identity.uid,
@@ -800,16 +801,29 @@ static int ima_get_actor_identity(struct crypto_shash *tfm, char *mapping)
 }
 
 
-int ima_get_actor(char *actor)
+int ima_get_actor(struct ima_field_data *field_data, char *actor)
 {
-	int retn;
+	int retn = 1;
 	struct crypto_shash *tfm;
+	struct actor_identity *identity = NULL;
 
 	tfm = crypto_alloc_shash("sha256", 0, 0);
 	if (IS_ERR(tfm))
 		return PTR_ERR(tfm);
 
-	retn = ima_get_actor_identity(tfm, actor);
+	identity = kzalloc(sizeof(*identity), GFP_KERNEL);
+	if (!identity)
+		goto done;
+
+	retn = ima_get_actor_identity(tfm, identity, actor);
+	if(retn!=0)
+		goto done;
+	field_data->identity = identity;
+	retn = 0;
+
+ done:
+	if (retn)
+		kfree(identity);
 	crypto_free_shash(tfm);
 	return retn;
 }
@@ -846,7 +860,7 @@ static int ima_add_subject_name(struct crypto_shash *tfm,
 }
 
 static int ima_get_subject_identity(struct crypto_shash *tfm,
-				    struct subject_identity subject,
+				    struct subject_identity *subject,
 				    char *identity)
 {
 	int retn = 0;
@@ -868,58 +882,63 @@ static int ima_get_subject_identity(struct crypto_shash *tfm,
 	return retn;
 }
 
-int ima_get_subject(struct ima_event_data *event_data, char *subject)
+int ima_get_subject(struct ima_event_data *event_data,
+		    struct ima_field_data *field_data, char *subject)
 {
 	const char *filename;
-	int retn=0;
+	int retn=1;
 	struct crypto_shash *tfm;
-	struct subject_identity identity;
+	struct subject_identity *identity = NULL;
 	struct inode *inode;
 
 	tfm = crypto_alloc_shash("sha256", 0, 0);
 	if (IS_ERR(tfm))
 		return PTR_ERR(tfm);
 
+	identity = kzalloc(sizeof(*identity), GFP_KERNEL);
+	if (!identity)
+		goto done;
+
 	filename = event_data->filename;
-	memset(&identity, '\0', sizeof(struct subject_identity));
+	memset(identity, '\0', sizeof(struct subject_identity));
 
 	/* Add hash of subject name. */
-	if (ima_add_subject_name(tfm, &identity, event_data) != 0)
+	if (ima_add_subject_name(tfm, identity, event_data) != 0)
 		goto done;
 
 	/* Add the digest of the subject. */
-	memcpy(identity.digest, event_data->iint->ima_hash->digest,
-	       sizeof(identity.digest));
+	memcpy(identity->digest, event_data->iint->ima_hash->digest,
+	       WP256_DIGEST_SIZE);
 
 	/* Add subject characteristics. */
 	if (event_data->file) {
 		inode = file_inode(event_data->file);
-		identity.uid = from_kuid(&init_user_ns, inode->i_uid);
-		identity.gid = from_kgid(&init_user_ns, inode->i_gid);
-		identity.mode = inode->i_mode;
-		memcpy(identity.s_id, inode->i_sb->s_id,
-		       sizeof(identity.s_id));
-		memcpy(identity.s_uuid, inode->i_sb->s_uuid,
-		       sizeof(identity.s_uuid));
-		pr_info("[%s]: name=%s, uuid=%*phN\n", __func__,
-			identity.s_id, (int) sizeof(identity.s_uuid),
-			identity.s_uuid);
+		identity->uid = from_kuid(&init_user_ns, inode->i_uid);
+		identity->gid = from_kgid(&init_user_ns, inode->i_gid);
+		identity->mode = inode->i_mode;
+		memcpy(identity->s_id, inode->i_sb->s_id,
+		       sizeof(identity->s_id));
+		memcpy(identity->s_uuid, inode->i_sb->s_uuid,
+		       sizeof(identity->s_uuid));
 	}
 
 	retn = ima_get_subject_identity(tfm, identity, subject);
-	pr_info("[%s]: mode=o%o, uid=%u, gid=%u, filename=%s, name/size=%*phN/%u, subject=%*phN\n",
-		__func__, identity.mode, identity.uid, identity.gid,
-		filename == NULL ? "no path" : filename,
-		WP256_DIGEST_SIZE, identity.name, identity.name_length,
-		WP256_DIGEST_SIZE, subject);
+	if (retn)
+		goto done;
+	field_data->identity = identity;
+	retn = 0;
 
  done:
+	if (retn)
+		kfree(identity);
 	crypto_free_shash(tfm);
 	return retn;
 }
 
-int ima_map_identity(int function, struct integrity_iint_cache *iint,
-		     struct file *file, const char *pathname, char *mapping)
+static int ima_map_identity(int function, struct integrity_iint_cache *iint,
+			    struct file *file, const char *pathname,
+			    struct actor_identity *actor,
+			    struct subject_identity *subject, char *mapping)
 {
 	int retn, num_fields;
 	struct ima_template_entry *entry;
@@ -936,7 +955,6 @@ int ima_map_identity(int function, struct integrity_iint_cache *iint,
 		NULL
 	};
 
-
 	retn = ima_alloc_init_template(&event_data, &entry);
 	if (retn != 0 )
 		goto done;
@@ -946,13 +964,12 @@ int ima_map_identity(int function, struct integrity_iint_cache *iint,
 	retn = ima_calc_field_array_hash(&entry->template_data[0],
 					 entry->template_desc,
 					 num_fields, &hash.hdr);
+
+	*actor = *(struct actor_identity *) entry->template_data[0].identity;
+	*subject = *(struct subject_identity *) entry->template_data[1].identity;
 	memcpy(mapping, hash.digest, sizeof(hash.digest));
 
 	ima_free_template_entry(entry);
-	retn = ima_alloc_init_template(&event_data, &entry);
-	if (retn != 0 )
-		goto done;
-	ima_free_template_entry(entry);
 	retn = 0;
 
  done:
@@ -1001,11 +1018,14 @@ int ima_identity_is_mapped(int function, struct integrity_iint_cache *iint,
 {
 	int retn = 0;
 	char mapping[WP256_DIGEST_SIZE];
+	struct actor_identity actor;
+	struct subject_identity subject;
 
 	if (have_violation(file, iint, pathname))
 		return 1;
 
-	if (ima_map_identity(function, iint, file, pathname, mapping) != 0)
+	if (ima_map_identity(function, iint, file, pathname, &actor,
+			     &subject, mapping) != 0)
 		return 0;
 
 	if (have_contour(mapping)) {
@@ -1016,6 +1036,15 @@ int ima_identity_is_mapped(int function, struct integrity_iint_cache *iint,
 		return 1;
 	}
 
+	pr_info("[%s] actor uid=%d, euid=%d, suid=%d, gid=%d, egid=%d, sgid=%d, fsuid=%d, fsgid=%d, cap=%llx\n", __func__, actor.uid, actor.euid,
+		actor.suid, actor.gid, actor.egid, actor.sgid, actor.fsuid,
+		actor.fsgid, actor.capability.value);
+	pr_info("[%s] subject: filename=%s, mode=o%o, uid=%u, gid=%u, name size/hash=%u/%*phN, super name/uuid=%s/%*phN, subject=%*phN\n",
+		__func__, pathname, subject.mode, subject.uid, subject.gid,
+		subject.name_length, WP256_DIGEST_SIZE, subject.name,
+		subject.s_id, (int) sizeof(subject.s_uuid), subject.s_uuid,
+		WP256_DIGEST_SIZE, subject.digest);
+
 	if (domain_sealed) {
 		retn = register_forensic_violation(function, iint, file,
 						   pathname);
@@ -1025,7 +1054,7 @@ int ima_identity_is_mapped(int function, struct integrity_iint_cache *iint,
 	else
 		retn = add_contour_point(mapping);
 
-#if 0
+#if 1
 	if (!retn)
 		pr_info("[%s]: Mapped entry=%d, comm=%s, pid=%d, func=%d, pathname=%s, fsmagic=%lx, inum=%lu, identity=%*phN\n",
 			__func__, contour_count, current->comm, current->pid,
diff --git a/security/integrity/ima/ima_template_lib.c b/security/integrity/ima/ima_template_lib.c
index e22a7a475bba..a4e364b40d93 100644
--- a/security/integrity/ima/ima_template_lib.c
+++ b/security/integrity/ima/ima_template_lib.c
@@ -339,7 +339,7 @@ int ima_event_actor_init(struct ima_event_data *event_data,
 	enum data_formats fmt = DATA_FMT_HEX;
 	int rc = 0;
 
-	rc = ima_get_actor(actor);
+	rc = ima_get_actor(field_data, actor);
 	if (rc!=0)
 		return rc;
 
@@ -358,7 +358,7 @@ int ima_event_subject_init(struct ima_event_data *event_data,
 	int rc = 0;
 	enum data_formats fmt = DATA_FMT_HEX;
 
-	rc = ima_get_subject(event_data, subject);
+	rc = ima_get_subject(event_data, field_data, subject);
 	if (rc!=0)
 		return rc;
 
-- 
2.11.0

