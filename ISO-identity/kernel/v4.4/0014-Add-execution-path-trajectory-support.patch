From 3154c14394dc9dade05bb05aa6d693dccb2bb271 Mon Sep 17 00:00:00 2001
From: "Dr. Greg Wettstein" <greg@enjellic.com>
Date: Tue, 14 Mar 2017 00:00:04 -0500
Subject: [PATCH 14/24] Add execution path trajectory support.

This commit implements support for developing a trace which
documents the ballistic trajectory path across a system's
execution surface.  The trajectory path represents the set of
information exchange events which are mediated between actor
and subject identities.

The trajectory path is surfaced through a pseudo-file named
trajectory in the iso-identity pseudo-directory which, for the
root behavioral space, is situated at the following location:

/sys/kernel/security/ima/iso-identity/trajectory

Each line in this file represents one information exchange event.
The following is an example of one such line:

event{swapper/0:/bin/bash-3.2.48} actor{uid=0, euid=0, suid=0, gid=0, egid=0, sgid=0, fsuid=0, fsgid=0, cap=3fffffffff} subject{uid=0, gid=0, mode=o100755, name_length=16, name=e1cb9766d47adb4d514d5590dd247504a3aab7e67839d65a6c6f4c32fc120e5d, s_id=xvda, s_uuid=feadbeaffeadbeaffeadbeaffeadbeaf, digest=d2a6bfe0d8a2346d45518dcaaf47642808d6c605506bd0b8e42a65a76735b98e}

The event{} clauses represent a symblic representation of the
event.  The actor{} and subject{} clauses represent the identity
characteristics of the two participants in the event.
---
 security/integrity/ima/ima_identity.c | 145 ++++++++++++++++++++++++++++++++--
 1 file changed, 140 insertions(+), 5 deletions(-)

diff --git a/security/integrity/ima/ima_identity.c b/security/integrity/ima/ima_identity.c
index 4c24ae732223..7ecf37297876 100644
--- a/security/integrity/ima/ima_identity.c
+++ b/security/integrity/ima/ima_identity.c
@@ -66,6 +66,7 @@ static struct dentry *host_identity;
 static struct dentry *sealed;
 static struct dentry *forensics;
 static struct dentry *measurement_file;
+static struct dentry *trajectory;
 
 /* Identity of host. */
 static char host_id[WP256_DIGEST_SIZE];
@@ -104,6 +105,18 @@ static DEFINE_MUTEX(contour_list_mutex);
 static LIST_HEAD(contour_list);
 static unsigned int contour_count;
 
+struct trajectory {
+	struct list_head list;
+	char *filename;
+	char *process;
+	struct actor_identity actor;
+	struct subject_identity subject;
+};
+
+static DEFINE_MUTEX(trajectory_list_mutex);
+static LIST_HEAD(trajectory_list);
+static unsigned int trajectory_count;
+
 /* Iso-identity measurement value. */
 static char measurement[WP256_DIGEST_SIZE];
 
@@ -197,6 +210,112 @@ static int add_contour_point(char *point)
 	return retn;
 }
 
+/**
+ *	add_trajectory_point - Add a point to the system behavior trajectory.
+ *	@filename: The name of the event.
+ *	@actor: The actor identity elements.
+ *	@subject: The subject identity elements.
+ *
+ *	Returns a non-zero value on a failure to add a point.
+ */
+
+static int add_trajectory_point(const char *filename,
+				struct actor_identity *actor,
+				struct subject_identity *subject)
+{
+	int retn = 1;
+	char *fname = NULL, *process = NULL;
+	struct trajectory *entry;
+
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	if (!entry)
+		goto done;
+	fname = kzalloc(strlen(filename), GFP_KERNEL);
+	if ( !fname )
+		goto done;
+	entry->filename = fname;
+	process = kzalloc(strlen(current->comm), GFP_KERNEL);
+	if (!process)
+		goto done;
+	entry->process = process;
+
+	strcpy(entry->filename, filename);
+	strcpy(entry->process, current->comm);
+	entry->actor = *actor;
+	entry->subject = *subject;
+
+	mutex_lock(&trajectory_list_mutex);
+	list_add_tail(&entry->list, &trajectory_list);
+	++trajectory_count;
+	mutex_unlock(&trajectory_list_mutex);
+	retn = 0;
+
+ done:
+	if (retn) {
+		kfree(entry);
+		kfree(fname);
+		kfree(process);
+	}
+	return retn;
+}
+
+static void *ima_trajectory_start(struct seq_file *c, loff_t *pos)
+{
+	if (*pos >= trajectory_count)
+		return NULL;
+
+	mutex_lock(&trajectory_list_mutex);
+	return seq_list_start(&trajectory_list, *pos);
+}
+
+static void *ima_trajectory_next(struct seq_file *c, void *p, loff_t *pos)
+{
+	return seq_list_next(p, &trajectory_list, pos);
+}
+
+static void ima_trajectory_stop(struct seq_file *c, void *pos)
+{
+	mutex_unlock(&trajectory_list_mutex);
+}
+
+static int ima_trajectory_show(struct seq_file *c, void *trajectory)
+{
+	struct trajectory *pt;
+
+	pt = list_entry(trajectory, struct trajectory, list);
+
+	seq_printf(c, "event{%s:%s} actor{uid=%d, euid=%d, suid=%d, gid=%d, egid=%d, sgid=%d, fsuid=%d, fsgid=%d, cap=%llx} subject{uid=%d, gid=%d, mode=o%o, name_length=%u, name=%*phN, s_id=%s, s_uuid=%*phN, digest=%*phN}\n",
+		   pt->process, pt->filename, pt->actor.uid, pt->actor.euid,
+		   pt->actor.suid, pt->actor.gid, pt->actor.egid,
+		   pt->actor.sgid, pt->actor.fsuid, pt->actor.fsgid,
+		   pt->actor.capability.value, pt->subject.uid,
+		   pt->subject.gid, pt->subject.mode, pt->subject.name_length,
+		   WP256_DIGEST_SIZE, pt->subject.name, pt->subject.s_id,
+		   (int) sizeof(pt->subject.s_uuid), pt->subject.s_uuid,
+		   WP256_DIGEST_SIZE, pt->subject.digest);
+
+	return 0;
+}
+
+static const struct seq_operations ima_trajectory_seqops = {
+	.start = ima_trajectory_start,
+	.next = ima_trajectory_next,
+	.stop = ima_trajectory_stop,
+	.show = ima_trajectory_show
+};
+
+static int ima_trajectory_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &ima_trajectory_seqops);
+}
+
+static const struct file_operations ima_trajectory_ops = {
+	.open = ima_trajectory_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = seq_release,
+};
+
 static void *ima_contours_start(struct seq_file *c, loff_t *pos)
 {
 	if (*pos >= contour_count)
@@ -791,9 +910,10 @@ static int ima_get_actor_identity(struct crypto_shash *tfm,
 	retn = crypto_shash_finup(&desc.shash, (char *) identity,
 				  sizeof(*identity), mapping);
 #if 0
-	pr_info("IMA[%s]: comm=%s, pid=%d, [ue]id=%d/%d, caps=%llx\n",
-		__func__, current->comm, current->pid, identity.uid,
-		identity.euid, identity.capability.value);
+	pr_info("IMA[%s]: comm=%s, pid=%d, [ue]id=%d/%d, caps=%llx, mapping=%*phN\n",
+		__func__, current->comm, current->pid, identity->uid,
+		identity->euid, identity->capability.value, WP256_DIGEST_SIZE,
+		mapping);
 #endif
 
  done:
@@ -875,7 +995,7 @@ static int ima_get_subject_identity(struct crypto_shash *tfm,
 	if (retn != 0)
 		goto done;
 
-	retn = crypto_shash_finup(&desc.shash, (char *) &subject,
+	retn = crypto_shash_finup(&desc.shash, (char *) subject,
 				  sizeof(struct subject_identity), identity);
 
  done:
@@ -1036,6 +1156,7 @@ int ima_identity_is_mapped(int function, struct integrity_iint_cache *iint,
 		return 1;
 	}
 
+#if 0
 	pr_info("[%s] actor uid=%d, euid=%d, suid=%d, gid=%d, egid=%d, sgid=%d, fsuid=%d, fsgid=%d, cap=%llx\n", __func__, actor.uid, actor.euid,
 		actor.suid, actor.gid, actor.egid, actor.sgid, actor.fsuid,
 		actor.fsgid, actor.capability.value);
@@ -1044,6 +1165,7 @@ int ima_identity_is_mapped(int function, struct integrity_iint_cache *iint,
 		subject.name_length, WP256_DIGEST_SIZE, subject.name,
 		subject.s_id, (int) sizeof(subject.s_uuid), subject.s_uuid,
 		WP256_DIGEST_SIZE, subject.digest);
+#endif
 
 	if (domain_sealed) {
 		retn = register_forensic_violation(function, iint, file,
@@ -1051,8 +1173,13 @@ int ima_identity_is_mapped(int function, struct integrity_iint_cache *iint,
 		if (retn == 0 )
 			retn = add_contour_point(mapping);
 	}
-	else
+	else {
 		retn = add_contour_point(mapping);
+		if (retn == 0)
+			retn = add_trajectory_point(pathname, &actor,
+						    &subject);
+	}
+
 
 #if 1
 	if (!retn)
@@ -1112,6 +1239,13 @@ int __init ima_identity_init(void)
 	if (IS_ERR(measurement_file))
 		goto err;
 
+	trajectory = securityfs_create_file("trajectory",
+					    S_IRUSR | S_IRGRP,
+					    identity_dir, NULL,
+					    &ima_trajectory_ops);
+	if (IS_ERR(trajectory))
+		goto err;
+
 	retn = 0;
 
  done:
@@ -1125,6 +1259,7 @@ int __init ima_identity_init(void)
 	securityfs_remove(sealed);
 	securityfs_remove(forensics);
 	securityfs_remove(measurement_file);
+	securityfs_remove(trajectory);
 
 	return retn;
 }
-- 
2.11.0

