From 4b4b4edde23a1cb8daffd88ac4d6a0bd4e24a505 Mon Sep 17 00:00:00 2001
From: "Dr. Greg Wettstein" <greg@enjellic.com>
Date: Tue, 4 Apr 2017 20:36:36 -0500
Subject: [PATCH 19/24] Initial implementation of system call based behavior
 definitions.

This update provides an initial implementation of the
set_behavior system call which provides support for configuring
various system behavior parameters.  This system call provides
what will be a 'namespace' friendly method of defining a static
system behavior configuration.

The initial implementation provides support for setting contour
points and defining file pseudonyms.

In order to streamline the implementation the routines which
implement the basic functionality noted above was lifted out of
the sysfs write routines into their own functions.  The sysfs
write routines and the system call now use this common
infrastructure.
---
 arch/x86/entry/syscalls/syscall_32.tbl |   1 +
 arch/x86/entry/syscalls/syscall_64.tbl |   1 +
 include/linux/syscalls.h               |   5 +
 include/uapi/asm-generic/unistd.h      |   5 +-
 kernel/sys_ni.c                        |   3 +
 security/integrity/ima/ima_identity.c  | 305 +++++++++++++++++++++------------
 6 files changed, 209 insertions(+), 111 deletions(-)

diff --git a/arch/x86/entry/syscalls/syscall_32.tbl b/arch/x86/entry/syscalls/syscall_32.tbl
index f17705e1332c..6ad57e17649c 100644
--- a/arch/x86/entry/syscalls/syscall_32.tbl
+++ b/arch/x86/entry/syscalls/syscall_32.tbl
@@ -383,3 +383,4 @@
 374	i386	userfaultfd		sys_userfaultfd
 375	i386	membarrier		sys_membarrier
 376	i386	mlock2			sys_mlock2
+377	i386	set_behavior		sys_set_behavior
diff --git a/arch/x86/entry/syscalls/syscall_64.tbl b/arch/x86/entry/syscalls/syscall_64.tbl
index 314a90bfc09c..946c8830de3d 100644
--- a/arch/x86/entry/syscalls/syscall_64.tbl
+++ b/arch/x86/entry/syscalls/syscall_64.tbl
@@ -332,6 +332,7 @@
 323	common	userfaultfd		sys_userfaultfd
 324	common	membarrier		sys_membarrier
 325	common	mlock2			sys_mlock2
+326	common	set_behavior		sys_set_behavior
 
 #
 # x32-specific system call numbers start at 512 to avoid cache impact
diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
index c2b66a277e98..33d37d64a554 100644
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@ -890,3 +890,8 @@ asmlinkage long sys_membarrier(int cmd, int flags);
 asmlinkage long sys_mlock2(unsigned long start, size_t len, int flags);
 
 #endif
+
+#ifdef CONFIG_IMA
+asmlinkage long sys_set_behavior(unsigned char __user * buf, size_t cnt,
+				 unsigned long flags);
+#endif
diff --git a/include/uapi/asm-generic/unistd.h b/include/uapi/asm-generic/unistd.h
index 1324b0292ec2..333dc99669bd 100644
--- a/include/uapi/asm-generic/unistd.h
+++ b/include/uapi/asm-generic/unistd.h
@@ -716,8 +716,11 @@ __SYSCALL(__NR_membarrier, sys_membarrier)
 #define __NR_mlock2 284
 __SYSCALL(__NR_mlock2, sys_mlock2)
 
+#define __NR_set_behavior 285
+__SYSCALL(__NR_set_behavior, sys_set_behavior)
+
 #undef __NR_syscalls
-#define __NR_syscalls 285
+#define __NR_syscalls 286
 
 /*
  * All syscalls below here should go away really,
diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 0623787ec67a..87abf5025597 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -249,3 +249,6 @@ cond_syscall(sys_execveat);
 
 /* membarrier */
 cond_syscall(sys_membarrier);
+
+/* Set system behavior parameters */
+cond_syscall(sys_set_behavior);
diff --git a/security/integrity/ima/ima_identity.c b/security/integrity/ima/ima_identity.c
index 4bf88ded3580..bac4c5745d91 100644
--- a/security/integrity/ima/ima_identity.c
+++ b/security/integrity/ima/ima_identity.c
@@ -15,11 +15,16 @@
  */
 #include <linux/namei.h>
 #include <linux/seq_file.h>
+#include <linux/syscalls.h>
 #include <crypto/hash.h>
 #include <crypto/hash_info.h>
 
 #include "ima.h"
 
+/* System call definitions. */
+#define IMA_SET_CONTOUR		0x1
+#define IMA_SET_PSEUDONYM	0x2
+
 /* Structure defining actor identity elements. */
 struct actor_identity {
 	uid_t uid;
@@ -374,6 +379,165 @@ static int update_behavior_measurement(struct crypto_shash *tfm, char *id)
 	return retn;
 }
 
+/**
+ *	load_pseudonym - Add a pseudonym entry to the system behavior
+ *	description.
+ *	@filename: The user space buffer containing the pathname of
+ *	the pseudonym.  This buffer is required to have a linefeed
+ *	character at the end of the buffer.
+ *	@datalen: The size of the pathname.
+ *
+ *	Returns a non-zero value on a failure to add a point.
+ */
+
+static int load_pseudonym(const char __user *pathbufr, size_t datalen)
+{
+	char *p, *bufr = NULL;
+	int retn = -EINVAL;
+	size_t amt;
+	struct inode *inode;
+	struct path path;
+	struct integrity_iint_cache *iint;
+
+	if (datalen > PAGE_SIZE)
+		return -EINVAL;
+
+	bufr = kzalloc(datalen, GFP_KERNEL);
+	if (!bufr) {
+		retn = -ENOMEM;
+		goto done;
+	}
+
+	if (copy_from_user(bufr, pathbufr, datalen)) {
+		retn = -EFAULT;
+		goto done;
+	}
+
+	p = strchr(bufr, '\n');
+	if (!p) {
+		retn = -EINVAL;
+		goto done;
+	}
+	*p = '\0';
+
+	retn = kern_path(bufr, LOOKUP_FOLLOW, &path);
+	if (retn)
+		goto done;
+	inode = path.dentry->d_inode;
+
+	mutex_lock(&inode->i_mutex);
+	iint = integrity_inode_get(inode);
+	mutex_unlock(&inode->i_mutex);
+	if (!iint) {
+		retn = -ENOENT;
+		goto done;
+	}
+	pr_info("[%s]: Mapped pseudonym for %s, iint=%p, inum=%ld\n",
+		__func__, bufr, iint, inode->i_ino);
+	iint->flags |= (IMA_PSEUDONYM | IMA_COLLECTED);
+	iint->version = inode->i_version;
+
+	amt = sizeof(struct ima_digest_data) + WP256_DIGEST_SIZE;
+	iint->ima_hash = kzalloc(amt, GFP_KERNEL);
+	if (iint->ima_hash == NULL) {
+		retn = -ENOMEM;
+		goto done;
+	}
+	iint->ima_hash->algo = HASH_ALGO_SHA256;
+	iint->ima_hash->length = WP256_DIGEST_SIZE;
+
+	retn = 0;
+
+done:
+	kfree(bufr);
+
+	return retn;
+}
+
+/**
+ *	load_contour - Add a contour point to the system behavior
+ *	description.
+ *	@contour: The buffer containing the contour point in ASCII
+ *	hexadecimal format.
+ *	@datalen: The size of the buffer.
+ *
+ *	Returns a non-zero value on a failure to add a point.
+ */
+
+static int load_contour(const char __user *contour, size_t datalen)
+{
+	char *p, idbufr[WP256_DIGEST_SIZE*2 + 1], mapping[WP256_DIGEST_SIZE],
+		tpm_digest[SHA1_DIGEST_SIZE];
+	ssize_t retn;
+	struct crypto_shash *tfmsha1 = NULL, *tfmsha256 = NULL;
+
+	if (datalen != sizeof(idbufr)) {
+		retn = -EINVAL;
+		goto done;
+	}
+
+	memset(idbufr, '\0', sizeof(idbufr));
+	if (copy_from_user(idbufr, contour, datalen)) {
+		retn = -EFAULT;
+		goto done;
+	}
+
+	p = strchr(idbufr, '\n');
+	if (!p) {
+		retn = -EINVAL;
+		goto done;
+	}
+	*p = '\0';
+	if (hex2bin(mapping, idbufr, sizeof(mapping))) {
+		retn = -EINVAL;
+		goto done;
+	}
+
+	if (have_contour(mapping)) {
+		retn = datalen;
+		goto done;
+	}
+	if (add_contour_point(mapping)) {
+		retn = -ENOMEM;
+		goto done;
+	}
+
+	/* Add the contour point measurement. */
+	tfmsha1 = crypto_alloc_shash("sha1", 0, 0);
+	if (IS_ERR(tfmsha1)) {
+		retn = PTR_ERR(tfmsha1);
+		goto done;
+	}
+	tfmsha256 = crypto_alloc_shash("sha256", 0, 0);
+	if (IS_ERR(tfmsha256)) {
+		retn = PTR_ERR(tfmsha256);
+		goto done;
+	}
+
+        retn = update_behavior_measurement(tfmsha256, mapping);
+	if (retn != 0)
+		goto done;
+
+	retn = get_host_measurement(tfmsha1, mapping, WP256_DIGEST_SIZE,
+				    tpm_digest);
+	if (retn != 0)
+		goto done;
+	retn = ima_pcr_extend(tpm_digest);
+	if (retn != 0)
+		goto done;
+
+	retn = 0;
+
+done:
+	if (tfmsha1)
+		crypto_free_shash(tfmsha1);
+	if (tfmsha256)
+		crypto_free_shash(tfmsha256);
+
+	return retn;
+
+}
+
 static void *ima_trajectory_start(struct seq_file *c, loff_t *pos)
 {
 	if (*pos >= trajectory_count)
@@ -490,79 +654,20 @@ static int ima_open_map(struct inode * inode, struct file * filp)
 static ssize_t ima_write_map(struct file *file, const char __user *buf,
 			     size_t datalen, loff_t *ppos)
 {
-	char *p, idbufr[WP256_DIGEST_SIZE*2 + 1], mapping[WP256_DIGEST_SIZE],
-		tpm_digest[SHA1_DIGEST_SIZE];
 	ssize_t retn;
-	struct crypto_shash *tfmsha1 = NULL, *tfmsha256 = NULL;
-
-	if (datalen != sizeof(idbufr)) {
-		retn = -EINVAL;
-		goto done;
-	}
 
 	if (*ppos != 0) {
 		retn = -EINVAL;
 		goto done;
 	}
 
-	memset(idbufr, '\0', sizeof(idbufr));
-	if (copy_from_user(idbufr, buf, datalen)) {
-		retn = -EFAULT;
-		goto done;
-	}
-
-	p = strchr(idbufr, '\n');
-	if (!p) {
-		retn = -EINVAL;
-		goto done;
-	}
-	*p = '\0';
-	if (hex2bin(mapping, idbufr, sizeof(mapping))) {
-		retn = -EINVAL;
-		goto done;
-	}
-
-	if (have_contour(mapping)) {
-		retn = datalen;
-		goto done;
-	}
-	if (add_contour_point(mapping)) {
-		retn = -ENOMEM;
-		goto done;
-	}
-
-	/* Add the contour point measurement. */
-	tfmsha1 = crypto_alloc_shash("sha1", 0, 0);
-	if (IS_ERR(tfmsha1)) {
-		retn = PTR_ERR(tfmsha1);
-		goto done;
-	}
-	tfmsha256 = crypto_alloc_shash("sha256", 0, 0);
-	if (IS_ERR(tfmsha256)) {
-		retn = PTR_ERR(tfmsha256);
-		goto done;
-	}
-
-        retn = update_behavior_measurement(tfmsha256, mapping);
-	if (retn != 0)
-		goto done;
-
-	retn = get_host_measurement(tfmsha1, mapping, WP256_DIGEST_SIZE,
-				    tpm_digest);
-	if (retn != 0)
-		goto done;
-	retn = ima_pcr_extend(tpm_digest);
-	if (retn != 0)
+	retn = load_contour(buf, datalen);
+	if ( retn != 0 )
 		goto done;
 
 	retn = datalen;
 
 done:
-	if (tfmsha1)
-		crypto_free_shash(tfmsha1);
-	if (tfmsha256)
-		crypto_free_shash(tfmsha256);
-
 	return retn;
 }
 
@@ -589,12 +694,7 @@ static int ima_open_pseudonym(struct inode * inode, struct file * filp)
 static ssize_t ima_write_pseudonym(struct file *file, const char __user *buf,
 				   size_t datalen, loff_t *ppos)
 {
-	size_t amt;
-	char *p, *bufr = NULL;
 	ssize_t retn;
-	struct inode *inode;
-	struct path path;
-	struct integrity_iint_cache *iint;
 
 	if (datalen > PAGE_SIZE) {
 		retn = -EINVAL;
@@ -606,55 +706,13 @@ static ssize_t ima_write_pseudonym(struct file *file, const char __user *buf,
 		goto done;
 	}
 
-	bufr = kzalloc(datalen, GFP_KERNEL);
-	if (!bufr) {
-		retn = -ENOMEM;
-		goto done;
-	}
-
-	if (copy_from_user(bufr, buf, datalen)) {
-		retn = -EFAULT;
-		goto done;
-	}
-
-	p = strchr(bufr, '\n');
-	if (!p) {
-		retn = -EINVAL;
-		goto done;
-	}
-	*p = '\0';
-
-	retn = kern_path(bufr, LOOKUP_FOLLOW, &path);
-	if (retn)
-		goto done;
-	inode = path.dentry->d_inode;
-
-	mutex_lock(&inode->i_mutex);
-	iint = integrity_inode_get(inode);
-	mutex_unlock(&inode->i_mutex);
-	if (!iint) {
-		retn = -ENOENT;
-		goto done;
-	}
-	pr_info("[%s]: Mapped pseudonym for %s, iint=%p, inum=%ld\n",
-		__func__, bufr, iint, inode->i_ino);
-	iint->flags |= (IMA_PSEUDONYM | IMA_COLLECTED);
-	iint->version = inode->i_version;
-
-	amt = sizeof(struct ima_digest_data) + WP256_DIGEST_SIZE;
-	iint->ima_hash = kzalloc(amt, GFP_KERNEL);
-	if (iint->ima_hash == NULL) {
-		retn = -ENOMEM;
+	retn = load_pseudonym(buf, datalen);
+	if ( retn != 0 )
 		goto done;
-	}
-	iint->ima_hash->algo = HASH_ALGO_SHA256;
-	iint->ima_hash->length = WP256_DIGEST_SIZE;
 
 	retn = datalen;
 
 done:
-	kfree(bufr);
-
 	return retn;
 }
 
@@ -1316,3 +1374,30 @@ int __init ima_identity_init(void)
 
 	return retn;
 }
+
+SYSCALL_DEFINE3(set_behavior, unsigned char *, bufr, size_t, cnt,
+		unsigned long, flags)
+{
+	int retn = -EINVAL;
+
+	pr_info("[%s]: Called: cnt=%zu, flags=%lu.\n", __func__, cnt, flags);
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+	if (flags & ~(IMA_SET_CONTOUR | IMA_SET_PSEUDONYM))
+		return -EINVAL;
+
+
+	if (flags & IMA_SET_PSEUDONYM) {
+		retn = load_pseudonym(bufr, cnt);
+		goto done;
+	}
+
+	if (flags & IMA_SET_CONTOUR) {
+		retn = load_contour(bufr, cnt);
+		goto done;
+	}
+
+ done:
+	return retn;
+}
-- 
2.11.0

