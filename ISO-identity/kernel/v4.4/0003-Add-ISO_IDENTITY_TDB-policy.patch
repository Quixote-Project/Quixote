From 2a7a0ae7e029330c4b5fd1b544692c7807663f2e Mon Sep 17 00:00:00 2001
From: "Dr. Greg Wettstein" <gw@idfusion.org>
Date: Fri, 30 Dec 2016 11:56:04 -0600
Subject: [PATCH 03/24] Add ISO_IDENTITY_TDB policy.

This update implements definitions for the iso-identity mapping
policy.  If configured this policy implements the mapping of
information exchange events to yield a system behavior
measurement.

An information exchange event consists of an actor identity
operating on a subject identity.   The 'fusioning' of the actor
and subject identities yields a unique measurement value for the
exchange event.

If viewed from the perspective of the actor process this mapping
can be thought of as a set of mutually exclusive planes which
define the permitted behaviors of an actor process.   The
interaction of the actor identity with the field plane can be
thought of as a contour within which the actor process must
operate to stay within the desired behavior of the system.
---
 security/integrity/ima/ima_policy.c | 48 +++++++++++++++++++++++++++++++++++--
 security/integrity/integrity.h      |  4 +++-
 2 files changed, 49 insertions(+), 3 deletions(-)

diff --git a/security/integrity/ima/ima_policy.c b/security/integrity/ima/ima_policy.c
index 49f5f93a8b2d..1330d7045d45 100644
--- a/security/integrity/ima/ima_policy.c
+++ b/security/integrity/ima/ima_policy.c
@@ -37,6 +37,8 @@
 #define APPRAISE	0x0004	/* same as IMA_APPRAISE */
 #define DONT_APPRAISE	0x0008
 #define AUDIT		0x0040
+#define MAP		0x010000	/* same as IMA_MAP */
+#define DONT_MAP	0x020000
 
 int ima_policy_flag;
 
@@ -45,7 +47,7 @@ enum lsm_rule_types { LSM_OBJ_USER, LSM_OBJ_ROLE, LSM_OBJ_TYPE,
 	LSM_SUBJ_USER, LSM_SUBJ_ROLE, LSM_SUBJ_TYPE
 };
 
-enum policy_types { ORIGINAL_TCB = 1, DEFAULT_TCB };
+enum policy_types { ORIGINAL_TCB = 1, DEFAULT_TCB, ISO_IDENTITY_TCB };
 
 struct ima_rule_entry {
 	struct list_head list;
@@ -114,6 +116,17 @@ static struct ima_rule_entry default_measurement_rules[] = {
 	{.action = MEASURE, .func = FIRMWARE_CHECK, .flags = IMA_FUNC},
 };
 
+static struct ima_rule_entry iso_identity_measurement_rules[] = {
+	{.action = MAP,.func = MMAP_CHECK,.mask = MAY_EXEC,
+	 .flags = IMA_FUNC | IMA_MASK},
+	{.action = MAP,.func = BPRM_CHECK,.mask = MAY_EXEC,
+	 .flags = IMA_FUNC | IMA_MASK},
+	{.action = MAP, .func = FILE_CHECK, .mask = MAY_READ,
+	 .uid = GLOBAL_ROOT_UID, .capability = CAP_FULL_SET,
+	 .flags = IMA_FUNC | IMA_INMASK | IMA_CAPABILITY},
+	{.action = MAP,.func = MODULE_CHECK, .flags = IMA_FUNC},
+};
+
 static struct ima_rule_entry default_appraise_rules[] = {
 	{.action = DONT_APPRAISE, .fsmagic = PROC_SUPER_MAGIC, .flags = IMA_FSMAGIC},
 	{.action = DONT_APPRAISE, .fsmagic = SYSFS_MAGIC, .flags = IMA_FSMAGIC},
@@ -160,6 +173,9 @@ static int __init policy_setup(char *str)
 	if (strcmp(str, "tcb") == 0)
 		ima_policy = DEFAULT_TCB;
 
+	if (strcmp(str, "iso-identity") == 0)
+		ima_policy = ISO_IDENTITY_TCB;
+
 	return 1;
 }
 __setup("ima_policy=", policy_setup);
@@ -400,8 +416,11 @@ void __init ima_init_policy(void)
 	appraise_entries = ima_use_appraise_tcb ?
 			 ARRAY_SIZE(default_appraise_rules) : 0;
 
-	for (i = 0; i < measure_entries; i++)
+	for (i = 0; i < measure_entries; i++) {
+		if (ima_policy == ISO_IDENTITY_TCB)
+			dont_measure_rules[i].action = DONT_MAP;
 		list_add_tail(&dont_measure_rules[i].list, &ima_default_rules);
+	}
 
 	switch (ima_policy) {
 	case ORIGINAL_TCB:
@@ -413,6 +432,12 @@ void __init ima_init_policy(void)
 		for (i = 0; i < ARRAY_SIZE(default_measurement_rules); i++)
 			list_add_tail(&default_measurement_rules[i].list,
 				      &ima_default_rules);
+		break;
+	case ISO_IDENTITY_TCB:
+		for (i = 0; i < ARRAY_SIZE(iso_identity_measurement_rules); i++)
+			list_add_tail(&iso_identity_measurement_rules[i].list,
+				      &ima_default_rules);
+		break;
 	default:
 		break;
 	}
@@ -443,6 +468,7 @@ enum {
 	Opt_measure = 1, Opt_dont_measure,
 	Opt_appraise, Opt_dont_appraise,
 	Opt_audit,
+	Opt_map, Opt_dont_map,
 	Opt_obj_user, Opt_obj_role, Opt_obj_type,
 	Opt_subj_user, Opt_subj_role, Opt_subj_type,
 	Opt_func, Opt_mask, Opt_fsmagic,
@@ -456,6 +482,8 @@ static match_table_t policy_tokens = {
 	{Opt_appraise, "appraise"},
 	{Opt_dont_appraise, "dont_appraise"},
 	{Opt_audit, "audit"},
+	{Opt_map, "map"},
+	{Opt_dont_map, "dont_map"},
 	{Opt_obj_user, "obj_user=%s"},
 	{Opt_obj_role, "obj_role=%s"},
 	{Opt_obj_type, "obj_type=%s"},
@@ -570,6 +598,22 @@ static int ima_parse_rule(char *rule, struct ima_rule_entry *entry)
 
 			entry->action = AUDIT;
 			break;
+		case Opt_map:
+			ima_log_string(ab, "action", "map");
+
+			if (entry->action != UNKNOWN)
+				result = -EINVAL;
+
+			entry->action = MAP;
+			break;
+		case Opt_dont_map:
+			ima_log_string(ab, "action", "dont map");
+
+			if (entry->action != UNKNOWN)
+				result = -EINVAL;
+
+			entry->action = DONT_MAP;
+			break;
 		case Opt_func:
 			ima_log_string(ab, "func", args[0].from);
 
diff --git a/security/integrity/integrity.h b/security/integrity/integrity.h
index 9c6168709d3b..dca60d98773f 100644
--- a/security/integrity/integrity.h
+++ b/security/integrity/integrity.h
@@ -25,6 +25,7 @@
 #define IMA_COLLECTED		0x00000020
 #define IMA_AUDIT		0x00000040
 #define IMA_AUDITED		0x00000080
+#define IMA_MAP			0x00010000
 
 /* iint cache flags */
 #define IMA_ACTION_FLAGS	0xff000000
@@ -32,9 +33,10 @@
 #define IMA_DIGSIG_REQUIRED	0x02000000
 #define IMA_PERMIT_DIRECTIO	0x04000000
 #define IMA_NEW_FILE		0x08000000
+#define IMA_PSEUDONYM		0x10000000
 
 #define IMA_DO_MASK		(IMA_MEASURE | IMA_APPRAISE | IMA_AUDIT | \
-				 IMA_APPRAISE_SUBMASK)
+				 IMA_MAP | IMA_APPRAISE_SUBMASK)
 #define IMA_DONE_MASK		(IMA_MEASURED | IMA_APPRAISED | IMA_AUDITED | \
 				 IMA_COLLECTED | IMA_APPRAISED_SUBMASK)
 
-- 
2.11.0

