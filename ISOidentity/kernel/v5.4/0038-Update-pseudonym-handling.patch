From f8418c3ea1dd7e8646e075fe4b8dbb55d1ed9382 Mon Sep 17 00:00:00 2001
From: "Dr. Greg" <greg@enjellic.com>
Date: Sat, 27 Mar 2021 19:21:12 -0500
Subject: [PATCH 38/50] Update pseudonym handling.

This commit re-works pseudonym handling to make it correct and
properly applicable to namespaces.

A pseudonym was previously handled by setting the IMA_PSEUDONYM
bit in the flags element of the integrity inode structure.  This
led to incorrect behavior when an inode had multiple attempted
writes and was a global rather then a namespace specific
construct.

The prior implementation also essentially re-created the
'open-writers' and Time Of Measurement Time Of Use (TOMTOU)
detection logic in the ima_events.c file.  In fact the previous
implementation ended up not even calling the
ima_rdwr_violation_check() function.

This patch changes the logic in the process_measurement()
function so that ima_rdwr_violation_check() is called if the
IMA_MAP policy is set.  The integrity inode structure for an
inode is unconditionally looked up in this function.

If the inode has been tagged as a pseudonym and there is an
open_writers or TOMTOU violation the function returns with
creating an audit entry.  In order to provide this functionality
a new function, ima_events_is_pseudonym(), was created with
global scope to determine if the integrity inode structure has
been classifed as a pseudonymin in the current namespace.

A list entry is added to the events namespace map to track
pseudonym declarations in a namespace.  Writing a pathname to the
/sys/kernel/security/integrity/events/psedounym pseudo-file
causes a structure entry to be added to this list that contains
the pointer to the integrity inode structure.  This allows
pseudonyms to function as a namespace specific construction.

The ima_events_genhash() function sets the digest value for a
pseudonym to be all zero's.  This update sets the digest value to
be all 'FF' values if a digest entry has not calculated for an
inode, otherwise the computed digest entry is used.

All of this allowed the have_violation() function to be removed
since the 'open-writers' and TOMTOU checks are now only needed in
the original location.
---
 security/integrity/ima/ima.h        |   1 +
 security/integrity/ima/ima_events.c | 142 ++++++++++++++++------------
 security/integrity/ima/ima_main.c   |  21 +++-
 3 files changed, 99 insertions(+), 65 deletions(-)

diff --git a/security/integrity/ima/ima.h b/security/integrity/ima/ima.h
index b89d0e3227d6..31bac6f7df8a 100644
--- a/security/integrity/ima/ima.h
+++ b/security/integrity/ima/ima.h
@@ -174,6 +174,7 @@ int ima_get_subject(struct ima_event_data *, struct ima_field_data *, char *);
 int ima_events_is_mapped(int, struct integrity_iint_cache *iint,
 			 struct file *file, const char *pathname,
 			   struct ima_template_desc *, int);
+bool ima_events_is_pseudonym(struct integrity_iint_cache *iint);
 int ima_fs_init(void);
 struct dentry *ima_fs_init_events(void);
 
diff --git a/security/integrity/ima/ima_events.c b/security/integrity/ima/ima_events.c
index 72c3901ef2ce..12c2c2fc2f87 100644
--- a/security/integrity/ima/ima_events.c
+++ b/security/integrity/ima/ima_events.c
@@ -165,6 +165,12 @@ struct event {
 	} u;
 };
 
+/* Structure defining an event pseudonym. */
+struct pseudonym {
+	struct list_head list;
+
+	struct integrity_iint_cache *iint;
+};
 
 /*
  * The following structure encapsulates all of the information needed
@@ -194,6 +200,9 @@ struct ima_events_map {
 	struct mutex measurement_mutex;
 	struct list_head measurement_list;
 
+	struct mutex pseudonym_mutex;
+	struct list_head pseudonym_list;
+
 	struct AIevent *AI_events;
 
 	struct kobj_attribute update;
@@ -210,6 +219,9 @@ struct ima_events_map {
 	.measurement_mutex = __MUTEX_INITIALIZER(init_ima_events_map.measurement_mutex),
 	.measurement_list = LIST_HEAD_INIT(init_ima_events_map.measurement_list),
 
+	.pseudonym_mutex = __MUTEX_INITIALIZER(init_ima_events_map.pseudonym_mutex),
+	.pseudonym_list = LIST_HEAD_INIT(init_ima_events_map.pseudonym_list),
+
 	.AI_events = AI_events
 };
 
@@ -627,10 +639,11 @@ static int load_pseudonym(const char __user *pathbufr, size_t datalen)
 {
 	char *p, *bufr = NULL;
 	int retn = -EINVAL;
-	size_t amt;
 	struct inode *inode;
 	struct path path;
+	struct pseudonym *pseudonym;
 	struct integrity_iint_cache *iint;
+	struct ima_events_map *map = current_map();
 
 	if (datalen > PAGE_SIZE)
 		return -EINVAL;
@@ -666,25 +679,19 @@ static int load_pseudonym(const char __user *pathbufr, size_t datalen)
 		goto done;
 	}
 
-	pr_debug("[%s]: Mapping pseudonym for %s, iint=%p, inum=%ld\n",
-		 __func__, bufr, iint, inode->i_ino);
-
-	iint->flags |= (IMA_PSEUDONYM | IMA_COLLECTED);
-#if 0
-	iint->version = inode->i_version;
-#else
-	iint->version = inode_query_iversion(inode);
-#endif
-
-	amt = sizeof(struct ima_digest_data) + WP256_DIGEST_SIZE;
-	iint->ima_hash = kzalloc(amt, GFP_KERNEL);
-	if (iint->ima_hash == NULL) {
+	pseudonym = kzalloc(sizeof(struct event), GFP_KERNEL);
+	if (!pseudonym) {
 		retn = -ENOMEM;
 		goto done;
 	}
-	iint->ima_hash->algo = HASH_ALGO_SHA256;
-	iint->ima_hash->length = WP256_DIGEST_SIZE;
+	pseudonym->iint = iint;
+
+	mutex_lock(&map->pseudonym_mutex);
+	list_add_tail(&pseudonym->list, &map->pseudonym_list);
+	mutex_unlock(&map->pseudonym_mutex);
 
+	pr_debug("Mapped %s as inode pseudonym: %ld\n", bufr,
+		 iint->inode->i_ino);
 	retn = 0;
 
 done:
@@ -1372,46 +1379,6 @@ static const struct file_operations ima_measurement_ops = {
 	.release = seq_release,
 };
 
-static int have_violation(struct file *file, struct integrity_iint_cache *iint,
-			  const char *pathname)
-{
-	bool tomtou = false, writers = false;
-	struct inode *inode = file_inode(file);
-
-	/* Check for possible violation conditions. */
-	if (file->f_mode & FMODE_WRITE) {
-		if (atomic_read(&inode->i_readcount) && IS_IMA(inode)) {
-			if (!iint)
-				iint = integrity_iint_find(inode);
-			if (iint && test_bit(IMA_MUST_MEASURE,
-						&iint->atomic_flags))
-			tomtou = true;
-		}
-
-	}
-
-	if (iint->flags & IMA_PSEUDONYM) {
-		if (tomtou)
-			pr_debug("[%s]: Pseudonym inhibited TOMTOU violation\n",
-				 __func__);
-		if (writers)
-			pr_debug("[%s]: Pseudonym inibited writers violation\n",
-				 __func__);
-		return 0;
-	}
-
-	if (tomtou || writers) {
-		if (tomtou)
-			ima_add_violation(file, pathname, iint, "invalid_pcr",
-					  "ToMToU");
-		if (writers)
-			ima_add_violation(file, pathname, iint, "invalid_pcr",
-					  "open_writers");
-	}
-
-	return tomtou || writers;
-}
-
 int ima_events_genhash(struct ima_template_entry *entry, char *tpm_digest)
 {
 	int retn;
@@ -1586,8 +1553,17 @@ int ima_get_subject(struct ima_event_data *event_data,
 		goto done;
 
 	/* Add the digest of the subject. */
-	memcpy(subject->digest, event_data->iint->ima_hash->digest,
-	       WP256_DIGEST_SIZE);
+	if (event_data->iint->ima_hash == NULL)
+		memset(subject->digest, 0xff, WP256_DIGEST_SIZE);
+	else
+		memcpy(subject->digest, event_data->iint->ima_hash->digest,
+		       WP256_DIGEST_SIZE);
+
+	if (ima_events_is_pseudonym(event_data->iint)) {
+		pr_debug("Setting pseudonym digest for: %ld\n",
+			 event_data->iint->inode->i_ino);
+		memset(subject->digest, 0x00, WP256_DIGEST_SIZE);
+	}
 
 	/* Add subject characteristics. */
 	if (event_data->file) {
@@ -1744,9 +1720,6 @@ int ima_events_is_mapped(int function, struct integrity_iint_cache *iint,
 	struct crypto_shash *sha256 = NULL;
 	struct ima_events_map *map = current_map();
 
-	if (have_violation(file, iint, pathname))
-		return 1;
-
 	if (ima_map_event(function, iint, template_desc, file, pathname,
 			  &actor, &subject, mapping) != 0)
 		return 0;
@@ -1901,6 +1874,38 @@ int __init ima_events_init(void)
 	return retn;
 }
 
+/**
+ * ima_events_is_pseudonym() - Test if inode is a pseudonym
+ * @iint: Inode to be checked for pseudonym status.
+ *
+ * This function checks whether or not the pointer to the integrity
+ * inode is on the namespace specific instance list of inodes that
+ * have been declared to be a pseudony.
+ *
+ * Returns true if the inode is a pseudonym, false otherwise.
+ */
+
+bool ima_events_is_pseudonym(struct integrity_iint_cache *iint)
+{
+	bool retn = false;
+	struct ima_events_map *map = current_map();
+	struct pseudonym *entry;
+
+	mutex_lock(&map->pseudonym_mutex);
+	list_for_each_entry(entry, &map->pseudonym_list, list) {
+		if (entry->iint == iint) {
+			retn = true;
+			goto done;
+		}
+	}
+
+ done:
+	mutex_unlock(&map->pseudonym_mutex);
+	if (retn)
+		pr_debug("Found pseudonym inode: %ld\n", iint->inode->i_ino);
+	return retn;
+}
+
 int ima_measure_ns(const u8 *hash)
 {
 	int retn = 1;
@@ -1935,6 +1940,7 @@ void ima_free_ns(struct kref *kref)
 	struct ima_events_namespace *ns;
 	struct event_point *centry, *tmp_centry;
 	struct trajectory *tentry, *tmp_tentry;
+	struct pseudonym *sentry, *tmp_sentry;
 
 	ns = container_of(kref, struct ima_events_namespace, kref);
 
@@ -1962,6 +1968,17 @@ void ima_free_ns(struct kref *kref)
 	}
 	pr_debug("[%s]: Released %d trajectory entries.\n", __func__, cnt);
 
+	cnt = 0;
+	list_for_each_entry_safe(sentry, tmp_sentry, &ns->map->pseudonym_list,
+				 list) {
+		pr_debug("Removed pseudonym: %ld\n",
+			 sentry->iint->inode->i_ino);
+		list_del(&sentry->list);
+		kfree(sentry);
+		++cnt;
+	}
+	pr_debug("Released %d pseudonyms.\n", cnt);
+
 	if (ns->map->domain_sealed) {
 		cnt = 0;
 		list_for_each_entry_safe(tentry, tmp_tentry,
@@ -2034,6 +2051,9 @@ struct ima_events_namespace *ima_copy_events_ns(unsigned long flags,
 	mutex_init(&ns->map->measurement_mutex);
 	INIT_LIST_HEAD(&ns->map->measurement_list);
 
+	mutex_init(&ns->map->pseudonym_mutex);
+	INIT_LIST_HEAD(&ns->map->pseudonym_list);
+
 	ns->map->AI_events = kzalloc(sizeof(AI_events), GFP_KERNEL);
 	if (!ns->map->AI_events) {
 		retn = -ENOMEM;
diff --git a/security/integrity/ima/ima_main.c b/security/integrity/ima/ima_main.c
index 14631565894a..815806a07c91 100644
--- a/security/integrity/ima/ima_main.c
+++ b/security/integrity/ima/ima_main.c
@@ -114,10 +114,11 @@ static void ima_rdwr_violation_check(struct file *file,
 	fmode_t mode = file->f_mode;
 	bool send_tomtou = false, send_writers = false;
 
+	if (IS_IMA(inode) && !iint)
+		iint = integrity_iint_find(inode);
+
 	if (mode & FMODE_WRITE) {
 		if (atomic_read(&inode->i_readcount) && IS_IMA(inode)) {
-			if (!iint)
-				iint = integrity_iint_find(inode);
 			/* IMA_MEASURE is set from reader side */
 			if (iint && test_bit(IMA_MUST_MEASURE,
 						&iint->atomic_flags))
@@ -130,6 +131,16 @@ static void ima_rdwr_violation_check(struct file *file,
 			send_writers = true;
 	}
 
+	if (ima_events_is_pseudonym(iint)) {
+		if (send_tomtou)
+			pr_debug("Pseudonym %ld inhibited TOMTOU violation.\n",
+				 iint->inode->i_ino);
+		if (send_writers)
+			pr_debug("Pseudonym %ld inibited writers violation.\n",
+				 iint->inode->i_ino);
+		return;
+	}
+
 	if (!send_tomtou && !send_writers)
 		return;
 
@@ -217,7 +228,8 @@ static int process_measurement(struct file *file, const struct cred *cred,
 	action = ima_get_action(inode, cred, secid, mask, func, &pcr,
 				&template_desc);
 	violation_check = ((func == FILE_CHECK || func == MMAP_CHECK) &&
-			   (ima_policy_flag & IMA_MEASURE));
+			   ((ima_policy_flag & IMA_MEASURE) ||
+			    ima_policy_flag & IMA_MAP));
 	if (!action && !violation_check)
 		return 0;
 
@@ -236,7 +248,8 @@ static int process_measurement(struct file *file, const struct cred *cred,
 	}
 
 	if (!rc && violation_check)
-		ima_rdwr_violation_check(file, iint, action & IMA_MEASURE,
+		ima_rdwr_violation_check(file, iint,
+					 action & (IMA_MEASURE | IMA_MAP),
 					 &pathbuf, &pathname, filename);
 
 	inode_unlock(inode);
-- 
2.31.1

