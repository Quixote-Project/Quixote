From 08693a56c2b5c43039cbf934e28dd77e8b54cd7a Mon Sep 17 00:00:00 2001
From: "Dr. Greg" <greg@enjellic.com>
Date: Fri, 5 Feb 2021 03:16:56 -0600
Subject: [PATCH 06/50] Retire iso_identity name prefix.

This update converts the integrity events infrastructure to use
the 'ima_events' prefix rather then 'iso_identity'.
---
 include/linux/ima.h                 |  14 +--
 include/linux/nsproxy.h             |   4 +-
 security/integrity/ima/ima_events.c | 148 ++++++++++++++--------------
 security/integrity/ima/ima_policy.c |   6 +-
 4 files changed, 86 insertions(+), 86 deletions(-)

diff --git a/include/linux/ima.h b/include/linux/ima.h
index 7192349b022a..0d9059efb326 100644
--- a/include/linux/ima.h
+++ b/include/linux/ima.h
@@ -13,11 +13,11 @@
 struct linux_binprm;
 
 #ifdef CONFIG_IMA
-struct iso_identity_map;
+struct ima_events_map;
 
-struct iso_identity_namespace {
+struct ima_events_namespace {
 	struct kref kref;
-	struct iso_identity_map *map;
+	struct ima_events_map *map;
 	struct user_namespace *user_ns;
 	struct ns_common ns;
 };
@@ -53,17 +53,17 @@ static inline const char * const *arch_get_ima_policy(void)
 }
 #endif
 
-extern struct iso_identity_namespace * ima_copy_behavior_ns(unsigned long,
+extern struct ima_events_namespace * ima_copy_behavior_ns(unsigned long,
 					      struct user_namespace *,
-					      struct iso_identity_namespace *);
+					      struct ima_events_namespace *);
 extern int ima_measure_ns(const u8 *);
 extern void ima_free_ns(struct kref *);
 
-static inline void ima_get_ns(struct iso_identity_namespace *ns)
+static inline void ima_get_ns(struct ima_events_namespace *ns)
 {
 	kref_get(&ns->kref);
 }
-static inline void ima_put_ns(struct iso_identity_namespace *ns)
+static inline void ima_put_ns(struct ima_events_namespace *ns)
 {
 	kref_put(&ns->kref, ima_free_ns);
 }
diff --git a/include/linux/nsproxy.h b/include/linux/nsproxy.h
index a99f2b4f911f..807714921676 100644
--- a/include/linux/nsproxy.h
+++ b/include/linux/nsproxy.h
@@ -11,7 +11,7 @@ struct ipc_namespace;
 struct pid_namespace;
 struct cgroup_namespace;
 struct fs_struct;
-struct iso_identity_namespace;
+struct ima_events_namespace;
 
 /*
  * A structure to contain pointers to all per-process
@@ -37,7 +37,7 @@ struct nsproxy {
 	struct pid_namespace *pid_ns_for_children;
 	struct net 	     *net_ns;
 	struct cgroup_namespace *cgroup_ns;
-	struct iso_identity_namespace *behavior_ns;
+	struct ima_events_namespace *behavior_ns;
 };
 extern struct nsproxy init_nsproxy;
 
diff --git a/security/integrity/ima/ima_events.c b/security/integrity/ima/ima_events.c
index b534c7fb05f5..f4e179ec8fcf 100644
--- a/security/integrity/ima/ima_events.c
+++ b/security/integrity/ima/ima_events.c
@@ -85,7 +85,7 @@ static struct dentry *forensics;
 static struct dentry *measurement_file;
 static struct dentry *trajectory;
 
-static struct kobject *iso_identity_kobject;
+static struct kobject *ima_events_kobject;
 
 
 /* Structure defining an ai security event. */
@@ -170,7 +170,7 @@ struct event {
  * The following structure encapsulates all of the information needed
  * to support a behavior namespace.
  */
-struct iso_identity_map {
+struct ima_events_map {
 	char hostid[WP256_DIGEST_SIZE];
 	char measurement [WP256_DIGEST_SIZE];
 
@@ -194,25 +194,25 @@ struct iso_identity_map {
 	struct AIevent *AI_events;
 
 	struct kobj_attribute update;
-} init_iso_identity_map = {
-	.contour_list_mutex = __MUTEX_INITIALIZER(init_iso_identity_map.contour_list_mutex),
-	.contour_list = LIST_HEAD_INIT(init_iso_identity_map.contour_list),
+} init_ima_events_map = {
+	.contour_list_mutex = __MUTEX_INITIALIZER(init_ima_events_map.contour_list_mutex),
+	.contour_list = LIST_HEAD_INIT(init_ima_events_map.contour_list),
 
-	.trajectory_list_mutex = __MUTEX_INITIALIZER(init_iso_identity_map.trajectory_list_mutex),
-	.trajectory_list = LIST_HEAD_INIT(init_iso_identity_map.trajectory_list),
+	.trajectory_list_mutex = __MUTEX_INITIALIZER(init_ima_events_map.trajectory_list_mutex),
+	.trajectory_list = LIST_HEAD_INIT(init_ima_events_map.trajectory_list),
 	.max_forensics_count = 10,
-	.forensics_list = LIST_HEAD_INIT(init_iso_identity_map.forensics_list),
+	.forensics_list = LIST_HEAD_INIT(init_ima_events_map.forensics_list),
 
-	.measurement_mutex = __MUTEX_INITIALIZER(init_iso_identity_map.measurement_mutex),
-	.measurement_list = LIST_HEAD_INIT(init_iso_identity_map.measurement_list),
+	.measurement_mutex = __MUTEX_INITIALIZER(init_ima_events_map.measurement_mutex),
+	.measurement_list = LIST_HEAD_INIT(init_ima_events_map.measurement_list),
 
 	.AI_events = AI_events
 };
 
-struct iso_identity_namespace init_iso_identity_ns = {
+struct ima_events_namespace init_ima_events_ns = {
         .kref = KREF_INIT(2),
 
-	.map = &init_iso_identity_map,
+	.map = &init_ima_events_map,
 
 	.ns.inum = PROC_BEHAVIOR_INIT_INO,
 	.ns.ops = &behavior_operations
@@ -227,11 +227,11 @@ static atomic_t map_opencount = ATOMIC_INIT(1);
  *	Returns a a pointer to the currently active behavioral map.
  */
 
-static struct iso_identity_map *current_map(void)
+static struct ima_events_map *current_map(void)
 {
 	if (current->nsproxy->behavior_ns)
 		return current->nsproxy->behavior_ns->map;
-	return init_iso_identity_ns.map;
+	return init_ima_events_ns.map;
 }
 
 /**
@@ -243,7 +243,7 @@ static struct iso_identity_map *current_map(void)
  *	returns the status of event generation.
  */
 
-static int generate_event(struct iso_identity_map *map, enum event_types event)
+static int generate_event(struct ima_events_map *map, enum event_types event)
 {
 	int retn=0;
 
@@ -261,7 +261,7 @@ static int generate_event(struct iso_identity_map *map, enum event_types event)
 	list_add_tail(&mp->list, &map->measurement_list);
 	mutex_unlock(&map->measurement_mutex);
 
-	sysfs_notify(iso_identity_kobject, NULL, map->update.attr.name);
+	sysfs_notify(ima_events_kobject, NULL, map->update.attr.name);
 
  done:
 	return retn;
@@ -313,7 +313,7 @@ static int have_contour(char *point)
 {
 	int retn = 0;
 	struct contour *entry;
-	struct iso_identity_map *map = current_map();
+	struct ima_events_map *map = current_map();
 
 	mutex_lock(&map->contour_list_mutex);
 	list_for_each_entry(entry, &map->contour_list, list) {
@@ -341,7 +341,7 @@ static int have_valid_contour(char *point)
 {
 	int retn = 0;
 	struct contour *entry;
-	struct iso_identity_map *map = current_map();
+	struct ima_events_map *map = current_map();
 
 	mutex_lock(&map->contour_list_mutex);
 	list_for_each_entry(entry, &map->contour_list, list) {
@@ -369,7 +369,7 @@ static int add_contour_point(char *point, bool valid)
 {
 	int retn = 1;
 	struct contour *entry;
-	struct iso_identity_map *map = current_map();
+	struct ima_events_map *map = current_map();
 
 	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
 	if (!entry)
@@ -446,7 +446,7 @@ static int add_trajectory_point(const char *filename,
 	int retn = 1;
 	char *fname = NULL, *process = NULL;
 	struct trajectory *entry;
-	struct iso_identity_map *map= current_map();
+	struct ima_events_map *map= current_map();
 
 	entry = create_point(filename, actor, subject);
 	if ( !entry )
@@ -483,7 +483,7 @@ static int add_forensic_point(const char *filename,
 {
 	int retn = 1;
 	struct trajectory *entry;
-	struct iso_identity_map *map = current_map();
+	struct ima_events_map *map = current_map();
 
 	if (map->forensics_count == map->max_forensics_count)
 		return 1;
@@ -510,7 +510,7 @@ static int add_exchange_event(const char *filename,
 			      struct subject_identity *subject)
 {
 	int retn = 1;
-	struct iso_identity_map *map;
+	struct ima_events_map *map;
 	struct event *mp;
 	struct trajectory *event;
 
@@ -536,7 +536,7 @@ static int add_exchange_event(const char *filename,
 	list_add_tail(&mp->list, &map->measurement_list);
 	mutex_unlock(&map->measurement_mutex);
 
-	sysfs_notify(iso_identity_kobject, NULL, map->update.attr.name);
+	sysfs_notify(ima_events_kobject, NULL, map->update.attr.name);
 	schedule();
 
  done:
@@ -550,7 +550,7 @@ static int get_host_measurement(struct crypto_shash *tfm, char *id,
 	SHASH_DESC_ON_STACK(shash, tfm);
 
 
-	struct iso_identity_map *map = current_map();
+	struct ima_events_map *map = current_map();
 
 	shash->tfm = tfm;
 	retn = crypto_shash_init(shash);
@@ -571,7 +571,7 @@ static int update_behavior_measurement(struct crypto_shash *tfm, char *id)
 {
 	int retn;
 	char digest[WP256_DIGEST_SIZE];
-	struct iso_identity_map *map = current_map();
+	struct ima_events_map *map = current_map();
 	SHASH_DESC_ON_STACK(shash, tfm);
 
 	/* Map the measurement to a host dimension. */
@@ -766,7 +766,7 @@ static ssize_t show_ns_update(struct kobject *kobj,
 {
 	ssize_t retn = -ENODATA;
 	struct event *mp;
-	struct iso_identity_map *map = current_map();
+	struct ima_events_map *map = current_map();
 
 	mutex_lock(&map->measurement_mutex);
 	if (list_empty(&map->measurement_list))
@@ -834,7 +834,7 @@ static ssize_t show_ns_update(struct kobject *kobj,
 
 static void *ima_trajectory_start(struct seq_file *c, loff_t *pos)
 {
-	struct iso_identity_map *map = current_map();
+	struct ima_events_map *map = current_map();
 
 	if (*pos >= map->trajectory_count)
 		return NULL;
@@ -845,13 +845,13 @@ static void *ima_trajectory_start(struct seq_file *c, loff_t *pos)
 
 static void *ima_trajectory_next(struct seq_file *c, void *p, loff_t *pos)
 {
-	struct iso_identity_map *map = current_map();
+	struct ima_events_map *map = current_map();
 	return seq_list_next(p, &map->trajectory_list, pos);
 }
 
 static void ima_trajectory_stop(struct seq_file *c, void *pos)
 {
-	struct iso_identity_map *map = current_map();
+	struct ima_events_map *map = current_map();
 	mutex_unlock(&map->trajectory_list_mutex);
 }
 
@@ -883,7 +883,7 @@ static const struct seq_operations ima_trajectory_seqops = {
 
 static int ima_trajectory_open(struct inode *inode, struct file *file)
 {
-	struct iso_identity_map *map = current_map();
+	struct ima_events_map *map = current_map();
 
 	if (map->domain_sealed)
 		return -EACCES;
@@ -899,7 +899,7 @@ static const struct file_operations ima_trajectory_ops = {
 
 static void *ima_contours_start(struct seq_file *c, loff_t *pos)
 {
-	struct iso_identity_map *map = current_map();
+	struct ima_events_map *map = current_map();
 	if (*pos >= map->contour_count)
 		return NULL;
 
@@ -909,13 +909,13 @@ static void *ima_contours_start(struct seq_file *c, loff_t *pos)
 
 static void *ima_contours_next(struct seq_file *c, void *p, loff_t *pos)
 {
-	struct iso_identity_map *map = current_map();
+	struct ima_events_map *map = current_map();
 	return seq_list_next(p, &map->contour_list, pos);
 }
 
 static void ima_contours_stop(struct seq_file *c, void *pos)
 {
-	struct iso_identity_map *map = current_map();
+	struct ima_events_map *map = current_map();
 	mutex_unlock(&map->contour_list_mutex);
 }
 
@@ -937,7 +937,7 @@ static const struct seq_operations ima_contours_seqops = {
 
 static int ima_contours_open(struct inode *inode, struct file *file)
 {
-	struct iso_identity_map *map = current_map();
+	struct ima_events_map *map = current_map();
 
 	if (map->domain_sealed)
 		return -EACCES;
@@ -953,7 +953,7 @@ static const struct file_operations ima_contours_ops = {
 
 static int ima_open_map(struct inode * inode, struct file * filp)
 {
-	struct iso_identity_map *map = current_map();
+	struct ima_events_map *map = current_map();
 
 	if (map->domain_sealed)
 		return -EACCES;
@@ -999,7 +999,7 @@ static const struct file_operations ima_map_ops = {
 
 static int ima_open_pseudonym(struct inode * inode, struct file * filp)
 {
-	struct iso_identity_map *map = current_map();
+	struct ima_events_map *map = current_map();
 
 	if (map->domain_sealed)
 		return -EACCES;
@@ -1047,7 +1047,7 @@ static const struct file_operations ima_pseudonym_ops = {
 
 static int ima_open_host_identity(struct inode * inode, struct file * filp)
 {
-	struct iso_identity_map *map = current_map();
+	struct ima_events_map *map = current_map();
 
 	if (map->domain_sealed)
 		return -EACCES;
@@ -1062,7 +1062,7 @@ static ssize_t ima_write_host_identity(struct file *file,
 {
 	char *p, id[WP256_DIGEST_SIZE*2 + 1];
 	ssize_t retn;
-	struct iso_identity_map *map = current_map();
+	struct ima_events_map *map = current_map();
 
 	if (datalen != sizeof(id)) {
 		retn = -EINVAL;
@@ -1113,7 +1113,7 @@ static const struct file_operations ima_host_identity_ops = {
 
 static int ima_open_sealed(struct inode * inode, struct file * filp)
 {
-	struct iso_identity_map *map = current_map();
+	struct ima_events_map *map = current_map();
 
 	if (map->domain_sealed)
 		return -EACCES;
@@ -1128,7 +1128,7 @@ static ssize_t ima_write_sealed(struct file *file,
 {
 	char sealed[2];
 	ssize_t retn;
-	struct iso_identity_map *map = current_map();
+	struct ima_events_map *map = current_map();
 
 	if (datalen != 2) {
 		retn = -EINVAL;
@@ -1179,7 +1179,7 @@ static const struct file_operations ima_sealed_ops = {
 
 static void *ima_forensics_start(struct seq_file *c, loff_t *pos)
 {
-	struct iso_identity_map *map = current_map();
+	struct ima_events_map *map = current_map();
 
 	if (*pos >= map->forensics_count)
 		return NULL;
@@ -1190,14 +1190,14 @@ static void *ima_forensics_start(struct seq_file *c, loff_t *pos)
 
 static void *ima_forensics_next(struct seq_file *c, void *p, loff_t *pos)
 {
-	struct iso_identity_map *map = current_map();
+	struct ima_events_map *map = current_map();
 
 	return seq_list_next(p, &map->forensics_list, pos);
 }
 
 static void ima_forensics_stop(struct seq_file *c, void *pos)
 {
-	struct iso_identity_map *map = current_map();
+	struct ima_events_map *map = current_map();
 
 	mutex_unlock(&map->trajectory_list_mutex);
 }
@@ -1242,7 +1242,7 @@ static const struct file_operations ima_forensics_ops = {
 
 static void *ima_measurement_start(struct seq_file *c, loff_t *pos)
 {
-	struct iso_identity_map *map = current_map();
+	struct ima_events_map *map = current_map();
 
 	if (*pos > 0)
 		return NULL;
@@ -1262,7 +1262,7 @@ static void ima_measurement_stop(struct seq_file *c, void *pos)
 
 static int ima_measurement_show(struct seq_file *c, void *event)
 {
-	struct iso_identity_map *map = current_map();
+	struct ima_events_map *map = current_map();
 
 	seq_printf(c, "%*phN\n", (int) sizeof(map->measurement),
 		   map->measurement);
@@ -1579,7 +1579,7 @@ static void ima_set_actor_status(int function, const char *pathname,
 				 struct subject_identity *subject,
 				 char *mapping)
 {
-	struct iso_identity_map *map = current_map();
+	struct ima_events_map *map = current_map();
 
 	if (!current->in_execve)
 		return;
@@ -1608,7 +1608,7 @@ int ima_events_is_mapped(int function, struct integrity_iint_cache *iint,
 	char mapping[WP256_DIGEST_SIZE];
 	struct actor_identity actor;
 	struct subject_identity subject;
-	struct iso_identity_map *map = current_map();
+	struct ima_events_map *map = current_map();
 
 	if (have_violation(file, iint, pathname))
 		return 1;
@@ -1714,8 +1714,8 @@ int __init ima_events_init(void)
 	if (IS_ERR(trajectory))
 		goto err;
 
-	iso_identity_kobject = kobject_create_and_add("iso-identity", fs_kobj);
-	if (!iso_identity_kobject)
+	ima_events_kobject = kobject_create_and_add("iso-identity", fs_kobj);
+	if (!ima_events_kobject)
 		goto err;
 
 	retn = 0;
@@ -1733,8 +1733,8 @@ int __init ima_events_init(void)
 	securityfs_remove(measurement_file);
 	securityfs_remove(trajectory);
 
-	if (iso_identity_kobject)
-		kobject_put(iso_identity_kobject);
+	if (ima_events_kobject)
+		kobject_put(ima_events_kobject);
 
 	return retn;
 }
@@ -1742,7 +1742,7 @@ int __init ima_events_init(void)
 int ima_measure_ns(const u8 *hash)
 {
 	int retn = 1;
-	struct iso_identity_map *map;
+	struct ima_events_map *map;
 	struct event *mp;
 
 	if (!current->nsproxy->behavior_ns)
@@ -1761,7 +1761,7 @@ int ima_measure_ns(const u8 *hash)
 	list_add_tail(&mp->list, &map->measurement_list);
 	mutex_unlock(&map->measurement_mutex);
 
-	sysfs_notify(iso_identity_kobject, NULL, map->update.attr.name);
+	sysfs_notify(ima_events_kobject, NULL, map->update.attr.name);
 
  done:
 	return retn;
@@ -1770,11 +1770,11 @@ int ima_measure_ns(const u8 *hash)
 void ima_free_ns(struct kref *kref)
 {
 	unsigned int cnt;
-	struct iso_identity_namespace *ns;
+	struct ima_events_namespace *ns;
 	struct contour *centry, *tmp_centry;
 	struct trajectory *tentry, *tmp_tentry;
 
-	ns = container_of(kref, struct iso_identity_namespace, kref);
+	ns = container_of(kref, struct ima_events_namespace, kref);
 
 	cnt = 0;
 	list_for_each_entry_safe(centry, tmp_centry, &ns->map->contour_list,
@@ -1816,7 +1816,7 @@ void ima_free_ns(struct kref *kref)
 			 cnt);
 	}
 
-	sysfs_remove_file(iso_identity_kobject, &ns->map->update.attr);
+	sysfs_remove_file(ima_events_kobject, &ns->map->update.attr);
 	kfree(ns->map->update.attr.name);
 
 	put_user_ns(ns->user_ns);
@@ -1828,7 +1828,7 @@ void ima_free_ns(struct kref *kref)
 }
 
 static int add_aggregate(struct crypto_shash *tfm,
-			 struct iso_identity_map *map)
+			 struct ima_events_map *map)
 {
 	int retn = 0;
 	char host_measurement[WP256_DIGEST_SIZE];
@@ -1876,20 +1876,20 @@ static int add_aggregate(struct crypto_shash *tfm,
 	list_add_tail(&mp->list, &map->measurement_list);
 	mutex_unlock(&map->measurement_mutex);
 
-	sysfs_notify(iso_identity_kobject, NULL, map->update.attr.name);
+	sysfs_notify(ima_events_kobject, NULL, map->update.attr.name);
 
  done:
 	return retn;
 }
 
-struct iso_identity_namespace *ima_copy_behavior_ns(unsigned long flags,
+struct ima_events_namespace *ima_copy_behavior_ns(unsigned long flags,
 				    struct user_namespace *user_ns,
-				    struct iso_identity_namespace *behavior_ns)
+				    struct ima_events_namespace *behavior_ns)
 {
 	static char *update = "update-";
 	char bufr[7 + 10 + 1];
 	int retn = 0;
-	struct iso_identity_namespace *ns;
+	struct ima_events_namespace *ns;
 	struct crypto_shash *tfm = NULL;
 
 	pr_debug("[%s]: New ns = %s\n", __func__,
@@ -1901,7 +1901,7 @@ struct iso_identity_namespace *ima_copy_behavior_ns(unsigned long flags,
 	if (!(flags & CLONE_EVENTS))
 		return behavior_ns;
 
-	ns = kzalloc(sizeof(struct iso_identity_namespace), GFP_KERNEL);
+	ns = kzalloc(sizeof(struct ima_events_namespace), GFP_KERNEL);
 	if (!ns) {
 		retn = -ENOMEM;
 		goto done;
@@ -1911,7 +1911,7 @@ struct iso_identity_namespace *ima_copy_behavior_ns(unsigned long flags,
 	if (retn)
 		goto done;
 
-	ns->map = kzalloc(sizeof(struct iso_identity_map), GFP_KERNEL);
+	ns->map = kzalloc(sizeof(struct ima_events_map), GFP_KERNEL);
 	if (!ns->map) {
 		retn = -ENOMEM;
 		goto done;
@@ -1948,7 +1948,7 @@ struct iso_identity_namespace *ima_copy_behavior_ns(unsigned long flags,
 	strcpy((char *) ns->map->update.attr.name, bufr);
 	ns->map->update.attr.mode = 0400;
 	ns->map->update.show = show_ns_update;
-	retn = sysfs_create_file(iso_identity_kobject, &ns->map->update.attr);
+	retn = sysfs_create_file(ima_events_kobject, &ns->map->update.attr);
 	if(retn)
 		goto done;
 
@@ -1989,7 +1989,7 @@ int ima_events_process_te(unsigned int event)
 {
 	int retn = 0;
 
-	struct iso_identity_map *map = current_map();
+	struct ima_events_map *map = current_map();
 
 	struct event *ep;
 
@@ -2021,7 +2021,7 @@ int ima_events_process_te(unsigned int event)
 	list_add_tail(&ep->list, &map->measurement_list);
 	mutex_unlock(&map->measurement_mutex);
 
-	sysfs_notify(iso_identity_kobject, NULL, map->update.attr.name);
+	sysfs_notify(ima_events_kobject, NULL, map->update.attr.name);
 
  done:
 	return retn;
@@ -2061,7 +2061,7 @@ SYSCALL_DEFINE3(set_behavior, unsigned char *, bufr, size_t, cnt,
 		unsigned long, flags)
 {
 	int retn = -EINVAL;
-	struct iso_identity_map *map = current_map();
+	struct ima_events_map *map = current_map();
 	struct ai_control {
 		unsigned int hook;
 		unsigned int action;
@@ -2140,15 +2140,15 @@ SYSCALL_DEFINE3(set_behavior, unsigned char *, bufr, size_t, cnt,
 
 static void behavior_put(struct ns_common *ns)
 {
-	struct iso_identity_namespace *behavior_ns =
-		container_of(ns, struct iso_identity_namespace, ns);
+	struct ima_events_namespace *behavior_ns =
+		container_of(ns, struct ima_events_namespace, ns);
 
 	ima_put_ns(behavior_ns);
 }
 
 static struct ns_common *behavior_get(struct task_struct *task)
 {
-	struct iso_identity_namespace *ns = NULL;
+	struct ima_events_namespace *ns = NULL;
 	struct nsproxy *nsproxy;
 
 	task_lock(task);
@@ -2158,8 +2158,8 @@ static struct ns_common *behavior_get(struct task_struct *task)
 		if (ns)
 			ima_get_ns(ns);
 		else {
-			ns = &init_iso_identity_ns;
-			ima_get_ns(&init_iso_identity_ns);
+			ns = &init_ima_events_ns;
+			ima_get_ns(&init_ima_events_ns);
 		}
 	}
 	task_unlock(task);
@@ -2169,8 +2169,8 @@ static struct ns_common *behavior_get(struct task_struct *task)
 
 static int behavior_install(struct nsproxy *nsproxy, struct ns_common *new)
 {
-	struct iso_identity_namespace *behavior_ns =
-		container_of(new, struct iso_identity_namespace, ns);
+	struct ima_events_namespace *behavior_ns =
+		container_of(new, struct ima_events_namespace, ns);
 
 	if (!ns_capable(behavior_ns->user_ns, CAP_SYS_ADMIN) ||
 	    !ns_capable(current_user_ns(), CAP_SYS_ADMIN))
diff --git a/security/integrity/ima/ima_policy.c b/security/integrity/ima/ima_policy.c
index d99b4acd423d..f6544a5998de 100644
--- a/security/integrity/ima/ima_policy.c
+++ b/security/integrity/ima/ima_policy.c
@@ -191,7 +191,7 @@ static struct ima_rule_entry build_appraise_rules[] __ro_after_init = {
 #endif
 };
 
-static struct ima_rule_entry iso_identity_measurement_rules[] = {
+static struct ima_rule_entry ima_events_measurement_rules[] = {
 	{.action = MAP,.func = MMAP_CHECK,.mask = MAY_EXEC,
 	 .flags = IMA_FUNC | IMA_MASK},
 	{.action = MAP,.func = BPRM_CHECK,.mask = MAY_EXEC,
@@ -699,8 +699,8 @@ void __init ima_init_policy(void)
 			  IMA_DEFAULT_POLICY);
 		break;
 	case EVENTS_TCB:
-		add_rules(iso_identity_measurement_rules,
-			  ARRAY_SIZE(iso_identity_measurement_rules),
+		add_rules(ima_events_measurement_rules,
+			  ARRAY_SIZE(ima_events_measurement_rules),
 			  IMA_DEFAULT_POLICY);
 		break;
 	default:
-- 
2.31.1

