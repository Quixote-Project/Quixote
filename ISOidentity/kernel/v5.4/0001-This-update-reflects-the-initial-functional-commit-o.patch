From fc70b620a6f9f26fbbf0247a08b819b5fbb1e0f5 Mon Sep 17 00:00:00 2001
From: "Dr. Greg" <greg@enjellic.com>
Date: Tue, 26 Jan 2021 04:42:22 -0600
Subject: [PATCH 01/50] This update reflects the initial functional commit of
 Turing Event modeling to the 5.4 kernel.  In light testing it appears to be
 consistent in functionality with the 4.4 kernel in which the initial
 implementation was done.

There was only a small correctness fix in the code that was
needed in order to achieve equivalent functionality.  From
this commit, moving forward, the changes will be functionality
and correctness changes from the initial implementation.
---
 arch/x86/entry/syscalls/syscall_32.tbl    |    2 +
 arch/x86/entry/syscalls/syscall_64.tbl    |    2 +
 fs/proc/array.c                           |    7 +
 fs/proc/namespaces.c                      |    4 +
 include/linux/ima.h                       |   25 +
 include/linux/nsproxy.h                   |    2 +
 include/linux/proc_ns.h                   |    2 +
 include/linux/sched.h                     |    3 +
 include/linux/syscalls.h                  |    6 +
 include/uapi/asm-generic/unistd.h         |    6 +-
 include/uapi/linux/sched.h                |    3 +
 kernel/fork.c                             |    6 +-
 kernel/nsproxy.c                          |   18 +-
 kernel/sys_ni.c                           |    3 +
 security/Kconfig                          |    5 +-
 security/Makefile                         |    2 +
 security/integrity/iint.c                 |    5 +
 security/integrity/ima/Makefile           |    2 +-
 security/integrity/ima/ima.h              |   18 +
 security/integrity/ima/ima_api.c          |   40 +-
 security/integrity/ima/ima_fs.c           |   10 +
 security/integrity/ima/ima_identity.c     | 2194 +++++++++++++++++++++
 security/integrity/ima/ima_init.c         |    6 +-
 security/integrity/ima/ima_main.c         |   10 +
 security/integrity/ima/ima_policy.c       |   80 +-
 security/integrity/ima/ima_queue.c        |   10 +-
 security/integrity/ima/ima_template.c     |    6 +
 security/integrity/ima/ima_template_lib.c |   38 +
 security/integrity/ima/ima_template_lib.h |   10 +
 security/integrity/integrity.h            |    4 +-
 security/security.c                       |    1 +
 security/te/Kconfig                       |   13 +
 security/te/Makefile                      |    3 +
 security/te/te.c                          |  133 ++
 34 files changed, 2653 insertions(+), 26 deletions(-)
 create mode 100644 security/integrity/ima/ima_identity.c
 create mode 100644 security/te/Kconfig
 create mode 100644 security/te/Makefile
 create mode 100644 security/te/te.c

diff --git a/arch/x86/entry/syscalls/syscall_32.tbl b/arch/x86/entry/syscalls/syscall_32.tbl
index 3fe02546aed3..2d9c0aca6c37 100644
--- a/arch/x86/entry/syscalls/syscall_32.tbl
+++ b/arch/x86/entry/syscalls/syscall_32.tbl
@@ -440,3 +440,5 @@
 433	i386	fspick			sys_fspick			__ia32_sys_fspick
 434	i386	pidfd_open		sys_pidfd_open			__ia32_sys_pidfd_open
 435	i386	clone3			sys_clone3			__ia32_sys_clone3
+436	i386	set_behavior		sys_set_behavior		__ia32_sys_set_behavior
+437	i386	set_bad_actor		sys_set_bad_actor		__ia32_sys_set_bad_actor
diff --git a/arch/x86/entry/syscalls/syscall_64.tbl b/arch/x86/entry/syscalls/syscall_64.tbl
index c29976eca4a8..11059df85210 100644
--- a/arch/x86/entry/syscalls/syscall_64.tbl
+++ b/arch/x86/entry/syscalls/syscall_64.tbl
@@ -357,6 +357,8 @@
 433	common	fspick			__x64_sys_fspick
 434	common	pidfd_open		__x64_sys_pidfd_open
 435	common	clone3			__x64_sys_clone3/ptregs
+436	common	set_behavior		__x64_sys_set_behavior
+437	common	set_bad_actor		__x64_sys_set_bad_actor
 
 #
 # x32-specific system call numbers start at 512 to avoid cache impact
diff --git a/fs/proc/array.c b/fs/proc/array.c
index 46dcb6f0eccf..db2889279df2 100644
--- a/fs/proc/array.c
+++ b/fs/proc/array.c
@@ -378,6 +378,12 @@ static inline void task_context_switch_counts(struct seq_file *m,
 	seq_putc(m, '\n');
 }
 
+static inline void task_behavior_status(struct seq_file *m,
+					struct task_struct *p)
+{
+	seq_printf(m, "bad_actor:\t%u\n", p->bad_actor);
+}
+
 static void task_cpus_allowed(struct seq_file *m, struct task_struct *task)
 {
 	seq_printf(m, "Cpus_allowed:\t%*pb\n",
@@ -424,6 +430,7 @@ int proc_pid_status(struct seq_file *m, struct pid_namespace *ns,
 	task_cpus_allowed(m, task);
 	cpuset_task_status_allowed(m, task);
 	task_context_switch_counts(m, task);
+	task_behavior_status(m, task);
 	return 0;
 }
 
diff --git a/fs/proc/namespaces.c b/fs/proc/namespaces.c
index dd2b35f78b09..6ef5a8e605de 100644
--- a/fs/proc/namespaces.c
+++ b/fs/proc/namespaces.c
@@ -9,6 +9,7 @@
 #include <linux/ipc_namespace.h>
 #include <linux/pid_namespace.h>
 #include <linux/user_namespace.h>
+#include <linux/ima.h>
 #include "internal.h"
 
 
@@ -28,6 +29,9 @@ static const struct proc_ns_operations *ns_entries[] = {
 #endif
 #ifdef CONFIG_USER_NS
 	&userns_operations,
+#endif
+#ifdef CONFIG_IMA
+	&behavior_operations,
 #endif
 	&mntns_operations,
 #ifdef CONFIG_CGROUPS
diff --git a/include/linux/ima.h b/include/linux/ima.h
index 1c37f17f7203..ba404fe3f319 100644
--- a/include/linux/ima.h
+++ b/include/linux/ima.h
@@ -13,6 +13,15 @@
 struct linux_binprm;
 
 #ifdef CONFIG_IMA
+struct iso_identity_map;
+
+struct iso_identity_namespace {
+	struct kref kref;
+	struct iso_identity_map *map;
+	struct user_namespace *user_ns;
+	struct ns_common ns;
+};
+
 extern int ima_bprm_check(struct linux_binprm *bprm);
 extern int ima_file_check(struct file *file, int mask);
 extern void ima_post_create_tmpfile(struct inode *inode);
@@ -44,6 +53,22 @@ static inline const char * const *arch_get_ima_policy(void)
 }
 #endif
 
+extern struct iso_identity_namespace * ima_copy_behavior_ns(unsigned long,
+					      struct user_namespace *,
+					      struct iso_identity_namespace *);
+extern int ima_measure_ns(const u8 *);
+extern void ima_free_ns(struct kref *);
+
+static inline void ima_get_ns(struct iso_identity_namespace *ns)
+{
+	kref_get(&ns->kref);
+}
+static inline void ima_put_ns(struct iso_identity_namespace *ns)
+{
+	kref_put(&ns->kref, ima_free_ns);
+}
+extern int ima_identity_process_ai(unsigned int);
+
 #else
 static inline int ima_bprm_check(struct linux_binprm *bprm)
 {
diff --git a/include/linux/nsproxy.h b/include/linux/nsproxy.h
index 2ae1b1a4d84d..a99f2b4f911f 100644
--- a/include/linux/nsproxy.h
+++ b/include/linux/nsproxy.h
@@ -11,6 +11,7 @@ struct ipc_namespace;
 struct pid_namespace;
 struct cgroup_namespace;
 struct fs_struct;
+struct iso_identity_namespace;
 
 /*
  * A structure to contain pointers to all per-process
@@ -36,6 +37,7 @@ struct nsproxy {
 	struct pid_namespace *pid_ns_for_children;
 	struct net 	     *net_ns;
 	struct cgroup_namespace *cgroup_ns;
+	struct iso_identity_namespace *behavior_ns;
 };
 extern struct nsproxy init_nsproxy;
 
diff --git a/include/linux/proc_ns.h b/include/linux/proc_ns.h
index d31cb6215905..75cbc4d3296c 100644
--- a/include/linux/proc_ns.h
+++ b/include/linux/proc_ns.h
@@ -32,6 +32,7 @@ extern const struct proc_ns_operations pidns_for_children_operations;
 extern const struct proc_ns_operations userns_operations;
 extern const struct proc_ns_operations mntns_operations;
 extern const struct proc_ns_operations cgroupns_operations;
+extern const struct proc_ns_operations behavior_operations;
 
 /*
  * We always define these enumerators
@@ -43,6 +44,7 @@ enum {
 	PROC_USER_INIT_INO	= 0xEFFFFFFDU,
 	PROC_PID_INIT_INO	= 0xEFFFFFFCU,
 	PROC_CGROUP_INIT_INO	= 0xEFFFFFFBU,
+	PROC_BEHAVIOR_INIT_INO	= 0xEFFFFFFAU,
 };
 
 #ifdef CONFIG_PROC_FS
diff --git a/include/linux/sched.h b/include/linux/sched.h
index 67a1d86981a9..bbdf3ef5a086 100644
--- a/include/linux/sched.h
+++ b/include/linux/sched.h
@@ -780,6 +780,9 @@ struct task_struct {
 	/* to be used once the psi infrastructure lands upstream. */
 	unsigned			use_memdelay:1;
 #endif
+#ifdef CONFIG_IMA
+	unsigned			bad_actor:1;
+#endif
 
 	unsigned long			atomic_flags; /* Flags requiring atomic access. */
 
diff --git a/include/linux/syscalls.h b/include/linux/syscalls.h
index f7c561c4dcdd..57d74d27ae18 100644
--- a/include/linux/syscalls.h
+++ b/include/linux/syscalls.h
@@ -1422,3 +1422,9 @@ long compat_ksys_semtimedop(int semid, struct sembuf __user *tsems,
 			    const struct old_timespec32 __user *timeout);
 
 #endif
+
+#ifdef CONFIG_IMA
+asmlinkage long sys_set_behavior(unsigned char __user * buf, size_t cnt,
+				 unsigned long flags);
+asmlinkage long sys_set_bad_actor(pid_t pid, unsigned long flags);
+#endif
diff --git a/include/uapi/asm-generic/unistd.h b/include/uapi/asm-generic/unistd.h
index 1fc8faa6e973..38574b732e0e 100644
--- a/include/uapi/asm-generic/unistd.h
+++ b/include/uapi/asm-generic/unistd.h
@@ -850,9 +850,13 @@ __SYSCALL(__NR_pidfd_open, sys_pidfd_open)
 #define __NR_clone3 435
 __SYSCALL(__NR_clone3, sys_clone3)
 #endif
+#define __NR_set_behavior 436
+__SYSCALL(__NR_set_behavior, sys_set_behavior)
+#define __NR_set_bad_actor 437
+__SYSCALL(__NR_set_bad_actor, sys_set_bad_actor)
 
 #undef __NR_syscalls
-#define __NR_syscalls 436
+#define __NR_syscalls 438
 
 /*
  * 32 bit systems traditionally used different
diff --git a/include/uapi/linux/sched.h b/include/uapi/linux/sched.h
index 25b4fa00bad1..d059c8b2c16b 100644
--- a/include/uapi/linux/sched.h
+++ b/include/uapi/linux/sched.h
@@ -33,6 +33,9 @@
 #define CLONE_NEWNET		0x40000000	/* New network namespace */
 #define CLONE_IO		0x80000000	/* Clone io context */
 
+/* Clone flags that can be used only with unshare. */
+#define CLONE_EVENTS		0x00000040
+
 #ifndef __ASSEMBLY__
 /**
  * struct clone_args - arguments for the clone3 syscall
diff --git a/kernel/fork.c b/kernel/fork.c
index 13b38794efb5..245854ab6660 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -1977,6 +1977,9 @@ static __latent_entropy struct task_struct *copy_process(
 	p->sequential_io	= 0;
 	p->sequential_io_avg	= 0;
 #endif
+#ifdef CONFIG_IMA
+	p->bad_actor = current->bad_actor;
+#endif
 
 	/* Perform scheduler related setup. Assign this task to a CPU. */
 	retval = sched_fork(clone_flags, p);
@@ -2734,7 +2737,8 @@ static int check_unshare_flags(unsigned long unshare_flags)
 	if (unshare_flags & ~(CLONE_THREAD|CLONE_FS|CLONE_NEWNS|CLONE_SIGHAND|
 				CLONE_VM|CLONE_FILES|CLONE_SYSVSEM|
 				CLONE_NEWUTS|CLONE_NEWIPC|CLONE_NEWNET|
-				CLONE_NEWUSER|CLONE_NEWPID|CLONE_NEWCGROUP))
+				CLONE_NEWUSER|CLONE_NEWPID|CLONE_NEWCGROUP|
+			        CLONE_EVENTS))
 		return -EINVAL;
 	/*
 	 * Not implemented, but pretend it works if there is nothing
diff --git a/kernel/nsproxy.c b/kernel/nsproxy.c
index c815f58e6bc0..dfa4fc2711bb 100644
--- a/kernel/nsproxy.c
+++ b/kernel/nsproxy.c
@@ -23,6 +23,7 @@
 #include <linux/syscalls.h>
 #include <linux/cgroup.h>
 #include <linux/perf_event.h>
+#include <linux/ima.h>
 
 static struct kmem_cache *nsproxy_cachep;
 
@@ -106,8 +107,18 @@ static struct nsproxy *create_new_namespaces(unsigned long flags,
 		goto out_net;
 	}
 
+	new_nsp->behavior_ns = ima_copy_behavior_ns(flags, user_ns,
+						    tsk->nsproxy->behavior_ns);
+	if (IS_ERR(new_nsp->behavior_ns)) {
+		err = PTR_ERR(new_nsp->behavior_ns);
+		goto out_behavior;
+	}
+
 	return new_nsp;
 
+out_behavior:
+	if (new_nsp->net_ns)
+		put_net(new_nsp->net_ns);
 out_net:
 	put_cgroup_ns(new_nsp->cgroup_ns);
 out_cgroup:
@@ -139,7 +150,7 @@ int copy_namespaces(unsigned long flags, struct task_struct *tsk)
 
 	if (likely(!(flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |
 			      CLONE_NEWPID | CLONE_NEWNET |
-			      CLONE_NEWCGROUP)))) {
+			      CLONE_NEWCGROUP | CLONE_EVENTS)))) {
 		get_nsproxy(old_ns);
 		return 0;
 	}
@@ -176,6 +187,8 @@ void free_nsproxy(struct nsproxy *ns)
 		put_ipc_ns(ns->ipc_ns);
 	if (ns->pid_ns_for_children)
 		put_pid_ns(ns->pid_ns_for_children);
+	if (ns->behavior_ns)
+		ima_put_ns(ns->behavior_ns);
 	put_cgroup_ns(ns->cgroup_ns);
 	put_net(ns->net_ns);
 	kmem_cache_free(nsproxy_cachep, ns);
@@ -192,7 +205,8 @@ int unshare_nsproxy_namespaces(unsigned long unshare_flags,
 	int err = 0;
 
 	if (!(unshare_flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |
-			       CLONE_NEWNET | CLONE_NEWPID | CLONE_NEWCGROUP)))
+			       CLONE_NEWNET | CLONE_NEWPID | CLONE_NEWCGROUP|
+			       CLONE_EVENTS)))
 		return 0;
 
 	user_ns = new_cred ? new_cred->user_ns : current_user_ns();
diff --git a/kernel/sys_ni.c b/kernel/sys_ni.c
index 34b76895b81e..9a0434c68c23 100644
--- a/kernel/sys_ni.c
+++ b/kernel/sys_ni.c
@@ -349,6 +349,9 @@ COND_SYSCALL(pkey_mprotect);
 COND_SYSCALL(pkey_alloc);
 COND_SYSCALL(pkey_free);
 
+/* Set system event parameters */
+COND_SYSCALL(sys_set_behavior);
+COND_SYSCALL(sys_set_bad_actor);
 
 /*
  * Architecture specific weak syscall entries.
diff --git a/security/Kconfig b/security/Kconfig
index 2a1a2d396228..fe928ba733da 100644
--- a/security/Kconfig
+++ b/security/Kconfig
@@ -238,6 +238,7 @@ source "security/loadpin/Kconfig"
 source "security/yama/Kconfig"
 source "security/safesetid/Kconfig"
 source "security/lockdown/Kconfig"
+source "security/te/Kconfig"
 
 source "security/integrity/Kconfig"
 
@@ -280,8 +281,8 @@ config LSM
 	default "lockdown,yama,loadpin,safesetid,integrity,smack,selinux,tomoyo,apparmor" if DEFAULT_SECURITY_SMACK
 	default "lockdown,yama,loadpin,safesetid,integrity,apparmor,selinux,smack,tomoyo" if DEFAULT_SECURITY_APPARMOR
 	default "lockdown,yama,loadpin,safesetid,integrity,tomoyo" if DEFAULT_SECURITY_TOMOYO
-	default "lockdown,yama,loadpin,safesetid,integrity" if DEFAULT_SECURITY_DAC
-	default "lockdown,yama,loadpin,safesetid,integrity,selinux,smack,tomoyo,apparmor"
+	default "lockdown,yama,loadpin,safesetid,integrity,te" if DEFAULT_SECURITY_DAC
+	default "lockdown,yama,loadpin,safesetid,integrity,selinux,smack,tomoyo,apparmor,te"
 	help
 	  A comma-separated list of LSMs, in initialization order.
 	  Any LSMs left off this list will be ignored. This can be
diff --git a/security/Makefile b/security/Makefile
index be1dd9d2cb2f..6dbc5c14eed7 100644
--- a/security/Makefile
+++ b/security/Makefile
@@ -12,6 +12,7 @@ subdir-$(CONFIG_SECURITY_YAMA)		+= yama
 subdir-$(CONFIG_SECURITY_LOADPIN)	+= loadpin
 subdir-$(CONFIG_SECURITY_SAFESETID)    += safesetid
 subdir-$(CONFIG_SECURITY_LOCKDOWN_LSM)	+= lockdown
+subdir-$(CONFIG_SECURITY_EVENT)		+= te
 
 # always enable default capabilities
 obj-y					+= commoncap.o
@@ -30,6 +31,7 @@ obj-$(CONFIG_SECURITY_LOADPIN)		+= loadpin/
 obj-$(CONFIG_SECURITY_SAFESETID)       += safesetid/
 obj-$(CONFIG_SECURITY_LOCKDOWN_LSM)	+= lockdown/
 obj-$(CONFIG_CGROUP_DEVICE)		+= device_cgroup.o
+obj-$(CONFIG_SECURITY_EVENT)		+= te/
 
 # Object integrity file lists
 subdir-$(CONFIG_INTEGRITY)		+= integrity
diff --git a/security/integrity/iint.c b/security/integrity/iint.c
index e12c4900510f..6ff1b9950927 100644
--- a/security/integrity/iint.c
+++ b/security/integrity/iint.c
@@ -141,13 +141,18 @@ void integrity_inode_free(struct inode *inode)
 
 	if (!IS_IMA(inode))
 		return;
+	pr_info("[%s]: Processing eviction for inode=%ld, flags=%u\n",
+		__func__, inode->i_ino, inode->i_flags);
 
 	write_lock(&integrity_iint_lock);
 	iint = __integrity_iint_find(inode);
 	rb_erase(&iint->rb_node, &integrity_iint_tree);
 	write_unlock(&integrity_iint_lock);
 
+	pr_info("[%s]: Evicting security inode %p for %ld.\n", __func__,
+		iint, iint->inode->i_ino);
 	iint_free(iint);
+	inode->i_flags &= ~S_IMA;
 }
 
 static void init_once(void *foo)
diff --git a/security/integrity/ima/Makefile b/security/integrity/ima/Makefile
index 31d57cdf2421..d9cc59f70e24 100644
--- a/security/integrity/ima/Makefile
+++ b/security/integrity/ima/Makefile
@@ -7,7 +7,7 @@
 obj-$(CONFIG_IMA) += ima.o
 
 ima-y := ima_fs.o ima_queue.o ima_init.o ima_main.o ima_crypto.o ima_api.o \
-	 ima_policy.o ima_template.o ima_template_lib.o
+	 ima_policy.o ima_template.o ima_template_lib.o ima_identity.o
 ima-$(CONFIG_IMA_APPRAISE) += ima_appraise.o
 ima-$(CONFIG_IMA_APPRAISE_MODSIG) += ima_modsig.o
 ima-$(CONFIG_HAVE_IMA_KEXEC) += ima_kexec.o
diff --git a/security/integrity/ima/ima.h b/security/integrity/ima/ima.h
index 3689081aaf38..13ce339e39e5 100644
--- a/security/integrity/ima/ima.h
+++ b/security/integrity/ima/ima.h
@@ -68,10 +68,16 @@ struct ima_event_data {
 
 /* IMA template field data definition */
 struct ima_field_data {
+	void *identity;
 	u8 *data;
 	u32 len;
 };
 
+/* Host identity, defined in ima_identity.c */
+extern char *hostid;
+
+struct ima_template_entry;
+
 /* IMA template field definition */
 struct ima_template_field {
 	const char field_id[IMA_TEMPLATE_FIELD_ID_MAX_LEN];
@@ -87,6 +93,7 @@ struct ima_template_desc {
 	char *name;
 	char *fmt;
 	int num_fields;
+	int (*genhash)(struct ima_template_entry *, char *);
 	const struct ima_template_field **fields;
 };
 
@@ -131,6 +138,7 @@ extern bool ima_canonical_fmt;
 /* Internal IMA function definitions */
 int ima_init(void);
 int ima_fs_init(void);
+int ima_pcr_extend(const u8 *hash, int);
 int ima_add_template_entry(struct ima_template_entry *entry, int violation,
 			   const char *op, struct inode *inode,
 			   const unsigned char *filename);
@@ -162,6 +170,15 @@ void ima_init_template_list(void);
 int __init ima_init_digests(void);
 int ima_lsm_policy_change(struct notifier_block *nb, unsigned long event,
 			  void *lsm_data);
+int ima_identity_init(void);
+int ima_identity_genhash(struct ima_template_entry *, char *);
+int ima_get_actor(struct ima_field_data *, char *);
+int ima_get_subject(struct ima_event_data *, struct ima_field_data *, char *);
+int ima_identity_is_mapped(int, struct integrity_iint_cache *iint,
+			   struct file *file, const char *pathname,
+			   struct ima_template_desc *, int);
+int ima_fs_init(void);
+struct dentry *ima_fs_init_identity(void);
 
 /*
  * used to protect h_table and sha_table
@@ -209,6 +226,7 @@ int ima_get_action(struct inode *inode, const struct cred *cred, u32 secid,
 		   int mask, enum ima_hooks func, int *pcr,
 		   struct ima_template_desc **template_desc);
 int ima_must_measure(struct inode *inode, int mask, enum ima_hooks func);
+int ima_must_map(struct inode *inode, int mask, int function);
 int ima_collect_measurement(struct integrity_iint_cache *iint,
 			    struct file *file, void *buf, loff_t size,
 			    enum hash_algo algo, struct modsig *modsig);
diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 610759fe63b8..f8954e143314 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -24,8 +24,10 @@ void ima_free_template_entry(struct ima_template_entry *entry)
 {
 	int i;
 
-	for (i = 0; i < entry->template_desc->num_fields; i++)
+	for (i = 0; i < entry->template_desc->num_fields; i++) {
+		kfree(entry->template_data[i].identity);
 		kfree(entry->template_data[i].data);
+	}
 
 	kfree(entry);
 }
@@ -102,13 +104,21 @@ int ima_store_template(struct ima_template_entry *entry,
 	} hash;
 
 	if (!violation) {
-		int num_fields = entry->template_desc->num_fields;
-
-		/* this function uses default algo */
-		hash.hdr.algo = HASH_ALGO_SHA1;
-		result = ima_calc_field_array_hash(&entry->template_data[0],
-						   entry->template_desc,
-						   num_fields, &hash.hdr);
+		if (entry->template_desc->genhash != NULL) {
+			hash.hdr.length = TPM_DIGEST_SIZE;
+			result = entry->template_desc->genhash(entry,
+							       hash.hdr.digest);
+		}
+		else {
+			int num_fields = entry->template_desc->num_fields;
+
+			/* this function uses default algo */
+			hash.hdr.algo = HASH_ALGO_SHA1;
+			result = ima_calc_field_array_hash(&entry->template_data[0],
+							   entry->template_desc,
+							   num_fields,
+							   &hash.hdr);
+		}
 		if (result < 0) {
 			integrity_audit_msg(AUDIT_INTEGRITY_PCR, inode,
 					    template_name, op,
@@ -185,7 +195,7 @@ int ima_get_action(struct inode *inode, const struct cred *cred, u32 secid,
 		   int mask, enum ima_hooks func, int *pcr,
 		   struct ima_template_desc **template_desc)
 {
-	int flags = IMA_MEASURE | IMA_AUDIT | IMA_APPRAISE | IMA_HASH;
+	int flags = IMA_MEASURE | IMA_AUDIT | IMA_APPRAISE | IMA_HASH | IMA_MAP;
 
 	flags &= ima_policy_flag;
 
@@ -193,6 +203,15 @@ int ima_get_action(struct inode *inode, const struct cred *cred, u32 secid,
 				template_desc);
 }
 
+int ima_must_map(struct inode *inode, int mask, int function)
+{
+#if 1
+	return 1;
+#else
+	return ima_match_policy(inode, function, mask, IMA_MAP);
+#endif
+}
+
 /*
  * ima_collect_measurement - collect file measurement
  *
@@ -318,6 +337,9 @@ void ima_store_measurement(struct integrity_iint_cache *iint,
 	if (iint->measured_pcrs & (0x1 << pcr) && !modsig)
 		return;
 
+	if (!(iint->flags & IMA_MAP) && (iint->flags & IMA_MEASURED))
+		return;
+
 	result = ima_alloc_init_template(&event_data, &entry, template_desc);
 	if (result < 0) {
 		integrity_audit_msg(AUDIT_INTEGRITY_PCR, inode, filename,
diff --git a/security/integrity/ima/ima_fs.c b/security/integrity/ima/ima_fs.c
index 2000e8df0301..7f43b745d2ad 100644
--- a/security/integrity/ima/ima_fs.c
+++ b/security/integrity/ima/ima_fs.c
@@ -449,6 +449,16 @@ static const struct file_operations ima_measure_policy_ops = {
 	.llseek = generic_file_llseek,
 };
 
+struct dentry * __init ima_fs_init_identity(void)
+{
+	struct dentry *id_dir = NULL;
+
+	id_dir = securityfs_create_dir("iso-identity", ima_dir);
+	if (IS_ERR(id_dir))
+		return NULL;
+	return id_dir;
+}
+
 int __init ima_fs_init(void)
 {
 	ima_dir = securityfs_create_dir("ima", integrity_dir);
diff --git a/security/integrity/ima/ima_identity.c b/security/integrity/ima/ima_identity.c
new file mode 100644
index 000000000000..dc38017094a2
--- /dev/null
+++ b/security/integrity/ima/ima_identity.c
@@ -0,0 +1,2194 @@
+/*
+ * Copyright (C) 2020 Enjellic Systems Development, LLC
+ *
+ * Authors:
+ * Dr. Greg Wettstein <greg@enjellic.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation, version 2 of the
+ * License.
+ *
+ * File: ima_identity.c
+ *	Implements generation of a process identity.
+ *	Implements maintenance of the iso-identity measurement list.
+ */
+#include <linux/namei.h>
+#include <linux/seq_file.h>
+#include <linux/syscalls.h>
+#include <linux/ima.h>
+#include <linux/sysfs.h>
+#include <linux/user_namespace.h>
+#include <linux/proc_ns.h>
+#include <linux/iversion.h>
+#include <crypto/hash.h>
+#include <crypto/hash_info.h>
+
+#include "ima.h"
+
+/* System call definitions. */
+#define IMA_SET_CONTOUR		0x1
+#define IMA_SET_PSEUDONYM	0x2
+#define IMA_SET_AI		0x4
+
+/* Structure defining actor identity elements. */
+struct actor_identity {
+	uid_t uid;
+	uid_t euid;
+	uid_t suid;
+
+	gid_t gid;
+	gid_t egid;
+	gid_t sgid;
+
+	uid_t fsuid;
+	gid_t fsgid;
+
+	union {
+		kernel_cap_t mask;
+		u64 value;
+	} capability;
+} __packed;
+
+/* Structure defining subject identity elements. */
+struct subject_identity {
+	uid_t uid;
+	gid_t gid;
+	umode_t mode;
+
+	u32 name_length;
+	char name[WP256_DIGEST_SIZE];
+
+	char s_id[32];
+	u8 s_uuid[16];
+
+	char digest[WP256_DIGEST_SIZE];
+} __attribute__((__packed__));
+
+/*
+ * The system aggregate measurement for export into canisters.
+ */
+static _Bool have_aggregate;
+static char aggregate[WP256_DIGEST_SIZE];
+
+/*
+ * Root dentry for the 'iso-identity' directory and dentries for the
+ * pseudo-files in that directory.
+ */
+static struct dentry *identity_dir;
+static struct dentry *contours;
+static struct dentry *map;
+static struct dentry *pseudonym;
+static struct dentry *host_identity;
+static struct dentry *sealed;
+static struct dentry *forensics;
+static struct dentry *measurement_file;
+static struct dentry *trajectory;
+
+static struct kobject *iso_identity_kobject;
+
+
+/* Structure defining an ai security event. */
+
+/* Types of AI events. */
+enum AIevent_type {
+	AI_file_open=0,
+	AI_socket_connect,
+	AI_socket_listen,
+	AI_undefined
+};
+
+enum AIevent_action {
+	AI_action_log=0,
+	AI_action_eperm,
+};
+
+const char *AI_actions[] = {
+	"LOG",
+	"EPERM"
+};
+
+struct AIevent {
+	enum AIevent_action action;
+	char *description;
+};
+
+struct AIdescription {
+	char process[TASK_COMM_LEN];
+	struct AIevent *descn;
+};
+
+/* Array of structures defining the possible events. */
+struct AIevent AI_events[] = {
+	{AI_action_log, "file_open"},
+	{AI_action_log, "socket_connect"},
+	{AI_action_log, "socket_listen"}
+};
+
+
+/* Structure defining a behavior contour point. */
+struct contour {
+	struct list_head list;
+	char identity[WP256_DIGEST_SIZE];
+	bool valid;
+};
+
+/* Structure defining an execution trajectory point. */
+struct trajectory {
+	struct list_head list;
+	char *filename;
+	char *process;
+	pid_t pid;
+	struct actor_identity actor;
+	struct subject_identity subject;
+};
+
+/* Types of events. */
+enum event_types {
+	measurement_event=1,
+	exchange_event,
+	aggregate_event,
+	seal_event,
+	ai_event
+};
+
+/* Structure defining a model event. */
+struct event {
+	struct list_head list;
+
+	enum event_types type;
+
+	union {
+		char measurement[TPM_DIGEST_SIZE];
+		struct trajectory *exchange;
+		struct AIdescription ai;
+	} u;
+};
+
+
+/*
+ * The following structure encapsulates all of the information needed
+ * to support a behavior namespace.
+ */
+struct iso_identity_map {
+	char hostid[WP256_DIGEST_SIZE];
+	char measurement [WP256_DIGEST_SIZE];
+
+	struct contour cp;
+	unsigned int contour_count;
+	struct mutex contour_list_mutex;
+	struct list_head contour_list;
+
+	unsigned int trajectory_count;
+	struct mutex trajectory_list_mutex;
+	struct list_head trajectory_list;
+
+	bool domain_sealed;
+	unsigned int forensics_count;
+	unsigned int max_forensics_count;
+	struct list_head forensics_list;
+
+	struct mutex measurement_mutex;
+	struct list_head measurement_list;
+
+	struct AIevent *AI_events;
+
+	struct kobj_attribute update;
+} init_iso_identity_map = {
+	.contour_list_mutex = __MUTEX_INITIALIZER(init_iso_identity_map.contour_list_mutex),
+	.contour_list = LIST_HEAD_INIT(init_iso_identity_map.contour_list),
+
+	.trajectory_list_mutex = __MUTEX_INITIALIZER(init_iso_identity_map.trajectory_list_mutex),
+	.trajectory_list = LIST_HEAD_INIT(init_iso_identity_map.trajectory_list),
+	.max_forensics_count = 10,
+	.forensics_list = LIST_HEAD_INIT(init_iso_identity_map.forensics_list),
+
+	.measurement_mutex = __MUTEX_INITIALIZER(init_iso_identity_map.measurement_mutex),
+	.measurement_list = LIST_HEAD_INIT(init_iso_identity_map.measurement_list),
+
+	.AI_events = AI_events
+};
+
+struct iso_identity_namespace init_iso_identity_ns = {
+        .kref = KREF_INIT(2),
+
+	.map = &init_iso_identity_map,
+
+	.ns.inum = PROC_BEHAVIOR_INIT_INO,
+	.ns.ops = &behavior_operations
+};
+
+static atomic_t map_opencount = ATOMIC_INIT(1);
+
+/**
+ *	current_map - This function returns the currently active
+ *	behavior behavior namespace.
+ *
+ *	Returns a a pointer to the currently active behavioral map.
+ */
+
+static struct iso_identity_map *current_map(void)
+{
+	if (current->nsproxy->behavior_ns)
+		return current->nsproxy->behavior_ns->map;
+	return init_iso_identity_ns.map;
+}
+
+/**
+ *	emit_event - This function is responsible for nerating a
+ *	userspace behavior event.
+ *	@map:	The behavior namespace the event is to be generated in.
+ *	@event: the enumerated event type.
+ *
+ *	returns the status of event generation.
+ */
+
+static int generate_event(struct iso_identity_map *map, enum event_types event)
+{
+	int retn=0;
+
+	struct event *mp;
+
+	mp = kzalloc(sizeof(struct event), GFP_KERNEL);
+	if (!mp) {
+		retn = -ENOMEM;
+		goto done;
+	}
+
+	mp->type = event;
+
+	mutex_lock(&map->measurement_mutex);
+	list_add_tail(&mp->list, &map->measurement_list);
+	mutex_unlock(&map->measurement_mutex);
+
+	sysfs_notify(iso_identity_kobject, NULL, map->update.attr.name);
+
+ done:
+	return retn;
+}
+
+/**
+ *	get_identity - Obtain user identity factors.
+ *	*id: A pointer to the user identity structure to be populated.
+ *
+ *	This function populates the provided structure with the
+ *	elements used to define an actor's identity state.
+ */
+
+static void get_identity(struct actor_identity *id)
+
+{
+	kernel_cap_t eff, per, inh;
+
+	id->uid = from_kuid(&init_user_ns, current_uid());
+	id->euid = from_kuid(&init_user_ns, current_euid());
+	id->suid = from_kuid(&init_user_ns, current_suid());
+
+	id->gid = from_kgid(&init_user_ns, current_gid());
+	id->egid = from_kgid(&init_user_ns, current_egid());
+	id->sgid = from_kgid(&init_user_ns, current_sgid());
+
+	id->fsuid = from_kuid(&init_user_ns, current_fsuid());
+	id->fsgid = from_kgid(&init_user_ns, current_fsgid());
+
+	if (security_capget(current, &eff, &inh, &per) != 0 ) {
+		eff = CAP_FULL_SET;
+		per = CAP_FULL_SET;
+	}
+	id->capability.mask = cap_combine(eff, per);
+
+	return;
+}
+
+/**
+ *	have_contour - Search contour list for a given point.
+ *	@point: buffer containing the contour point to search for.
+ *
+ *	Search the current contour list attempting to find the
+ *	point specified by the caller.  Return true if the point
+ *	is located.
+ */
+
+static int have_contour(char *point)
+{
+	int retn = 0;
+	struct contour *entry;
+	struct iso_identity_map *map = current_map();
+
+	mutex_lock(&map->contour_list_mutex);
+	list_for_each_entry(entry, &map->contour_list, list) {
+		if (memcmp(entry->identity, point, WP256_DIGEST_SIZE) == 0) {
+			retn = 1;
+			goto done;
+		}
+	}
+
+ done:
+	mutex_unlock(&map->contour_list_mutex);
+	return retn;
+}
+
+/**
+ *	have_valid_contour - Search contour list for a given point.
+ *	@point: buffer containing the contour point to search for.
+ *
+ *	Search the current contour list attempting to find the
+ *	point specified by the caller.  Return true if the point
+ *	is located.
+ */
+
+static int have_valid_contour(char *point)
+{
+	int retn = 0;
+	struct contour *entry;
+	struct iso_identity_map *map = current_map();
+
+	mutex_lock(&map->contour_list_mutex);
+	list_for_each_entry(entry, &map->contour_list, list) {
+		if (memcmp(entry->identity, point, WP256_DIGEST_SIZE) == 0 &&
+		    entry->valid) {
+			retn = 1;
+			goto done;
+		}
+	}
+
+ done:
+	mutex_unlock(&map->contour_list_mutex);
+	return retn;
+}
+
+/**
+ *	add_countour_point - Add a point to the contour list.
+ *	@point: buffer containing the contour point to add.
+ *	@valid: The status of the point.
+ *
+ *	Returns a non-zero value on a failure to add a point.
+ */
+
+static int add_contour_point(char *point, bool valid)
+{
+	int retn = 1;
+	struct contour *entry;
+	struct iso_identity_map *map = current_map();
+
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	if (!entry)
+		goto done;
+
+	mutex_lock(&map->contour_list_mutex);
+	memcpy(entry->identity, point, WP256_DIGEST_SIZE);
+	entry->valid = valid;
+	list_add_tail(&entry->list, &map->contour_list);
+	++map->contour_count;
+	mutex_unlock(&map->contour_list_mutex);
+	retn = 0;
+
+ done:
+	return retn;
+}
+
+/**
+ *	create_point - This function is a helper function for the
+ *	add add_contour_point() and add_forensic_point() functions.  It
+ *	consolidates all of the functionality needed to create the
+ *	list entry leaving the addition of the entry to the calling
+ *	functions.
+ */
+
+static struct trajectory * create_point(const char *filename,
+					struct actor_identity *actor,
+					struct subject_identity *subject)
+{
+	bool err = true;
+	char *fname = NULL, *process = NULL;
+	struct trajectory *entry = NULL;
+
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	if (!entry)
+		goto done;
+	fname = kzalloc(strlen(filename) + 1, GFP_KERNEL);
+	if ( !fname )
+		goto done;
+	entry->filename = fname;
+	process = kzalloc(strlen(current->comm) + 1, GFP_KERNEL);
+	if (!process)
+		goto done;
+	entry->process = process;
+
+	strcpy(entry->filename, filename);
+	strcpy(entry->process, current->comm);
+	entry->pid = task_pid_nr(current);
+	entry->actor = *actor;
+	entry->subject = *subject;
+
+	err = false;
+
+ done:
+	if ( err )
+		kfree(entry);
+
+	return entry;
+}
+
+/**
+ *	add_trajectory_point - Add a point to the system behavior trajectory.
+ *	@filename: The name of the event.
+ *	@actor: The actor identity elements.
+ *	@subject: The subject identity elements.
+ *
+ *	Returns a non-zero value on a failure to add a point.
+ */
+
+static int add_trajectory_point(const char *filename,
+				struct actor_identity *actor,
+				struct subject_identity *subject)
+{
+	int retn = 1;
+	char *fname = NULL, *process = NULL;
+	struct trajectory *entry;
+	struct iso_identity_map *map= current_map();
+
+	entry = create_point(filename, actor, subject);
+	if ( !entry )
+		goto done;
+
+	mutex_lock(&map->trajectory_list_mutex);
+	list_add_tail(&entry->list, &map->trajectory_list);
+	++map->trajectory_count;
+	mutex_unlock(&map->trajectory_list_mutex);
+	retn = 0;
+
+ done:
+	if (retn) {
+		kfree(entry);
+		kfree(fname);
+		kfree(process);
+	}
+	return retn;
+}
+
+/**
+ *	add_forensic_point - Add a point which documents a forensic
+ *	event on the trajectory surface.
+ *	@filename: The name of the event.
+ *	@actor: The actor identity elements.
+ *	@subject: The subject identity elements.
+ *
+ *	Returns a non-zero value on a failure to add a point.
+ */
+
+static int add_forensic_point(const char *filename,
+			      struct actor_identity *actor,
+			      struct subject_identity *subject)
+{
+	int retn = 1;
+	struct trajectory *entry;
+	struct iso_identity_map *map = current_map();
+
+	if (map->forensics_count == map->max_forensics_count)
+		return 1;
+
+	entry = create_point(filename, actor, subject);
+	if ( !entry )
+		goto done;
+
+	mutex_lock(&map->trajectory_list_mutex);
+	list_add_tail(&entry->list, &map->forensics_list);
+	++map->forensics_count;
+	mutex_unlock(&map->trajectory_list_mutex);
+
+	pr_debug("[%s]: Registered forensic violation %d for path=%s\n",
+		 __func__, map->forensics_count, filename);
+	retn = 0;
+
+ done:
+	return retn;
+}
+
+static int add_exchange_event(const char *filename,
+			      struct actor_identity *actor,
+			      struct subject_identity *subject)
+{
+	int retn = 1;
+	struct iso_identity_map *map;
+	struct event *mp;
+	struct trajectory *event;
+
+	if (!current->nsproxy->behavior_ns)
+		return 0;
+	map = current_map();
+
+	mp = kzalloc(sizeof(struct event), GFP_KERNEL);
+	if (!mp) {
+		retn = -ENOMEM;
+		goto done;
+	}
+
+	event = create_point(filename, actor, subject);
+	if (!event) {
+		retn = -ENOMEM;
+		goto done;
+	}
+	mp->type = exchange_event;
+	mp->u.exchange = event;
+
+	mutex_lock(&map->measurement_mutex);
+	list_add_tail(&mp->list, &map->measurement_list);
+	mutex_unlock(&map->measurement_mutex);
+
+	sysfs_notify(iso_identity_kobject, NULL, map->update.attr.name);
+	schedule();
+
+ done:
+	return retn;
+}
+
+static int get_host_measurement(struct crypto_shash *tfm, char *id,
+				size_t idlength, char *digest)
+{
+	int retn;
+	SHASH_DESC_ON_STACK(shash, tfm);
+
+
+	struct iso_identity_map *map = current_map();
+
+	shash->tfm = tfm;
+	retn = crypto_shash_init(shash);
+	if (retn != 0)
+		goto done;
+	retn = crypto_shash_update(shash, map->hostid, WP256_DIGEST_SIZE);
+	if (retn != 0)
+		goto done;
+	retn = crypto_shash_finup(shash, id, idlength, digest);
+	if (retn != 0)
+		goto done;
+
+ done:
+	return retn;
+}
+
+static int update_behavior_measurement(struct crypto_shash *tfm, char *id)
+{
+	int retn;
+	char digest[WP256_DIGEST_SIZE];
+	struct iso_identity_map *map = current_map();
+	SHASH_DESC_ON_STACK(shash, tfm);
+
+	/* Map the measurement to a host dimension. */
+	retn = get_host_measurement(tfm, id, WP256_DIGEST_SIZE, digest);
+	if (retn != 0)
+		goto done;
+
+	/* Extend soft state measurement. */
+	shash->tfm = tfm;
+	retn = crypto_shash_init(shash);
+	if (retn != 0)
+		goto done;
+
+	retn = crypto_shash_update(shash, map->measurement, WP256_DIGEST_SIZE);
+	if (retn != 0)
+		goto done;
+
+	retn = crypto_shash_finup(shash, digest, sizeof(digest),
+				  map->measurement);
+
+ done:
+	return retn;
+}
+
+/**
+ *	load_pseudonym - Add a pseudonym entry to the system behavior
+ *	description.
+ *	@filename: The user space buffer containing the pathname of
+ *	the pseudonym.  This buffer is required to have a linefeed
+ *	character at the end of the buffer.
+ *	@datalen: The size of the pathname.
+ *
+ *	Returns a non-zero value on a failure to add a point.
+ */
+
+static int load_pseudonym(const char __user *pathbufr, size_t datalen)
+{
+	char *p, *bufr = NULL;
+	int retn = -EINVAL;
+	size_t amt;
+	struct inode *inode;
+	struct path path;
+	struct integrity_iint_cache *iint;
+
+	if (datalen > PAGE_SIZE)
+		return -EINVAL;
+
+	bufr = kzalloc(datalen, GFP_KERNEL);
+	if (!bufr) {
+		retn = -ENOMEM;
+		goto done;
+	}
+
+	if (copy_from_user(bufr, pathbufr, datalen)) {
+		retn = -EFAULT;
+		goto done;
+	}
+
+	p = strchr(bufr, '\n');
+	if (!p) {
+		retn = -EINVAL;
+		goto done;
+	}
+	*p = '\0';
+
+	retn = kern_path(bufr, LOOKUP_FOLLOW, &path);
+	if (retn)
+		goto done;
+	inode = path.dentry->d_inode;
+
+	inode_lock(inode);
+	iint = integrity_inode_get(inode);
+	inode_unlock(inode);
+	if (!iint) {
+		retn = -ENOENT;
+		goto done;
+	}
+
+	pr_debug("[%s]: Mapping pseudonym for %s, iint=%p, inum=%ld\n",
+		 __func__, bufr, iint, inode->i_ino);
+
+	iint->flags |= (IMA_PSEUDONYM | IMA_COLLECTED);
+#if 0
+	iint->version = inode->i_version;
+#else
+	iint->version = inode_query_iversion(inode);
+#endif
+
+	amt = sizeof(struct ima_digest_data) + WP256_DIGEST_SIZE;
+	iint->ima_hash = kzalloc(amt, GFP_KERNEL);
+	if (iint->ima_hash == NULL) {
+		retn = -ENOMEM;
+		goto done;
+	}
+	iint->ima_hash->algo = HASH_ALGO_SHA256;
+	iint->ima_hash->length = WP256_DIGEST_SIZE;
+
+	retn = 0;
+
+done:
+	kfree(bufr);
+
+	return retn;
+}
+
+/**
+ *	load_contour - Add a contour point to the system behavior
+ *	description.
+ *	@contour: The buffer containing the contour point in ASCII
+ *	hexadecimal format.
+ *	@datalen: The size of the buffer.
+ *
+ *	Returns a non-zero value on a failure to add a point.
+ */
+
+static int load_contour(const char __user *contour, size_t datalen)
+{
+	char *p, idbufr[WP256_DIGEST_SIZE*2 + 1], mapping[WP256_DIGEST_SIZE],
+		tpm_digest[SHA1_DIGEST_SIZE];
+	ssize_t retn;
+	struct crypto_shash *tfmsha1 = NULL, *tfmsha256 = NULL;
+
+	if (datalen != sizeof(idbufr)) {
+		retn = -EINVAL;
+		goto done;
+	}
+
+	memset(idbufr, '\0', sizeof(idbufr));
+	if (copy_from_user(idbufr, contour, datalen)) {
+		retn = -EFAULT;
+		goto done;
+	}
+
+	p = strchr(idbufr, '\n');
+	if (!p) {
+		retn = -EINVAL;
+		goto done;
+	}
+	*p = '\0';
+	if (hex2bin(mapping, idbufr, sizeof(mapping))) {
+		retn = -EINVAL;
+		goto done;
+	}
+
+	if (have_valid_contour(mapping)) {
+		retn = datalen;
+		goto done;
+	}
+	if (add_contour_point(mapping, true)) {
+		retn = -ENOMEM;
+		goto done;
+	}
+
+	/* Add the contour point measurement. */
+	tfmsha1 = crypto_alloc_shash("sha1", 0, 0);
+	if (IS_ERR(tfmsha1)) {
+		retn = PTR_ERR(tfmsha1);
+		goto done;
+	}
+	tfmsha256 = crypto_alloc_shash("sha256", 0, 0);
+	if (IS_ERR(tfmsha256)) {
+		retn = PTR_ERR(tfmsha256);
+		goto done;
+	}
+
+        retn = update_behavior_measurement(tfmsha256, mapping);
+	if (retn != 0)
+		goto done;
+
+	retn = get_host_measurement(tfmsha1, mapping, WP256_DIGEST_SIZE,
+				    tpm_digest);
+	if (retn != 0)
+		goto done;
+	retn = ima_pcr_extend(tpm_digest, CONFIG_IMA_MEASURE_PCR_IDX);
+	if (retn != 0)
+		goto done;
+
+	retn = 0;
+
+done:
+	if (tfmsha1)
+		crypto_free_shash(tfmsha1);
+	if (tfmsha256)
+		crypto_free_shash(tfmsha256);
+
+	return retn;
+
+}
+
+static ssize_t show_ns_update(struct kobject *kobj,
+			      struct kobj_attribute *attr, char *page)
+{
+	ssize_t retn = -ENODATA;
+	struct event *mp;
+	struct iso_identity_map *map = current_map();
+
+	mutex_lock(&map->measurement_mutex);
+	if (list_empty(&map->measurement_list))
+		goto done;
+	mp = list_first_entry(&map->measurement_list, struct event, list);
+
+	switch ( mp->type ) {
+		case aggregate_event:
+			retn = sprintf(page, "aggregate %*phN\n",
+				       (int) sizeof(aggregate), aggregate);
+			break;
+
+		case measurement_event:
+			retn = sprintf(page, "measurement %*phN\n",
+				       (int) sizeof(mp->u.measurement),
+				       mp->u.measurement);
+			break;
+		case exchange_event:
+			retn = sprintf(page, "exchange pid{%u} event{%s:%s} actor{uid=%d, euid=%d, suid=%d, gid=%d, egid=%d, sgid=%d, fsuid=%d, fsgid=%d, cap=0x%llx} subject{uid=%d, gid=%d, mode=0%o, name_length=%u, name=%*phN, s_id=%s, s_uuid=%*phN, digest=%*phN}\n",
+				       mp->u.exchange->pid,
+				       mp->u.exchange->process,
+				       mp->u.exchange->filename,
+				       mp->u.exchange->actor.uid,
+				       mp->u.exchange->actor.euid,
+				       mp->u.exchange->actor.suid,
+				       mp->u.exchange->actor.gid,
+				       mp->u.exchange->actor.egid,
+
+				       mp->u.exchange->actor.sgid,
+				       mp->u.exchange->actor.fsuid,
+				       mp->u.exchange->actor.fsgid,
+				       mp->u.exchange->actor.capability.value,
+
+				       mp->u.exchange->subject.uid,
+				       mp->u.exchange->subject.gid,
+				       mp->u.exchange->subject.mode,
+				       mp->u.exchange->subject.name_length,
+				       WP256_DIGEST_SIZE,
+				       mp->u.exchange->subject.name,
+				       mp->u.exchange->subject.s_id,
+				       (int) sizeof(mp->u.exchange->subject.s_uuid),
+				       mp->u.exchange->subject.s_uuid,
+				       WP256_DIGEST_SIZE,
+				       mp->u.exchange->subject.digest);
+			break;
+
+		case seal_event:
+			retn = sprintf(page, "%s", "sealed\n");
+			break;
+
+		case ai_event:
+			retn = sprintf(page, "ai_event actor{%s} event{%s} action{%s}\n",
+				       mp->u.ai.process,
+				       mp->u.ai.descn->description,
+				       AI_actions[mp->u.ai.descn->action]);
+			break;
+	}
+
+	list_del(&mp->list);
+
+ done:
+	mutex_unlock(&map->measurement_mutex);
+	return retn;
+}
+
+static void *ima_trajectory_start(struct seq_file *c, loff_t *pos)
+{
+	struct iso_identity_map *map = current_map();
+
+	if (*pos >= map->trajectory_count)
+		return NULL;
+
+	mutex_lock(&map->trajectory_list_mutex);
+	return seq_list_start(&map->trajectory_list, *pos);
+}
+
+static void *ima_trajectory_next(struct seq_file *c, void *p, loff_t *pos)
+{
+	struct iso_identity_map *map = current_map();
+	return seq_list_next(p, &map->trajectory_list, pos);
+}
+
+static void ima_trajectory_stop(struct seq_file *c, void *pos)
+{
+	struct iso_identity_map *map = current_map();
+	mutex_unlock(&map->trajectory_list_mutex);
+}
+
+static int ima_trajectory_show(struct seq_file *c, void *trajectory)
+{
+	struct trajectory *pt;
+
+	pt = list_entry(trajectory, struct trajectory, list);
+
+	seq_printf(c, "event{%s:%s} actor{uid=%d, euid=%d, suid=%d, gid=%d, egid=%d, sgid=%d, fsuid=%d, fsgid=%d, cap=0x%llx} subject{uid=%d, gid=%d, mode=0%o, name_length=%u, name=%*phN, s_id=%s, s_uuid=%*phN, digest=%*phN}\n",
+		   pt->process, pt->filename, pt->actor.uid, pt->actor.euid,
+		   pt->actor.suid, pt->actor.gid, pt->actor.egid,
+		   pt->actor.sgid, pt->actor.fsuid, pt->actor.fsgid,
+		   pt->actor.capability.value, pt->subject.uid,
+		   pt->subject.gid, pt->subject.mode, pt->subject.name_length,
+		   WP256_DIGEST_SIZE, pt->subject.name, pt->subject.s_id,
+		   (int) sizeof(pt->subject.s_uuid), pt->subject.s_uuid,
+		   WP256_DIGEST_SIZE, pt->subject.digest);
+
+	return 0;
+}
+
+static const struct seq_operations ima_trajectory_seqops = {
+	.start = ima_trajectory_start,
+	.next = ima_trajectory_next,
+	.stop = ima_trajectory_stop,
+	.show = ima_trajectory_show
+};
+
+static int ima_trajectory_open(struct inode *inode, struct file *file)
+{
+	struct iso_identity_map *map = current_map();
+
+	if (map->domain_sealed)
+		return -EACCES;
+	return seq_open(file, &ima_trajectory_seqops);
+}
+
+static const struct file_operations ima_trajectory_ops = {
+	.open = ima_trajectory_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = seq_release,
+};
+
+static void *ima_contours_start(struct seq_file *c, loff_t *pos)
+{
+	struct iso_identity_map *map = current_map();
+	if (*pos >= map->contour_count)
+		return NULL;
+
+	mutex_lock(&map->contour_list_mutex);
+	return seq_list_start(&map->contour_list, *pos);
+}
+
+static void *ima_contours_next(struct seq_file *c, void *p, loff_t *pos)
+{
+	struct iso_identity_map *map = current_map();
+	return seq_list_next(p, &map->contour_list, pos);
+}
+
+static void ima_contours_stop(struct seq_file *c, void *pos)
+{
+	struct iso_identity_map *map = current_map();
+	mutex_unlock(&map->contour_list_mutex);
+}
+
+static int ima_contours_show(struct seq_file *c, void *identity)
+{
+	struct contour *id;
+
+	id = list_entry(identity, struct contour, list);
+	seq_printf(c, "%*phN\n", WP256_DIGEST_SIZE, id->identity);
+	return 0;
+}
+
+static const struct seq_operations ima_contours_seqops = {
+	.start = ima_contours_start,
+	.next = ima_contours_next,
+	.stop = ima_contours_stop,
+	.show = ima_contours_show
+};
+
+static int ima_contours_open(struct inode *inode, struct file *file)
+{
+	struct iso_identity_map *map = current_map();
+
+	if (map->domain_sealed)
+		return -EACCES;
+	return seq_open(file, &ima_contours_seqops);
+}
+
+static const struct file_operations ima_contours_ops = {
+	.open = ima_contours_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = seq_release,
+};
+
+static int ima_open_map(struct inode * inode, struct file * filp)
+{
+	struct iso_identity_map *map = current_map();
+
+	if (map->domain_sealed)
+		return -EACCES;
+	if (!(filp->f_flags & O_WRONLY))
+		return -EACCES;
+	if (atomic_dec_and_test(&map_opencount))
+		return 0;
+	return -EBUSY;
+}
+
+static ssize_t ima_write_map(struct file *file, const char __user *buf,
+			     size_t datalen, loff_t *ppos)
+{
+	ssize_t retn;
+
+	if (*ppos != 0) {
+		retn = -EINVAL;
+		goto done;
+	}
+
+	retn = load_contour(buf, datalen);
+	if ( retn != 0 )
+		goto done;
+
+	retn = datalen;
+
+done:
+	return retn;
+}
+
+static int ima_release_map(struct inode *inode, struct file *file)
+{
+	atomic_set(&map_opencount, 1);
+	return 0;
+}
+
+static const struct file_operations ima_map_ops = {
+	.open = ima_open_map,
+	.write = ima_write_map,
+	.release = ima_release_map,
+	.llseek = generic_file_llseek,
+};
+
+static int ima_open_pseudonym(struct inode * inode, struct file * filp)
+{
+	struct iso_identity_map *map = current_map();
+
+	if (map->domain_sealed)
+		return -EACCES;
+	if (!(filp->f_flags & O_WRONLY))
+		return -EACCES;
+	return 0;
+}
+
+static ssize_t ima_write_pseudonym(struct file *file, const char __user *buf,
+				   size_t datalen, loff_t *ppos)
+{
+	ssize_t retn;
+
+	if (datalen > PAGE_SIZE) {
+		retn = -EINVAL;
+		goto done;
+	}
+
+	if (*ppos != 0) {
+		retn = -EINVAL;
+		goto done;
+	}
+
+	retn = load_pseudonym(buf, datalen);
+	if ( retn != 0 )
+		goto done;
+
+	retn = datalen;
+
+done:
+	return retn;
+}
+
+static int ima_release_pseudonym(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static const struct file_operations ima_pseudonym_ops = {
+	.open = ima_open_pseudonym,
+	.write = ima_write_pseudonym,
+	.release = ima_release_pseudonym,
+	.llseek = generic_file_llseek,
+};
+
+static int ima_open_host_identity(struct inode * inode, struct file * filp)
+{
+	struct iso_identity_map *map = current_map();
+
+	if (map->domain_sealed)
+		return -EACCES;
+	if (!(filp->f_flags & O_WRONLY))
+		return -EACCES;
+	return 0;
+}
+
+static ssize_t ima_write_host_identity(struct file *file,
+				       const char __user *buf, size_t datalen,
+				       loff_t *ppos)
+{
+	char *p, id[WP256_DIGEST_SIZE*2 + 1];
+	ssize_t retn;
+	struct iso_identity_map *map = current_map();
+
+	if (datalen != sizeof(id)) {
+		retn = -EINVAL;
+		goto done;
+	}
+
+	if (*ppos != 0) {
+		retn = -EINVAL;
+		goto done;
+	}
+
+	if (copy_from_user(id, buf, datalen)) {
+		retn = -EFAULT;
+		goto done;
+	}
+
+	p = strchr(id, '\n');
+	if (!p) {
+		retn = -EINVAL;
+		goto done;
+	}
+	*p = '\0';
+
+	if (hex2bin(map->hostid, id, WP256_DIGEST_SIZE)) {
+		retn = -EINVAL;
+		goto done;
+	}
+
+	pr_debug("[%s]: Set host identity to %*phN\n", __func__,
+		 (int) WP256_DIGEST_SIZE, map->hostid);
+	retn = datalen;
+
+done:
+	return retn;
+}
+
+static int ima_release_host_identity(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static const struct file_operations ima_host_identity_ops = {
+	.open = ima_open_host_identity,
+	.write = ima_write_host_identity,
+	.release = ima_release_host_identity,
+	.llseek = generic_file_llseek,
+};
+
+static int ima_open_sealed(struct inode * inode, struct file * filp)
+{
+	struct iso_identity_map *map = current_map();
+
+	if (map->domain_sealed)
+		return -EACCES;
+	if (!(filp->f_flags & O_WRONLY))
+		return -EACCES;
+	return 0;
+}
+
+static ssize_t ima_write_sealed(struct file *file,
+				const char __user *buf, size_t datalen,
+				loff_t *ppos)
+{
+	char sealed[2];
+	ssize_t retn;
+	struct iso_identity_map *map = current_map();
+
+	if (datalen != 2) {
+		retn = -EINVAL;
+		goto done;
+	}
+
+	if (*ppos != 0) {
+		retn = -EINVAL;
+		goto done;
+	}
+
+	if (copy_from_user(sealed, buf, sizeof(sealed))) {
+		retn = -EFAULT;
+		goto done;
+	}
+
+	if (sealed[1] != '\n') {
+		retn = -EINVAL;
+		goto done;
+	}
+	if (sealed[0] != '1') {
+		retn = -EINVAL;
+		goto done;
+	}
+	map->domain_sealed = true;
+	retn = generate_event(map, seal_event);
+	if (retn)
+		goto done;
+
+	pr_debug("[%s]: Sealed identity domain.\n", __func__);
+	retn = datalen;
+
+done:
+	return retn;
+}
+
+static int ima_release_sealed(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static const struct file_operations ima_sealed_ops = {
+	.open = ima_open_sealed,
+	.write = ima_write_sealed,
+	.release = ima_release_sealed,
+	.llseek = generic_file_llseek,
+};
+
+static void *ima_forensics_start(struct seq_file *c, loff_t *pos)
+{
+	struct iso_identity_map *map = current_map();
+
+	if (*pos >= map->forensics_count)
+		return NULL;
+
+	mutex_lock(&map->trajectory_list_mutex);
+	return seq_list_start(&map->forensics_list, *pos);
+}
+
+static void *ima_forensics_next(struct seq_file *c, void *p, loff_t *pos)
+{
+	struct iso_identity_map *map = current_map();
+
+	return seq_list_next(p, &map->forensics_list, pos);
+}
+
+static void ima_forensics_stop(struct seq_file *c, void *pos)
+{
+	struct iso_identity_map *map = current_map();
+
+	mutex_unlock(&map->trajectory_list_mutex);
+}
+
+static int ima_forensics_show(struct seq_file *c, void *event)
+{
+	struct trajectory *pt;
+
+	pt = list_entry(event, struct trajectory, list);
+
+	seq_printf(c, "event{%s:%s} actor{uid=%d, euid=%d, suid=%d, gid=%d, egid=%d, sgid=%d, fsuid=%d, fsgid=%d, cap=0x%llx} subject{uid=%d, gid=%d, mode=0%o, name_length=%u, name=%*phN, s_id=%s, s_uuid=%*phN, digest=%*phN}\n",
+		   pt->process, pt->filename, pt->actor.uid, pt->actor.euid,
+		   pt->actor.suid, pt->actor.gid, pt->actor.egid,
+		   pt->actor.sgid, pt->actor.fsuid, pt->actor.fsgid,
+		   pt->actor.capability.value, pt->subject.uid,
+		   pt->subject.gid, pt->subject.mode, pt->subject.name_length,
+		   WP256_DIGEST_SIZE, pt->subject.name, pt->subject.s_id,
+		   (int) sizeof(pt->subject.s_uuid), pt->subject.s_uuid,
+		   WP256_DIGEST_SIZE, pt->subject.digest);
+
+	return 0;
+}
+
+static const struct seq_operations ima_forensics_seqops = {
+	.start = ima_forensics_start,
+	.next = ima_forensics_next,
+	.stop = ima_forensics_stop,
+	.show = ima_forensics_show
+};
+
+static int ima_forensics_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &ima_forensics_seqops);
+}
+
+static const struct file_operations ima_forensics_ops = {
+	.open = ima_forensics_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = seq_release,
+};
+
+static void *ima_measurement_start(struct seq_file *c, loff_t *pos)
+{
+	struct iso_identity_map *map = current_map();
+
+	if (*pos > 0)
+		return NULL;
+
+	return map->measurement;
+}
+
+static void *ima_measurement_next(struct seq_file *c, void *p, loff_t *pos)
+{
+	return NULL;
+}
+
+static void ima_measurement_stop(struct seq_file *c, void *pos)
+{
+	return;
+}
+
+static int ima_measurement_show(struct seq_file *c, void *event)
+{
+	struct iso_identity_map *map = current_map();
+
+	seq_printf(c, "%*phN\n", (int) sizeof(map->measurement),
+		   map->measurement);
+	return 0;
+}
+
+static const struct seq_operations ima_measurement_seqops = {
+	.start = ima_measurement_start,
+	.next = ima_measurement_next,
+	.stop = ima_measurement_stop,
+	.show = ima_measurement_show
+};
+
+static int ima_measurement_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &ima_measurement_seqops);
+}
+
+static const struct file_operations ima_measurement_ops = {
+	.open = ima_measurement_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = seq_release,
+};
+
+static int have_violation(struct file *file, struct integrity_iint_cache *iint,
+			  const char *pathname)
+{
+	bool tomtou = false, writers = false;
+	struct inode *inode = file_inode(file);
+
+	/* Check for possible violation conditions. */
+	if (file->f_mode & FMODE_WRITE) {
+		if (atomic_read(&inode->i_readcount) && IS_IMA(inode)) {
+			if (!iint)
+				iint = integrity_iint_find(inode);
+			if (iint && test_bit(IMA_MUST_MEASURE,
+						&iint->atomic_flags))
+			tomtou = true;
+		}
+
+	}
+	if (ima_must_map(inode, MAY_READ, FILE_CHECK) &&
+	    (atomic_read(&inode->i_writecount) > 0))
+		writers = true;
+
+	if (iint->flags & IMA_PSEUDONYM) {
+		if (tomtou)
+			pr_debug("[%s]: Pseudonym inhibited TOMTOU violation\n",
+				 __func__);
+		if (writers)
+			pr_debug("[%s]: Pseudonym inibited writers violation\n",
+				 __func__);
+		return 0;
+	}
+
+	if (tomtou || writers) {
+		if (tomtou)
+			ima_add_violation(file, pathname, iint, "invalid_pcr",
+					  "ToMToU");
+		if (writers)
+			ima_add_violation(file, pathname, iint, "invalid_pcr",
+					  "open_writers");
+	}
+
+	return tomtou || writers;
+}
+
+int ima_identity_genhash(struct ima_template_entry *entry, char *tpm_digest)
+{
+	int retn;
+	struct {
+		struct ima_digest_data hdr;
+		char digest[WP256_DIGEST_SIZE];
+	} identity;
+	struct crypto_shash *tfm = NULL;
+
+	/* Construct identity. */
+	identity.hdr.algo = HASH_ALGO_SHA256;
+	retn = ima_calc_field_array_hash(&entry->template_data[0],
+					 entry->template_desc,
+					 entry->template_desc->num_fields,
+					 &identity.hdr);
+	if (retn != 0)
+		goto done;
+
+	/* Save the aggregate measurement. */
+	if (!have_aggregate) {
+		memcpy(aggregate, identity.hdr.digest, WP256_DIGEST_SIZE);
+		have_aggregate = true;
+		pr_debug("ima_identity: Saved aggregate: %*phN\n",
+			 WP256_DIGEST_SIZE, aggregate);
+	}
+
+	/* Extend current identity measurement state. */
+	tfm = crypto_alloc_shash("sha256", 0, 0);
+	if (IS_ERR(tfm)) {
+		retn = PTR_ERR(tfm);
+		goto done;
+	}
+        retn = update_behavior_measurement(tfm, identity.hdr.digest);
+	if (retn != 0)
+		goto done;
+	crypto_free_shash(tfm);
+
+	/* Generate a hash suitable for extending TPM 1.x. */
+	tfm = crypto_alloc_shash("sha1", 0, 0);
+	if (IS_ERR(tfm))
+		return PTR_ERR(tfm);
+	retn = get_host_measurement(tfm, identity.hdr.digest,
+				    WP256_DIGEST_SIZE, tpm_digest);
+	if (retn != 0)
+		goto done;
+	retn = 0;
+
+ done:
+	crypto_free_shash(tfm);
+	return retn;
+}
+
+static int ima_get_actor_identity(struct crypto_shash *tfm,
+				  struct actor_identity *identity,
+				  char *mapping)
+{
+	int retn = 0;
+	SHASH_DESC_ON_STACK(shash, tfm);
+
+	shash->tfm = tfm;
+	retn = crypto_shash_init(shash);
+	if (retn != 0)
+		goto done;
+
+	get_identity(identity);
+	retn = crypto_shash_finup(shash, (char *) identity,sizeof(*identity),
+				  mapping);
+	pr_debug("IMA[%s]: comm=%s, pid=%d, [ue]id=%d/%d, caps=%llx, mapping=%*phN\n",
+		__func__, current->comm, current->pid, identity->uid,
+		identity->euid, identity->capability.value, WP256_DIGEST_SIZE,
+		mapping);
+
+ done:
+	return retn;
+}
+
+
+int ima_get_actor(struct ima_field_data *field_data, char *actor)
+{
+	int retn = 1;
+	struct crypto_shash *tfm;
+	struct actor_identity *identity = NULL;
+
+	tfm = crypto_alloc_shash("sha256", 0, 0);
+	if (IS_ERR(tfm))
+		return PTR_ERR(tfm);
+
+	identity = kzalloc(sizeof(*identity), GFP_KERNEL);
+	if (!identity)
+		goto done;
+
+	retn = ima_get_actor_identity(tfm, identity, actor);
+	if(retn!=0)
+		goto done;
+	field_data->identity = identity;
+	retn = 0;
+
+ done:
+	if (retn)
+		kfree(identity);
+	crypto_free_shash(tfm);
+	return retn;
+}
+
+static int ima_add_subject_name(struct crypto_shash *tfm,
+				struct subject_identity *subject,
+				struct ima_event_data *event_data)
+{
+	const char *filename;
+	int retn;
+	SHASH_DESC_ON_STACK(shash, tfm);
+
+	if (event_data->filename)
+		filename = event_data->filename;
+	else
+		filename = event_data->file->f_path.dentry->d_name.name;
+
+	shash->tfm = tfm;
+	retn = crypto_shash_init(shash);
+	if (retn != 0)
+		goto done;
+
+	retn = crypto_shash_finup(shash, filename, strlen(filename),
+				  subject->name);
+	subject->name_length = strlen(filename);
+
+ done:
+	return retn;
+}
+
+static int ima_get_subject_identity(struct crypto_shash *tfm,
+				    struct subject_identity *subject,
+				    char *identity)
+{
+	int retn = 0;
+	SHASH_DESC_ON_STACK(shash, tfm);
+
+	shash->tfm = tfm;
+	retn = crypto_shash_init(shash);
+	if (retn != 0)
+		goto done;
+
+	retn = crypto_shash_finup(shash, (char *) subject,
+				  sizeof(struct subject_identity), identity);
+
+ done:
+	return retn;
+}
+
+int ima_get_subject(struct ima_event_data *event_data,
+		    struct ima_field_data *field_data, char *subject)
+{
+	const char *filename;
+	int retn=1;
+	struct crypto_shash *tfm;
+	struct subject_identity *identity = NULL;
+	struct inode *inode;
+
+	tfm = crypto_alloc_shash("sha256", 0, 0);
+	if (IS_ERR(tfm))
+		return PTR_ERR(tfm);
+
+	identity = kzalloc(sizeof(*identity), GFP_KERNEL);
+	if (!identity)
+		goto done;
+
+	filename = event_data->filename;
+	memset(identity, '\0', sizeof(struct subject_identity));
+
+	/* Add hash of subject name. */
+	if (ima_add_subject_name(tfm, identity, event_data) != 0)
+		goto done;
+
+	/* Add the digest of the subject. */
+	memcpy(identity->digest, event_data->iint->ima_hash->digest,
+	       WP256_DIGEST_SIZE);
+
+	/* Add subject characteristics. */
+	if (event_data->file) {
+		inode = file_inode(event_data->file);
+		identity->uid = from_kuid(&init_user_ns, inode->i_uid);
+		identity->gid = from_kgid(&init_user_ns, inode->i_gid);
+		identity->mode = inode->i_mode;
+		memcpy(identity->s_id, inode->i_sb->s_id,
+		       sizeof(identity->s_id));
+		memcpy(identity->s_uuid, inode->i_sb->s_uuid.b,
+		       sizeof(identity->s_uuid));
+	}
+
+	retn = ima_get_subject_identity(tfm, identity, subject);
+	if (retn)
+		goto done;
+	field_data->identity = identity;
+	retn = 0;
+
+ done:
+	if (retn)
+		kfree(identity);
+	crypto_free_shash(tfm);
+	return retn;
+}
+
+static int ima_map_identity(int function, struct integrity_iint_cache *iint,
+			    struct ima_template_desc *template_desc,
+			    struct file *file, const char *pathname,
+			    struct actor_identity *actor,
+			    struct subject_identity *subject, char *mapping)
+{
+	int retn, num_fields;
+	struct ima_template_entry *entry;
+	struct {
+		struct ima_digest_data hdr;
+		char digest[WP256_DIGEST_SIZE];
+	} hash;
+	struct ima_event_data event_data = {
+		iint,
+		file,
+		pathname,
+		NULL,
+		0,
+		NULL
+	};
+
+	retn = ima_alloc_init_template(&event_data, &entry, template_desc);
+	if (retn != 0 )
+		goto done;
+
+	num_fields = entry->template_desc->num_fields;
+	hash.hdr.algo = HASH_ALGO_SHA256;
+	retn = ima_calc_field_array_hash(&entry->template_data[0],
+					 entry->template_desc,
+					 num_fields, &hash.hdr);
+
+	*actor = *(struct actor_identity *) entry->template_data[0].identity;
+	*subject = *(struct subject_identity *) entry->template_data[1].identity;
+	memcpy(mapping, hash.digest, sizeof(hash.digest));
+
+	ima_free_template_entry(entry);
+	retn = 0;
+
+ done:
+	return retn;
+}
+
+static void ima_set_actor_status(int function, const char *pathname,
+				 struct subject_identity *subject,
+				 char *mapping)
+{
+	struct iso_identity_map *map = current_map();
+
+	if (!current->in_execve)
+		return;
+	if (!map->domain_sealed)
+		return;
+	if ((function != BPRM_CHECK) && (function != MMAP_CHECK))
+		return;
+
+	pr_debug("[%s]: Actor %d:%s function=%d, subject=%*phN, status=%u\n",
+		 __func__, current->pid, pathname, function, WP256_DIGEST_SIZE,
+		 subject->digest, current->bad_actor);
+	if (!have_valid_contour(mapping)) {
+		current->bad_actor = 1;
+		pr_debug("[%s]: Setting bad actor status.\n", __func__);
+	}
+
+	return;
+}
+
+int ima_identity_is_mapped(int function, struct integrity_iint_cache *iint,
+			   struct file *file, const char *pathname,
+			   struct ima_template_desc *template_desc,
+			   int violation_check)
+{
+	int retn = 0;
+	char mapping[WP256_DIGEST_SIZE];
+	struct actor_identity actor;
+	struct subject_identity subject;
+	struct iso_identity_map *map = current_map();
+
+	if (have_violation(file, iint, pathname))
+		return 1;
+
+	if (ima_map_identity(function, iint, template_desc, file, pathname,
+			     &actor, &subject, mapping) != 0)
+		return 0;
+
+	ima_set_actor_status(function, pathname, &subject, mapping);
+
+	add_exchange_event(pathname, &actor, &subject);
+
+	if (have_contour(mapping)) {
+		pr_debug("[%s]: Contour cache hit path=%s, mapping=%*phN\n",
+			 __func__, pathname, WP256_DIGEST_SIZE, mapping);
+		return 1;
+	}
+
+	pr_debug("[%s] actor uid=%d, euid=%d, suid=%d, gid=%d, egid=%d, sgid=%d, fsuid=%d, fsgid=%d, cap=%llx\n", __func__, actor.uid, actor.euid,
+		actor.suid, actor.gid, actor.egid, actor.sgid, actor.fsuid,
+		actor.fsgid, actor.capability.value);
+	pr_debug("[%s] subject: filename=%s, mode=o%o, uid=%u, gid=%u, name size/hash=%u/%*phN, super name/uuid=%s/%*phN, subject=%*phN\n",
+		__func__, pathname, subject.mode, subject.uid, subject.gid,
+		subject.name_length, WP256_DIGEST_SIZE, subject.name,
+		subject.s_id, (int) sizeof(subject.s_uuid), subject.s_uuid,
+		WP256_DIGEST_SIZE, subject.digest);
+
+	if (map->domain_sealed) {
+		retn = add_forensic_point(pathname, &actor, &subject);
+		if (retn == 0 )
+			retn = add_contour_point(mapping, false);
+	}
+	else {
+		retn = add_contour_point(mapping, true);
+		if (retn == 0)
+			retn = add_trajectory_point(pathname, &actor,
+						    &subject);
+	}
+	if (retn != 0 )
+		retn = 0;
+
+
+	if (!retn)
+		pr_debug("[%s]: Mapped entry: comm=%s, pid=%d, func=%d, pathname=%s, fsmagic=%lx, inum=%lu, identity=%*phN\n",
+			__func__, current->comm, current->pid, function,
+			 pathname, iint->inode->i_sb->s_magic,
+			 iint->inode->i_ino, WP256_DIGEST_SIZE, mapping);
+	return retn;
+}
+
+int __init ima_identity_init(void)
+{
+	int retn = -1;
+
+	identity_dir = ima_fs_init_identity();
+	if (identity_dir == NULL)
+		goto done;
+
+	contours = securityfs_create_file("contours", S_IRUSR | S_IRGRP,
+					  identity_dir, NULL,
+					  &ima_contours_ops);
+	if (IS_ERR(contours))
+		goto err;
+
+	map = securityfs_create_file("map", S_IWUSR, identity_dir, NULL,
+				     &ima_map_ops);
+	if (IS_ERR(map))
+		goto err;
+
+	pseudonym = securityfs_create_file("pseudonym", S_IWUSR, identity_dir,
+					   NULL, &ima_pseudonym_ops);
+	if (IS_ERR(pseudonym))
+		goto err;
+
+	host_identity = securityfs_create_file("host_identity", S_IWUSR,
+					       identity_dir, NULL,
+					       &ima_host_identity_ops);
+	if (IS_ERR(host_identity))
+		goto err;
+
+	sealed = securityfs_create_file("sealed", S_IWUSR, identity_dir, NULL,
+					&ima_sealed_ops);
+	if (IS_ERR(sealed))
+		goto err;
+
+	forensics = securityfs_create_file("forensics", S_IRUSR | S_IRGRP,
+					   identity_dir, NULL,
+					   &ima_forensics_ops);
+	if (IS_ERR(forensics))
+		goto err;
+
+	measurement_file = securityfs_create_file("measurement",
+						  S_IRUSR | S_IRGRP,
+						  identity_dir, NULL,
+						  &ima_measurement_ops);
+	if (IS_ERR(measurement_file))
+		goto err;
+
+	trajectory = securityfs_create_file("trajectory",
+					    S_IRUSR | S_IRGRP,
+					    identity_dir, NULL,
+					    &ima_trajectory_ops);
+	if (IS_ERR(trajectory))
+		goto err;
+
+	iso_identity_kobject = kobject_create_and_add("iso-identity", fs_kobj);
+	if (!iso_identity_kobject)
+		goto err;
+
+	retn = 0;
+
+ done:
+	return retn;
+
+ err:
+	securityfs_remove(contours);
+	securityfs_remove(map);
+	securityfs_remove(pseudonym);
+	securityfs_remove(host_identity);
+	securityfs_remove(sealed);
+	securityfs_remove(forensics);
+	securityfs_remove(measurement_file);
+	securityfs_remove(trajectory);
+
+	if (iso_identity_kobject)
+		kobject_put(iso_identity_kobject);
+
+	return retn;
+}
+
+int ima_measure_ns(const u8 *hash)
+{
+	int retn = 1;
+	struct iso_identity_map *map;
+	struct event *mp;
+
+	if (!current->nsproxy->behavior_ns)
+		return 0;
+
+	map = current_map();
+	mp = kzalloc(sizeof(struct event), GFP_KERNEL);
+	if (!mp) {
+		retn = -ENOMEM;
+		goto done;
+	}
+	mp->type = measurement_event;
+	memcpy(mp->u.measurement, hash, sizeof(map->measurement));
+
+	mutex_lock(&map->measurement_mutex);
+	list_add_tail(&mp->list, &map->measurement_list);
+	mutex_unlock(&map->measurement_mutex);
+
+	sysfs_notify(iso_identity_kobject, NULL, map->update.attr.name);
+
+ done:
+	return retn;
+}
+
+void ima_free_ns(struct kref *kref)
+{
+	unsigned int cnt;
+	struct iso_identity_namespace *ns;
+	struct contour *centry, *tmp_centry;
+	struct trajectory *tentry, *tmp_tentry;
+
+	ns = container_of(kref, struct iso_identity_namespace, kref);
+
+	cnt = 0;
+	list_for_each_entry_safe(centry, tmp_centry, &ns->map->contour_list,
+				 list) {
+		list_del(&centry->list);
+		pr_debug("[%s]: Removing contour: %*phN\n", __func__,
+			WP256_DIGEST_SIZE, centry->identity);
+		kfree(centry);
+		++cnt;
+	}
+	pr_debug("[%s]: Released %d contours.\n", __func__, cnt);
+
+	cnt = 0;
+	list_for_each_entry_safe(tentry, tmp_tentry, &ns->map->trajectory_list,
+				 list) {
+		list_del(&tentry->list);
+		pr_debug("[%s]: Removing trajectory event: %s/%s\n", __func__,
+			 tentry->process, tentry->filename);
+		kfree(tentry->filename);
+		kfree(tentry->process);
+		kfree(tentry);
+		++cnt;
+	}
+	pr_debug("[%s]: Released %d trajectory entries.\n", __func__, cnt);
+
+	if (ns->map->domain_sealed) {
+		cnt = 0;
+		list_for_each_entry_safe(tentry, tmp_tentry,
+					 &ns->map->forensics_list, list) {
+			list_del(&tentry->list);
+			pr_debug("[%s]: Removing forensics event: %s/%s\n",
+				 __func__, tentry->process, tentry->filename);
+			kfree(tentry->filename);
+			kfree(tentry->process);
+			kfree(tentry);
+			++cnt;
+		}
+		pr_debug("[%s]: Released %d forensic entries.\n", __func__,
+			 cnt);
+	}
+
+	sysfs_remove_file(iso_identity_kobject, &ns->map->update.attr);
+	kfree(ns->map->update.attr.name);
+
+	put_user_ns(ns->user_ns);
+	ns_free_inum(&ns->ns);
+	kfree(ns->map);
+	kfree(ns);
+
+	return;
+}
+
+static int add_aggregate(struct crypto_shash *tfm,
+			 struct iso_identity_map *map)
+{
+	int retn = 0;
+	char host_measurement[WP256_DIGEST_SIZE];
+	SHASH_DESC_ON_STACK(shash, tfm);
+	struct event *mp;
+
+	shash->tfm = tfm;
+
+	/* Extend the aggregate measurement into a host domain. */
+	retn = crypto_shash_init(shash);
+	if (retn != 0)
+		goto done;
+	retn = crypto_shash_update(shash, map->hostid, WP256_DIGEST_SIZE);
+	if (retn != 0)
+		goto done;
+	retn = crypto_shash_finup(shash, aggregate, sizeof(aggregate),
+				  host_measurement);
+	if (retn != 0)
+		goto done;
+
+
+	/* Extend the measurement with the host aggregate measurement. */
+	retn = crypto_shash_init(shash);
+	if (retn != 0)
+		goto done;
+	retn = crypto_shash_update(shash, map->measurement, WP256_DIGEST_SIZE);
+	if (retn != 0)
+		goto done;
+	retn = crypto_shash_finup(shash, host_measurement,
+				  sizeof(host_measurement), map->measurement);
+	if (retn != 0)
+		goto done;
+
+
+	/* Add the aggregate entry. */
+	mp = kzalloc(sizeof(struct event), GFP_KERNEL);
+	if (!mp) {
+		retn = -ENOMEM;
+		goto done;
+	}
+
+	mp->type = aggregate_event;
+
+	mutex_lock(&map->measurement_mutex);
+	list_add_tail(&mp->list, &map->measurement_list);
+	mutex_unlock(&map->measurement_mutex);
+
+	sysfs_notify(iso_identity_kobject, NULL, map->update.attr.name);
+
+ done:
+	return retn;
+}
+
+struct iso_identity_namespace *ima_copy_behavior_ns(unsigned long flags,
+				    struct user_namespace *user_ns,
+				    struct iso_identity_namespace *behavior_ns)
+{
+	static char *update = "update-";
+	char bufr[7 + 10 + 1];
+	int retn = 0;
+	struct iso_identity_namespace *ns;
+	struct crypto_shash *tfm = NULL;
+
+	pr_debug("[%s]: New ns = %s\n", __func__,
+		 flags & CLONE_EVENTS ? "yes" : "no");
+
+	if (behavior_ns)
+		ima_get_ns(behavior_ns);
+
+	if (!(flags & CLONE_EVENTS))
+		return behavior_ns;
+
+	ns = kzalloc(sizeof(struct iso_identity_namespace), GFP_KERNEL);
+	if (!ns) {
+		retn = -ENOMEM;
+		goto done;
+	}
+
+	retn = ns_alloc_inum(&ns->ns);
+	if (retn)
+		goto done;
+
+	ns->map = kzalloc(sizeof(struct iso_identity_map), GFP_KERNEL);
+	if (!ns->map) {
+		retn = -ENOMEM;
+		goto done;
+	}
+	mutex_init(&ns->map->contour_list_mutex);
+	INIT_LIST_HEAD(&ns->map->contour_list);
+
+	mutex_init(&ns->map->trajectory_list_mutex);
+	INIT_LIST_HEAD(&ns->map->trajectory_list);
+
+	ns->map->max_forensics_count = 10;
+	INIT_LIST_HEAD(&ns->map->forensics_list);
+
+	mutex_init(&ns->map->measurement_mutex);
+	INIT_LIST_HEAD(&ns->map->measurement_list);
+
+	ns->map->AI_events = kzalloc(sizeof(AI_events), GFP_KERNEL);
+	if (!ns->map->AI_events) {
+		retn = -ENOMEM;
+		goto done;
+	}
+	memcpy(ns->map->AI_events, AI_events, sizeof(AI_events));
+
+	if (snprintf(bufr, sizeof(bufr), "%s%u", update, ns->ns.inum) >=
+	    sizeof(bufr)) {
+		retn = -ENOMEM;
+		goto done;
+	}
+	ns->map->update.attr.name = kzalloc(strlen(bufr) + 1, GFP_KERNEL);
+	if (!ns->map->update.attr.name) {
+		retn = -ENOMEM;
+		goto done;
+	}
+	strcpy((char *) ns->map->update.attr.name, bufr);
+	ns->map->update.attr.mode = 0400;
+	ns->map->update.show = show_ns_update;
+	retn = sysfs_create_file(iso_identity_kobject, &ns->map->update.attr);
+	if(retn)
+		goto done;
+
+	tfm = crypto_alloc_shash("sha256", 0, 0);
+	if (IS_ERR(tfm)) {
+		retn = PTR_ERR(tfm);
+		goto done;
+	}
+
+	retn = add_aggregate(tfm, ns->map);
+	crypto_free_shash(tfm);
+
+ done:
+	if (retn) {
+		if (ns && ns->map) {
+			kfree(ns->map->update.attr.name);
+			kfree(ns->map->AI_events);
+			kfree(ns->map);
+		}
+		kfree(ns);
+		return ERR_PTR(retn);
+	}
+
+	kref_init(&ns->kref);
+	ns->ns.ops = &behavior_operations;
+	ns->user_ns = get_user_ns(user_ns);
+	if (behavior_ns)
+		ima_put_ns(behavior_ns);
+	return ns;
+}
+
+/*
+ * The following section handles requests to report on the status
+ * of processing of AI security events.
+ */
+
+int ima_identity_process_ai(unsigned int event)
+{
+	int retn = 0;
+
+	struct iso_identity_map *map = current_map();
+
+	struct event *ep;
+
+	/* Verify a valid event. */
+	if ( event >= AI_undefined ) {
+		pr_warn("[%s]: Undefined event\n", __func__);
+		goto done;
+	}
+
+	/* Add the event to the list. */
+	ep = kzalloc(sizeof(struct event), GFP_KERNEL);
+	if (!ep)
+		return -ENOMEM;
+
+	ep->type = ai_event;
+	ep->u.ai.descn = &map->AI_events[event];
+	strcpy(ep->u.ai.process, current->comm);
+
+	switch ( map->AI_events[event].action ) {
+		case AI_action_log:
+			retn = 0;
+			break;
+		case AI_action_eperm:
+			retn = -EPERM;
+			break;
+	}
+
+	mutex_lock(&map->measurement_mutex);
+	list_add_tail(&ep->list, &map->measurement_list);
+	mutex_unlock(&map->measurement_mutex);
+
+	sysfs_notify(iso_identity_kobject, NULL, map->update.attr.name);
+
+ done:
+	return retn;
+}
+
+
+SYSCALL_DEFINE2(set_bad_actor, pid_t, pid, unsigned long, flags)
+{
+	int retn = -ESRCH;
+	struct task_struct *actor;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	rcu_read_lock();
+	actor = find_task_by_vpid(pid);
+	if (actor != NULL) {
+		if (flags == 0) {
+			pr_debug("[%s]: Checking actor status, pid=%u\n",
+				 __func__, pid);
+			retn = actor->bad_actor;
+		}
+
+		if (flags == 1) {
+			pr_debug("[%s]: Setting actor status, pid=%u\n",
+				 __func__, pid);
+			actor->bad_actor = 1;
+			retn = 0;
+		}
+	}
+	rcu_read_unlock();
+
+	return retn;
+}
+
+SYSCALL_DEFINE3(set_behavior, unsigned char *, bufr, size_t, cnt,
+		unsigned long, flags)
+{
+	int retn = -EINVAL;
+	struct iso_identity_map *map = current_map();
+	struct ai_control {
+		unsigned int hook;
+		unsigned int action;
+	} ctl;
+	kuid_t root_uid;
+
+	pr_debug("[%s]: Called: cnt=%zu, flags=%lu.\n", __func__, cnt, flags);
+
+	/* Verify permissions for system call. */
+	if (!current->nsproxy->behavior_ns && !capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	if (current->nsproxy->behavior_ns) {
+		root_uid = make_kuid(current_cred()->user_ns, 0);
+		if ( !uid_eq(current_euid(), root_uid) )
+			return -EPERM;
+	}
+
+	/* Verify valid system call control flags. */
+	if (flags & ~(IMA_SET_CONTOUR | IMA_SET_PSEUDONYM | IMA_SET_AI))
+		return -EINVAL;
+
+
+	if (flags & IMA_SET_PSEUDONYM) {
+		if (map->domain_sealed)
+			return -EPERM;
+		retn = load_pseudonym(bufr, cnt);
+		goto done;
+	}
+
+	if (flags & IMA_SET_CONTOUR) {
+		if (map->domain_sealed)
+			return -EPERM;
+		retn = load_contour(bufr, cnt);
+		goto done;
+	}
+
+	if (flags & IMA_SET_AI) {
+		if (map->domain_sealed) {
+			retn = -EPERM;
+			goto done;
+		}
+		if (cnt != sizeof(ctl)) {
+			retn = -EINVAL;
+			goto done;
+		}
+		if (copy_from_user(&ctl, bufr, sizeof(ctl))) {
+			retn = -EFAULT;
+			goto done;
+		}
+
+		if (ctl.hook >= AI_undefined) {
+			retn = -EINVAL;
+			goto done;
+		}
+		if (ctl.action > AI_action_eperm) {
+			retn = -EINVAL;
+			goto done;
+		}
+
+		map->AI_events[ctl.hook].action = ctl.action;
+		pr_debug("%s modified ai hook %s, action=%s\n", __func__,
+			 map->AI_events[ctl.hook].description,
+			 AI_actions[ctl.action]);
+		retn = 0;
+	}
+
+ done:
+	return retn;
+}
+
+/*
+ * The following section defines the proc filesystem functions and
+ * operation dispatch structure.
+ */
+
+static void behavior_put(struct ns_common *ns)
+{
+	struct iso_identity_namespace *behavior_ns =
+		container_of(ns, struct iso_identity_namespace, ns);
+
+	ima_put_ns(behavior_ns);
+}
+
+static struct ns_common *behavior_get(struct task_struct *task)
+{
+	struct iso_identity_namespace *ns = NULL;
+	struct nsproxy *nsproxy;
+
+	task_lock(task);
+	nsproxy = task->nsproxy;
+	if (nsproxy) {
+		ns = nsproxy->behavior_ns;
+		if (ns)
+			ima_get_ns(ns);
+		else {
+			ns = &init_iso_identity_ns;
+			ima_get_ns(&init_iso_identity_ns);
+		}
+	}
+	task_unlock(task);
+
+	return ns ? &ns->ns : NULL;
+}
+
+static int behavior_install(struct nsproxy *nsproxy, struct ns_common *new)
+{
+	struct iso_identity_namespace *behavior_ns =
+		container_of(new, struct iso_identity_namespace, ns);
+
+	if (!ns_capable(behavior_ns->user_ns, CAP_SYS_ADMIN) ||
+	    !ns_capable(current_user_ns(), CAP_SYS_ADMIN))
+		return -EPERM;
+
+	if (behavior_ns) {
+		ima_get_ns(behavior_ns);
+		ima_put_ns(nsproxy->behavior_ns);
+	}
+
+	nsproxy->behavior_ns = behavior_ns;
+	return 0;
+}
+
+const struct proc_ns_operations behavior_operations = {
+	.name		= "behavior",
+	.type		= CLONE_EVENTS,
+	.get		= behavior_get,
+	.put		= behavior_put,
+	.install	= behavior_install,
+};
diff --git a/security/integrity/ima/ima_init.c b/security/integrity/ima/ima_init.c
index 5d55ade5f3b9..f2f2128b0176 100644
--- a/security/integrity/ima/ima_init.c
+++ b/security/integrity/ima/ima_init.c
@@ -131,5 +131,9 @@ int __init ima_init(void)
 
 	ima_init_policy();
 
-	return ima_fs_init();
+	rc = ima_fs_init();
+	if (rc != 0)
+		return rc;
+
+	return ima_identity_init();
 }
diff --git a/security/integrity/ima/ima_main.c b/security/integrity/ima/ima_main.c
index 60027c643ecd..d9ccee7a2553 100644
--- a/security/integrity/ima/ima_main.c
+++ b/security/integrity/ima/ima_main.c
@@ -346,6 +346,16 @@ static int process_measurement(struct file *file, const struct cred *cred,
 	if (action & IMA_AUDIT)
 		ima_audit_measurement(iint, pathname);
 
+	if (action & IMA_MAP) {
+		violation_check = ((func == FILE_CHECK || func == MMAP_CHECK));
+		if (!ima_identity_is_mapped(func, iint, file, pathname,
+					    template_desc, violation_check)) {
+			ima_store_measurement(iint, file, pathname,
+					      xattr_value, xattr_len, modsig,
+					      pcr, template_desc);
+		}
+	}
+
 	if ((file->f_flags & O_DIRECT) && (iint->flags & IMA_PERMIT_DIRECTIO))
 		rc = 0;
 out_locked:
diff --git a/security/integrity/ima/ima_policy.c b/security/integrity/ima/ima_policy.c
index 5380aca2b351..99be5c526e09 100644
--- a/security/integrity/ima/ima_policy.c
+++ b/security/integrity/ima/ima_policy.c
@@ -34,6 +34,7 @@
 #define IMA_EUID	0x0080
 #define IMA_PCR		0x0100
 #define IMA_FSNAME	0x0200
+#define IMA_CAPABILITY	0x0400
 
 #define UNKNOWN		0
 #define MEASURE		0x0001	/* same as IMA_MEASURE */
@@ -43,6 +44,8 @@
 #define AUDIT		0x0040
 #define HASH		0x0100
 #define DONT_HASH	0x0200
+#define MAP		0x010000	/* same as IMA_MAP */
+#define DONT_MAP	0x020000
 
 #define INVALID_PCR(a) (((a) < 0) || \
 	(a) >= (FIELD_SIZEOF(struct integrity_iint_cache, measured_pcrs) * 8))
@@ -56,7 +59,7 @@ enum lsm_rule_types { LSM_OBJ_USER, LSM_OBJ_ROLE, LSM_OBJ_TYPE,
 	LSM_SUBJ_USER, LSM_SUBJ_ROLE, LSM_SUBJ_TYPE
 };
 
-enum policy_types { ORIGINAL_TCB = 1, DEFAULT_TCB };
+enum policy_types { ORIGINAL_TCB = 1, DEFAULT_TCB, ISO_IDENTITY_TCB };
 
 enum policy_rule_list { IMA_DEFAULT_POLICY = 1, IMA_CUSTOM_POLICY };
 
@@ -69,6 +72,7 @@ struct ima_rule_entry {
 	unsigned long fsmagic;
 	uuid_t fsuuid;
 	kuid_t uid;
+	kernel_cap_t capability;
 	kuid_t fowner;
 	bool (*uid_op)(kuid_t, kuid_t);    /* Handlers for operators       */
 	bool (*fowner_op)(kuid_t, kuid_t); /* uid_eq(), uid_gt(), uid_lt() */
@@ -187,6 +191,17 @@ static struct ima_rule_entry build_appraise_rules[] __ro_after_init = {
 #endif
 };
 
+static struct ima_rule_entry iso_identity_measurement_rules[] = {
+	{.action = MAP,.func = MMAP_CHECK,.mask = MAY_EXEC,
+	 .flags = IMA_FUNC | IMA_MASK},
+	{.action = MAP,.func = BPRM_CHECK,.mask = MAY_EXEC,
+	 .flags = IMA_FUNC | IMA_MASK},
+	{.action = MAP, .func = FILE_CHECK, .mask = MAY_READ,
+	 .uid = GLOBAL_ROOT_UID, .capability = CAP_FULL_SET,
+	 .flags = IMA_FUNC | IMA_INMASK | IMA_CAPABILITY},
+	{.action = MAP,.func = MODULE_CHECK, .flags = IMA_FUNC},
+};
+
 static struct ima_rule_entry secure_boot_rules[] __ro_after_init = {
 	{.action = APPRAISE, .func = MODULE_CHECK,
 	 .flags = IMA_FUNC | IMA_DIGSIG_REQUIRED},
@@ -228,6 +243,10 @@ static int __init policy_setup(char *str)
 	while ((p = strsep(&str, " |\n")) != NULL) {
 		if (*p == ' ')
 			continue;
+
+		if (strcmp(p, "iso-identity") == 0)
+			ima_policy = ISO_IDENTITY_TCB;
+
 		if ((strcmp(p, "tcb") == 0) && !ima_policy)
 			ima_policy = DEFAULT_TCB;
 		else if (strcmp(p, "appraise_tcb") == 0)
@@ -372,6 +391,8 @@ static bool ima_match_rules(struct ima_rule_entry *rule, struct inode *inode,
 			    enum ima_hooks func, int mask)
 {
 	int i;
+	kernel_cap_t mcap, eff, per, inh;
+	struct task_struct *tsk = current;
 
 	if (func == KEXEC_CMDLINE) {
 		if ((rule->flags & IMA_FUNC) && (rule->func == func))
@@ -407,7 +428,14 @@ static bool ima_match_rules(struct ima_rule_entry *rule, struct inode *inode,
 		} else if (!rule->uid_op(cred->euid, rule->uid))
 			return false;
 	}
-
+	if ((rule->flags & IMA_CAPABILITY)) {
+		if (security_capget(tsk, &eff, &inh, &per))
+			return false;
+		mcap = cap_combine(eff, per);
+		mcap = cap_intersect(rule->capability, mcap);
+		if (cap_isclear(mcap))
+			return false;
+	}
 	if ((rule->flags & IMA_FOWNER) &&
 	    !rule->fowner_op(inode->i_uid, rule->fowner))
 		return false;
@@ -647,12 +675,17 @@ static int __init ima_init_arch_policy(void)
  */
 void __init ima_init_policy(void)
 {
-	int build_appraise_entries, arch_entries;
+	int i, build_appraise_entries, arch_entries;
 
 	/* if !ima_policy, we load NO default rules */
-	if (ima_policy)
+	if (ima_policy) {
+		if (ima_policy == ISO_IDENTITY_TCB) {
+			for (i=0; i < ARRAY_SIZE(dont_measure_rules); ++i)
+				dont_measure_rules[i].action = DONT_MAP;
+		}
 		add_rules(dont_measure_rules, ARRAY_SIZE(dont_measure_rules),
 			  IMA_DEFAULT_POLICY);
+	}
 
 	switch (ima_policy) {
 	case ORIGINAL_TCB:
@@ -664,6 +697,12 @@ void __init ima_init_policy(void)
 		add_rules(default_measurement_rules,
 			  ARRAY_SIZE(default_measurement_rules),
 			  IMA_DEFAULT_POLICY);
+		break;
+	case ISO_IDENTITY_TCB:
+		add_rules(iso_identity_measurement_rules,
+			  ARRAY_SIZE(iso_identity_measurement_rules),
+			  IMA_DEFAULT_POLICY);
+		break;
 	default:
 		break;
 	}
@@ -759,12 +798,13 @@ enum {
 	Opt_measure, Opt_dont_measure,
 	Opt_appraise, Opt_dont_appraise,
 	Opt_audit, Opt_hash, Opt_dont_hash,
+	Opt_map, Opt_dont_map,
 	Opt_obj_user, Opt_obj_role, Opt_obj_type,
 	Opt_subj_user, Opt_subj_role, Opt_subj_type,
 	Opt_func, Opt_mask, Opt_fsmagic, Opt_fsname,
 	Opt_fsuuid, Opt_uid_eq, Opt_euid_eq, Opt_fowner_eq,
 	Opt_uid_gt, Opt_euid_gt, Opt_fowner_gt,
-	Opt_uid_lt, Opt_euid_lt, Opt_fowner_lt,
+	Opt_uid_lt, Opt_euid_lt, Opt_capability, Opt_fowner_lt,
 	Opt_appraise_type, Opt_permit_directio,
 	Opt_pcr, Opt_template, Opt_err
 };
@@ -777,6 +817,8 @@ static const match_table_t policy_tokens = {
 	{Opt_audit, "audit"},
 	{Opt_hash, "hash"},
 	{Opt_dont_hash, "dont_hash"},
+	{Opt_map, "map"},
+	{Opt_dont_map, "dont_map"},
 	{Opt_obj_user, "obj_user=%s"},
 	{Opt_obj_role, "obj_role=%s"},
 	{Opt_obj_type, "obj_type=%s"},
@@ -796,6 +838,7 @@ static const match_table_t policy_tokens = {
 	{Opt_fowner_gt, "fowner>%s"},
 	{Opt_uid_lt, "uid<%s"},
 	{Opt_euid_lt, "euid<%s"},
+	{Opt_capability, "capablity=%s"},
 	{Opt_fowner_lt, "fowner<%s"},
 	{Opt_appraise_type, "appraise_type=%s"},
 	{Opt_permit_directio, "permit_directio"},
@@ -887,7 +930,7 @@ static int ima_parse_rule(char *rule, struct ima_rule_entry *entry)
 	char *p;
 	bool uid_token;
 	struct ima_template_desc *template_desc;
-	int result = 0;
+	int lp, result = 0;
 
 	ab = integrity_audit_log_start(audit_context(), GFP_KERNEL,
 				       AUDIT_INTEGRITY_POLICY_RULE);
@@ -964,6 +1007,22 @@ static int ima_parse_rule(char *rule, struct ima_rule_entry *entry)
 
 			entry->action = DONT_HASH;
 			break;
+		case Opt_map:
+			ima_log_string(ab, "action", "map");
+
+			if (entry->action != UNKNOWN)
+				result = -EINVAL;
+
+			entry->action = MAP;
+			break;
+		case Opt_dont_map:
+			ima_log_string(ab, "action", "dont map");
+
+			if (entry->action != UNKNOWN)
+				result = -EINVAL;
+
+			entry->action = DONT_MAP;
+			break;
 		case Opt_func:
 			ima_log_string(ab, "func", args[0].from);
 
@@ -1095,6 +1154,15 @@ static int ima_parse_rule(char *rule, struct ima_rule_entry *entry)
 					    ? IMA_UID : IMA_EUID;
 			}
 			break;
+		case Opt_capability:
+			ima_log_string(ab, "capability", args[0].from);
+			if ( strcmp(args[0].from, "any") == 0 )
+				entry->capability = CAP_FULL_SET;
+			CAP_FOR_EACH_U32(lp)
+				pr_cont("%d: 0x%x ", lp, entry->capability.cap[lp]);
+			pr_cont("\n");
+			entry->flags |= IMA_CAPABILITY;
+			break;
 		case Opt_fowner_gt:
 			entry->fowner_op = &uid_gt;
 			/* fall through */
diff --git a/security/integrity/ima/ima_queue.c b/security/integrity/ima/ima_queue.c
index 1ce8b1701566..3d76b8ec46f9 100644
--- a/security/integrity/ima/ima_queue.c
+++ b/security/integrity/ima/ima_queue.c
@@ -19,6 +19,7 @@
 
 #include <linux/rculist.h>
 #include <linux/slab.h>
+#include <linux/ima.h>
 #include "ima.h"
 
 #define AUDIT_CAUSE_LEN_MAX 32
@@ -136,7 +137,7 @@ unsigned long ima_get_binary_runtime_size(void)
 		return binary_runtime_size + sizeof(struct ima_kexec_hdr);
 };
 
-static int ima_pcr_extend(const u8 *hash, int pcr)
+int ima_pcr_extend(const u8 *hash, int pcr)
 {
 	int result = 0;
 	int i;
@@ -144,6 +145,9 @@ static int ima_pcr_extend(const u8 *hash, int pcr)
 	if (!ima_tpm_chip)
 		return result;
 
+	if(ima_measure_ns(hash) == 1)
+		return result;
+
 	for (i = 0; i < ima_tpm_chip->nr_allocated_banks; i++)
 		memcpy(digests[i].digest, hash, TPM_DIGEST_SIZE);
 
@@ -172,7 +176,9 @@ int ima_add_template_entry(struct ima_template_entry *entry, int violation,
 	int result = 0, tpmresult = 0;
 
 	mutex_lock(&ima_extend_list_mutex);
-	if (!violation) {
+	if (current->nsproxy->behavior_ns)
+		memcpy(digest, entry->digest, sizeof(digest));
+	if (!violation && !current->nsproxy->behavior_ns) {
 		memcpy(digest, entry->digest, sizeof(digest));
 		if (ima_lookup_digest_entry(digest, entry->pcr)) {
 			audit_cause = "hash_exists";
diff --git a/security/integrity/ima/ima_template.c b/security/integrity/ima/ima_template.c
index 6aa6408603e3..63c1f01ffc4e 100644
--- a/security/integrity/ima/ima_template.c
+++ b/security/integrity/ima/ima_template.c
@@ -24,6 +24,8 @@ static struct ima_template_desc builtin_templates[] = {
 	{.name = "ima-sig", .fmt = "d-ng|n-ng|sig"},
 	{.name = "ima-buf", .fmt = "d-ng|n-ng|buf"},
 	{.name = "ima-modsig", .fmt = "d-ng|n-ng|sig|d-modsig|modsig"},
+	{.name = "ima-identity",.fmt = "actor|subject",
+	 .genhash = ima_identity_genhash},
 	{.name = "", .fmt = ""},	/* placeholder for a custom format */
 };
 
@@ -47,6 +49,10 @@ static const struct ima_template_field supported_fields[] = {
 	 .field_show = ima_show_template_digest_ng},
 	{.field_id = "modsig", .field_init = ima_eventmodsig_init,
 	 .field_show = ima_show_template_sig},
+	{.field_id = "actor",.field_init = ima_event_actor_init,
+	 .field_show = ima_show_template_digest},
+	{.field_id = "subject",.field_init = ima_event_subject_init,
+	 .field_show = ima_show_template_digest}
 };
 
 /*
diff --git a/security/integrity/ima/ima_template_lib.c b/security/integrity/ima/ima_template_lib.c
index 32ae05d88257..192555f7aeea 100644
--- a/security/integrity/ima/ima_template_lib.c
+++ b/security/integrity/ima/ima_template_lib.c
@@ -468,3 +468,41 @@ int ima_eventmodsig_init(struct ima_event_data *event_data,
 	return ima_write_template_field_data(data, data_len, DATA_FMT_HEX,
 					     field_data);
 }
+
+/*
+ *  ima_event_actor_init - Generate identity of actor involved in event.
+ */
+int ima_event_actor_init(struct ima_event_data *event_data,
+			 struct ima_field_data *field_data)
+{
+	char actor[WP256_DIGEST_SIZE];
+	enum data_formats fmt = DATA_FMT_HEX;
+	int rc = 0;
+
+	rc = ima_get_actor(field_data, actor);
+	if (rc!=0)
+		return rc;
+
+	rc = ima_write_template_field_data(actor, sizeof(actor),
+					   fmt, field_data);
+	return rc;
+}
+
+/*
+ *  ima_event_subject_init - Generate identity of subject involved in event.
+ */
+int ima_event_subject_init(struct ima_event_data *event_data,
+			   struct ima_field_data *field_data)
+{
+	char subject[WP256_DIGEST_SIZE];
+	int rc = 0;
+	enum data_formats fmt = DATA_FMT_HEX;
+
+	rc = ima_get_subject(event_data, field_data, subject);
+	if (rc!=0)
+		return rc;
+
+	rc = ima_write_template_field_data(subject, sizeof(subject), fmt,
+					   field_data);
+	return rc;
+}
diff --git a/security/integrity/ima/ima_template_lib.h b/security/integrity/ima/ima_template_lib.h
index 9a88c79a7a61..bf57db56fab4 100644
--- a/security/integrity/ima/ima_template_lib.h
+++ b/security/integrity/ima/ima_template_lib.h
@@ -25,6 +25,8 @@ void ima_show_template_string(struct seq_file *m, enum ima_show_type show,
 			      struct ima_field_data *field_data);
 void ima_show_template_sig(struct seq_file *m, enum ima_show_type show,
 			   struct ima_field_data *field_data);
+void ima_show_hostid(struct seq_file *m, enum ima_show_type show,
+		     struct ima_field_data *field_data);
 void ima_show_template_buf(struct seq_file *m, enum ima_show_type show,
 			   struct ima_field_data *field_data);
 int ima_parse_buf(void *bufstartp, void *bufendp, void **bufcurp,
@@ -46,4 +48,12 @@ int ima_eventbuf_init(struct ima_event_data *event_data,
 		      struct ima_field_data *field_data);
 int ima_eventmodsig_init(struct ima_event_data *event_data,
 			 struct ima_field_data *field_data);
+int ima_event_actor_init(struct ima_event_data *event_data,
+			struct ima_field_data *field_data);
+int ima_event_subject_init(struct ima_event_data *event_data,
+			struct ima_field_data *field_data);
+int ima_hostid_init(struct integrity_iint_cache *iint, struct file *file,
+		    const unsigned char *filename,
+		    struct evm_ima_xattr_data *xattr_value, int xattr_len,
+		    struct ima_field_data *field_data);
 #endif /* __LINUX_IMA_TEMPLATE_LIB_H */
diff --git a/security/integrity/integrity.h b/security/integrity/integrity.h
index d9323d31a3a8..0e8ab7f2b34d 100644
--- a/security/integrity/integrity.h
+++ b/security/integrity/integrity.h
@@ -23,6 +23,7 @@
 #define IMA_AUDITED		0x00000080
 #define IMA_HASH		0x00000100
 #define IMA_HASHED		0x00000200
+#define IMA_MAP			0x00010000
 
 /* iint cache flags */
 #define IMA_ACTION_FLAGS	0xff000000
@@ -32,9 +33,10 @@
 #define EVM_IMMUTABLE_DIGSIG	0x08000000
 #define IMA_FAIL_UNVERIFIABLE_SIGS	0x10000000
 #define IMA_MODSIG_ALLOWED	0x20000000
+#define IMA_PSEUDONYM		0x40000000
 
 #define IMA_DO_MASK		(IMA_MEASURE | IMA_APPRAISE | IMA_AUDIT | \
-				 IMA_HASH | IMA_APPRAISE_SUBMASK)
+				 IMA_HASH | IMA_APPRAISE_SUBMASK | IMA_MAP)
 #define IMA_DONE_MASK		(IMA_MEASURED | IMA_APPRAISED | IMA_AUDITED | \
 				 IMA_HASHED | IMA_COLLECTED | \
 				 IMA_APPRAISED_SUBMASK)
diff --git a/security/security.c b/security/security.c
index 1bc000f834e2..590274ddd1d6 100644
--- a/security/security.c
+++ b/security/security.c
@@ -1128,6 +1128,7 @@ int security_inode_unlink(struct inode *dir, struct dentry *dentry)
 {
 	if (unlikely(IS_PRIVATE(d_backing_inode(dentry))))
 		return 0;
+	integrity_inode_free(dentry->d_inode);
 	return call_int_hook(inode_unlink, 0, dir, dentry);
 }
 
diff --git a/security/te/Kconfig b/security/te/Kconfig
new file mode 100644
index 000000000000..465d6e5e4db0
--- /dev/null
+++ b/security/te/Kconfig
@@ -0,0 +1,13 @@
+config SECURITY_EVENT
+	bool "Turing Event Inspection"
+	depends on SECURITY
+	depends on NET
+	depends on IMA
+	select SECURITYFS
+	default n
+	help
+	  This option selects support for Turing Event Inspection which
+	  implements the ability to inspect the actor and subject
+	  identity characters to determine if the event is to be
+	  allowed.
+	  If you are unsure how to answer this question, answer N.
diff --git a/security/te/Makefile b/security/te/Makefile
new file mode 100644
index 000000000000..f42c8795c769
--- /dev/null
+++ b/security/te/Makefile
@@ -0,0 +1,3 @@
+obj-$(CONFIG_SECURITY_EVENT) := te.o
+
+# te-y := te.o
diff --git a/security/te/te.c b/security/te/te.c
new file mode 100644
index 000000000000..f6ee2eef8cfe
--- /dev/null
+++ b/security/te/te.c
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2020 Enjellic Systems Development, LLC
+ *
+ * Authors:
+ * Dr. Greg Wettstein <greg@enjellic.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation, version 2 of the
+ * License.
+ */
+
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/socket.h>
+#include <linux/lsm_hooks.h>
+#include <linux/ima.h>
+
+
+/*
+ * The following defines the type of events that have been triggered.
+ * This enumeration must agree with the enumeration in the
+ * security/integrity/ima/ima_identity.c file.
+ */
+enum TEevent_type {
+	TE_file_open=0,
+	TE_socket_connect,
+	TE_socket_listen,
+	TE_undefined
+};
+
+
+/**
+ * te_file_open - Introspection hook to intercept file opens.
+ *
+ * @f:    Pointer to "struct file".
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+static int te_file_open(struct file *f)
+{
+	if ( !current->bad_actor )
+		return 0;
+
+	pr_info("%s: Bad actor=%s, subject=%s, flags=0x%x\n", __func__,
+		current->comm, f->f_path.dentry->d_name.name,
+		f->f_flags);
+
+	if ( ((f->f_flags & O_ACCMODE) == O_RDONLY) ||
+	     (f->f_flags & O_RDWR) )
+		pr_info("%s: Restricting read %s access to %s.\n",
+			__func__, current->comm,
+			f->f_path.dentry->d_name.name);
+
+	if ( f->f_flags & (O_CREAT | O_TRUNC | O_WRONLY | O_RDWR) )
+		pr_info("%s: Restricting write %s access to %s.\n",
+			__func__, current->comm,
+			f->f_path.dentry->d_name.name);
+
+	return ima_identity_process_ai(TE_file_open);
+}
+
+
+/**
+ * te_socket_connect - Introspection hook to intercept socket connections.
+ *
+ * @sock:	A pointer to the socket structure being used to
+ *	        implement the connection.
+ * @addr:	A pointer to the socket address that defines the
+ *		the endpoint being requested.
+ * @addr_len:	The length of the socket address.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+
+static int te_socket_connect(struct socket *sock, struct sockaddr *addr,
+			     int addr_len)
+
+{
+	if ( !current->bad_actor )
+		return 0;
+
+	pr_info("%s: Refused socket open, family=%u, length=%d, addr=%*phN\n", 
+		__func__, addr->sa_family, addr_len, addr_len, addr->sa_data);
+
+	return ima_identity_process_ai(TE_socket_connect);
+}
+
+
+/**
+ * te_socket_open - Introspection hook to intercept socket listen requests.
+ *
+ * @sock:	A pointer to the socket that will be listened on.
+ * @backlog:	The connection backlog depth that will be allowed.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+
+static int te_socket_listen(struct socket *sock, int backlog)
+
+{
+	if ( !current->bad_actor )
+		return 0;
+
+	pr_info("%s: Refused socket listen, backlog=%d\n", __func__, backlog);
+	return ima_identity_process_ai(TE_socket_listen);
+}
+
+
+/*
+ * The following array holds the introspection hooks which are
+ * implemented.
+ */
+static struct security_hook_list te_hooks[] __lsm_ro_after_init = {
+	LSM_HOOK_INIT(file_open, te_file_open),
+	LSM_HOOK_INIT(socket_connect, te_socket_connect),
+	LSM_HOOK_INIT(socket_listen, te_socket_listen)
+};
+
+
+/**
+ * ai_init - Register Autonomous Introspection as a security module.
+ */
+static int __init te_init(void)
+{
+	/* Register event inspection hooks. */
+	security_add_hooks(te_hooks, ARRAY_SIZE(te_hooks), "te");
+
+	printk(KERN_INFO "TE initialized.\n");
+	return 0;
+}
+
+__initcall(te_init);
-- 
2.31.1

