From 065f41a00b0ded3139e8755f97588eda170f7c58 Mon Sep 17 00:00:00 2001
From: "Dr. Greg" <greg@enjellic.com>
Date: Sun, 21 Feb 2021 17:27:13 -0600
Subject: [PATCH 33/50] Rationalize aggregate measurement handling.

Previously the addition of the hardware aggregate measurement was
added to an event namespace when the namespace was unshared.
This was problematic when tooling support was added to specify
that an external evaluator should be used.

The namespace manager could only configure the namespace for
external evaluation after the namespace was unshared.  By that
time the namespace copy code had injected the aggregate
measurement into whatever the default evaluation domain was when
the namespace was created.

For example if the root event namespace was using kernel based
evaluation the aggregate measurement would be added to the kernel
based domain even if the tooling had requested external
evaluation.

This was addressed by moving the implementation of aggregate
measurement handling into the ima_events_is_mapped() function.  A
boolean variable was added to the event namespace definition to
trace whether or not the aggregate measurement has been processed
for a namespace.  When the aggregate measurement is processed
this boolean is set to false so subsequent event processing will
skip the aggregate processing.

This was accomplished by largely moving the add_aggregate()
function upware to be a help function for the
ima_events_is_mapped() function.
---
 security/integrity/ima/ima_events.c | 136 ++++++++++++++--------------
 1 file changed, 66 insertions(+), 70 deletions(-)

diff --git a/security/integrity/ima/ima_events.c b/security/integrity/ima/ima_events.c
index f3844248d3d4..bdbdd2264199 100644
--- a/security/integrity/ima/ima_events.c
+++ b/security/integrity/ima/ima_events.c
@@ -172,6 +172,7 @@ struct event {
  */
 struct ima_events_map {
 	bool external;
+	bool emit_aggregate;
 
 	char base[WP256_DIGEST_SIZE];
 	char measurement[WP256_DIGEST_SIZE];
@@ -197,6 +198,7 @@ struct ima_events_map {
 
 	struct kobj_attribute update;
 } init_ima_events_map = {
+	.emit_aggregate = true,
 	.point_list_mutex = __MUTEX_INITIALIZER(init_ima_events_map.point_list_mutex),
 	.point_list = LIST_HEAD_INIT(init_ima_events_map.point_list),
 
@@ -1662,6 +1664,58 @@ static void ima_set_actor_status(int function, const char *pathname,
 	return;
 }
 
+static int add_aggregate(struct crypto_shash *tfm, struct ima_events_map *map)
+{
+	int retn = 0;
+	char host_measurement[WP256_DIGEST_SIZE];
+	struct event *mp;
+	SHASH_DESC_ON_STACK(shash, tfm);
+
+	/* Handle aggregate for an external evaluator. */
+	if (map->external) {
+		mp = kzalloc(sizeof(struct event), GFP_KERNEL);
+		if (!mp) {
+			retn = -ENOMEM;
+			goto done;
+		}
+
+		mp->type = aggregate_event;
+
+		mutex_lock(&map->measurement_mutex);
+		list_add_tail(&mp->list, &map->measurement_list);
+		mutex_unlock(&map->measurement_mutex);
+
+		sysfs_notify(ima_events_kobject, NULL, map->update.attr.name);
+		goto done;
+	}
+
+	/* Extend the aggregate measurement into a host domain. */
+	shash->tfm = tfm;
+	retn = crypto_shash_init(shash);
+	if (retn != 0)
+		goto done;
+	retn = crypto_shash_update(shash, map->base, WP256_DIGEST_SIZE);
+	if (retn != 0)
+		goto done;
+	retn = crypto_shash_finup(shash, aggregate, sizeof(aggregate),
+				  host_measurement);
+	if (retn != 0)
+		goto done;
+
+	/* Extend the measurement with the host aggregate measurement. */
+	retn = crypto_shash_init(shash);
+	if (retn != 0)
+		goto done;
+	retn = crypto_shash_update(shash, map->measurement, WP256_DIGEST_SIZE);
+	if (retn != 0)
+		goto done;
+	retn = crypto_shash_finup(shash, host_measurement,
+				  sizeof(host_measurement), map->measurement);
+
+ done:
+	return retn;
+}
+
 int ima_events_is_mapped(int function, struct integrity_iint_cache *iint,
 			 struct file *file, const char *pathname,
 			 struct ima_template_desc *template_desc,
@@ -1681,6 +1735,17 @@ int ima_events_is_mapped(int function, struct integrity_iint_cache *iint,
 			  &actor, &subject, mapping) != 0)
 		return 0;
 
+	if (map->emit_aggregate) {
+		map->emit_aggregate = false;
+
+		sha256 = crypto_alloc_shash("sha256", 0, 0);
+		if (IS_ERR(sha256))
+			return PTR_ERR(sha256);
+
+		retn = add_aggregate(sha256, map);
+		crypto_free_shash(sha256);
+	}
+
 	if (map->external) {
 		export_event(pathname, &actor, &subject);
 		return 0;
@@ -1908,64 +1973,6 @@ void ima_free_ns(struct kref *kref)
 	return;
 }
 
-static int add_aggregate(struct crypto_shash *tfm,
-			 struct ima_events_map *map)
-{
-	int retn = 0;
-	char host_measurement[WP256_DIGEST_SIZE];
-	SHASH_DESC_ON_STACK(shash, tfm);
-	struct event *mp;
-
-	shash->tfm = tfm;
-
-	/* Extend the aggregate measurement into a host domain. */
-	retn = crypto_shash_init(shash);
-	if (retn != 0)
-		goto done;
-	retn = crypto_shash_update(shash, map->base, WP256_DIGEST_SIZE);
-	if (retn != 0)
-		goto done;
-	retn = crypto_shash_finup(shash, aggregate, sizeof(aggregate),
-				  host_measurement);
-	if (retn != 0)
-		goto done;
-
-
-	/* Extend the measurement with the host aggregate measurement. */
-	retn = crypto_shash_init(shash);
-	if (retn != 0)
-		goto done;
-	retn = crypto_shash_update(shash, map->measurement, WP256_DIGEST_SIZE);
-	if (retn != 0)
-		goto done;
-	retn = crypto_shash_finup(shash, host_measurement,
-				  sizeof(host_measurement), map->measurement);
-	if (retn != 0)
-		goto done;
-
-
-	/* Add the aggregate entry. */
-	if (!map->external)
-		goto done;
-
-	mp = kzalloc(sizeof(struct event), GFP_KERNEL);
-	if (!mp) {
-		retn = -ENOMEM;
-		goto done;
-	}
-
-	mp->type = aggregate_event;
-
-	mutex_lock(&map->measurement_mutex);
-	list_add_tail(&mp->list, &map->measurement_list);
-	mutex_unlock(&map->measurement_mutex);
-
-	sysfs_notify(ima_events_kobject, NULL, map->update.attr.name);
-
- done:
-	return retn;
-}
-
 struct ima_events_namespace *ima_copy_events_ns(unsigned long flags,
 				    struct user_namespace *user_ns,
 				    struct ima_events_namespace *events_ns)
@@ -1974,7 +1981,6 @@ struct ima_events_namespace *ima_copy_events_ns(unsigned long flags,
 	char bufr[7 + 10 + 1];
 	int retn = 0;
 	struct ima_events_namespace *ns;
-	struct crypto_shash *tfm = NULL;
 
 	pr_debug("[%s]: New ns = %s\n", __func__,
 		 flags & CLONE_EVENTS ? "yes" : "no");
@@ -2024,6 +2030,7 @@ struct ima_events_namespace *ima_copy_events_ns(unsigned long flags,
 		memcpy(ns->map->base, events_ns->map->base, WP256_DIGEST_SIZE);
 	}
 	else {
+		ns->map->emit_aggregate = true;
 		ns->map->external = init_ima_events_ns.map->external;
 		memcpy(ns->map->base, init_ima_events_ns.map->base,
 		       WP256_DIGEST_SIZE);
@@ -2044,17 +2051,6 @@ struct ima_events_namespace *ima_copy_events_ns(unsigned long flags,
 	ns->map->update.attr.mode = 0400;
 	ns->map->update.show = show_ns_update;
 	retn = sysfs_create_file(ima_events_kobject, &ns->map->update.attr);
-	if(retn)
-		goto done;
-
-	tfm = crypto_alloc_shash("sha256", 0, 0);
-	if (IS_ERR(tfm)) {
-		retn = PTR_ERR(tfm);
-		goto done;
-	}
-
-	retn = add_aggregate(tfm, ns->map);
-	crypto_free_shash(tfm);
 
  done:
 	if (retn) {
-- 
2.31.1

