From 3d85cc8e905d7632b502589a0c869de42ed532d1 Mon Sep 17 00:00:00 2001
From: "Dr. Greg Wettstein" <gw@idfusion.org>
Date: Fri, 30 Dec 2016 12:18:30 -0600
Subject: [PATCH 04/24] Add iso-identity implementation framework.

The implementation of the iso-identity policy is primarily
encapsulated in the security/integrity/ima/ima_identity.c source
file.  This update commits the file along with the necessary
support framework in order to implement a functional compile of
the kernel.
---
 security/integrity/ima/Makefile       |   2 +-
 security/integrity/ima/ima.h          |  16 +
 security/integrity/ima/ima_api.c      |  33 +-
 security/integrity/ima/ima_fs.c       |  10 +
 security/integrity/ima/ima_identity.c | 981 ++++++++++++++++++++++++++++++++++
 security/integrity/ima/ima_init.c     |   6 +-
 6 files changed, 1036 insertions(+), 12 deletions(-)
 create mode 100644 security/integrity/ima/ima_identity.c

diff --git a/security/integrity/ima/Makefile b/security/integrity/ima/Makefile
index d79263d2fdbf..0d77452c928c 100644
--- a/security/integrity/ima/Makefile
+++ b/security/integrity/ima/Makefile
@@ -6,5 +6,5 @@
 obj-$(CONFIG_IMA) += ima.o
 
 ima-y := ima_fs.o ima_queue.o ima_init.o ima_main.o ima_crypto.o ima_api.o \
-	 ima_policy.o ima_template.o ima_template_lib.o
+	 ima_policy.o ima_template.o ima_template_lib.o ima_identity.o
 ima-$(CONFIG_IMA_APPRAISE) += ima_appraise.o
diff --git a/security/integrity/ima/ima.h b/security/integrity/ima/ima.h
index e2a60c30df44..1659b8e3a38d 100644
--- a/security/integrity/ima/ima.h
+++ b/security/integrity/ima/ima.h
@@ -68,6 +68,11 @@ struct ima_field_data {
 	u32 len;
 };
 
+/* Host identity, defined in ima_identity.c */
+extern char *hostid;
+
+struct ima_template_entry;
+
 /* IMA template field definition */
 struct ima_template_field {
 	const char field_id[IMA_TEMPLATE_FIELD_ID_MAX_LEN];
@@ -82,6 +87,7 @@ struct ima_template_desc {
 	char *name;
 	char *fmt;
 	int num_fields;
+	int (*genhash)(struct ima_template_entry *, char *);
 	struct ima_template_field **fields;
 };
 
@@ -118,6 +124,15 @@ void ima_putc(struct seq_file *m, void *data, int datalen);
 void ima_print_digest(struct seq_file *m, u8 *digest, u32 size);
 struct ima_template_desc *ima_template_desc_current(void);
 int ima_init_template(void);
+int ima_identity_init(void);
+int ima_identity_genhash(struct ima_template_entry *, char *);
+int ima_get_actor(char *);
+int ima_map_identity(int, struct integrity_iint_cache *iint,
+		     struct file *file, const char *pathname, char *mapping);
+int ima_identity_is_mapped(int, struct integrity_iint_cache *iint,
+			   struct file *file, const char *pathname);
+int ima_fs_init(void);
+struct dentry *ima_fs_init_identity(void);
 
 /*
  * used to protect h_table and sha_table
@@ -139,6 +154,7 @@ static inline unsigned long ima_hash_key(u8 *digest)
 /* LIM API function definitions */
 int ima_get_action(struct inode *inode, int mask, int function);
 int ima_must_measure(struct inode *inode, int mask, int function);
+int ima_must_map(struct inode *inode, int mask, int function);
 int ima_collect_measurement(struct integrity_iint_cache *iint,
 			    struct file *file,
 			    struct evm_ima_xattr_data **xattr_value,
diff --git a/security/integrity/ima/ima_api.c b/security/integrity/ima/ima_api.c
index 1d950fbb2aec..5a2108293647 100644
--- a/security/integrity/ima/ima_api.c
+++ b/security/integrity/ima/ima_api.c
@@ -99,21 +99,29 @@ int ima_store_template(struct ima_template_entry *entry,
 	} hash;
 
 	if (!violation) {
-		int num_fields = entry->template_desc->num_fields;
-
-		/* this function uses default algo */
-		hash.hdr.algo = HASH_ALGO_SHA1;
-		result = ima_calc_field_array_hash(&entry->template_data[0],
-						   entry->template_desc,
-						   num_fields, &hash.hdr);
+		if (entry->template_desc->genhash != NULL) {
+			result = entry->template_desc->genhash(entry,
+							       hash.hdr.digest);
+		}
+		else {
+			int num_fields = entry->template_desc->num_fields;
+
+			/* this function uses default algo */
+			hash.hdr.algo = HASH_ALGO_SHA1;
+			result = ima_calc_field_array_hash(&entry->template_data[0],
+							   entry->template_desc,
+							   num_fields,
+							   &hash.hdr);
+		}
 		if (result < 0) {
 			integrity_audit_msg(AUDIT_INTEGRITY_PCR, inode,
 					    template_name, op,
 					    audit_cause, result, 0);
 			return result;
 		}
-		memcpy(entry->digest, hash.hdr.digest, hash.hdr.length);
+		memcpy(entry->digest, hash.hdr.digest, TPM_DIGEST_SIZE);
 	}
+
 	result = ima_add_template_entry(entry, violation, op, inode, filename);
 	return result;
 }
@@ -170,13 +178,18 @@ err_out:
  */
 int ima_get_action(struct inode *inode, int mask, int function)
 {
-	int flags = IMA_MEASURE | IMA_AUDIT | IMA_APPRAISE;
+	int flags = IMA_MEASURE | IMA_AUDIT | IMA_APPRAISE | IMA_MAP;
 
 	flags &= ima_policy_flag;
 
 	return ima_match_policy(inode, function, mask, flags);
 }
 
+int ima_must_map(struct inode *inode, int mask, int function)
+{
+	return ima_match_policy(inode, function, mask, IMA_MAP);
+}
+
 /*
  * ima_collect_measurement - collect file measurement
  *
@@ -270,7 +283,7 @@ void ima_store_measurement(struct integrity_iint_cache *iint,
 					    xattr_len, NULL};
 	int violation = 0;
 
-	if (iint->flags & IMA_MEASURED)
+	if (!(iint->flags & IMA_MAP) && (iint->flags & IMA_MEASURED))
 		return;
 
 	result = ima_alloc_init_template(&event_data, &entry);
diff --git a/security/integrity/ima/ima_fs.c b/security/integrity/ima/ima_fs.c
index 816d175da79a..9434010cc222 100644
--- a/security/integrity/ima/ima_fs.c
+++ b/security/integrity/ima/ima_fs.c
@@ -349,6 +349,16 @@ static const struct file_operations ima_measure_policy_ops = {
 	.llseek = generic_file_llseek,
 };
 
+struct dentry * __init ima_fs_init_identity(void)
+{
+	struct dentry *id_dir = NULL;
+
+	id_dir = securityfs_create_dir("iso-identity", ima_dir);
+	if (IS_ERR(id_dir))
+		return NULL;
+	return id_dir;
+}
+
 int __init ima_fs_init(void)
 {
 	ima_dir = securityfs_create_dir("ima", NULL);
diff --git a/security/integrity/ima/ima_identity.c b/security/integrity/ima/ima_identity.c
new file mode 100644
index 000000000000..3058ec01e441
--- /dev/null
+++ b/security/integrity/ima/ima_identity.c
@@ -0,0 +1,981 @@
+/*
+ * Copyright (C) 2015 IDfusion, LLC
+ *
+ * Authors:
+ * Dr. Greg Wettstein <gw@idfusion.org>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation, version 2 of the
+ * License.
+ *
+ * File: ima_identity.c
+ *	Implements generation of a process identity.
+ *	Implements maintenance of the iso-identity measurement list.
+ */
+#include <linux/namei.h>
+#include <linux/seq_file.h>
+#include <crypto/hash.h>
+#include <crypto/hash_info.h>
+
+#include "ima.h"
+
+/* Structure defining actor identity elements. */
+struct identity_elements {
+	uid_t uid;
+	uid_t euid;
+	uid_t suid;
+
+	gid_t gid;
+	gid_t egid;
+	gid_t sgid;
+
+	uid_t fsuid;
+	gid_t fsgid;
+
+	union {
+		kernel_cap_t mask;
+		u64 value;
+	} capability;
+} __packed;
+
+/*
+ * Root dentry for the 'iso-identity' directory and dentries for the
+ * pseudo-files in that directory.
+ */
+static struct dentry *identity_dir;
+static struct dentry *contours;
+static struct dentry *map;
+static struct dentry *pseudonym;
+static struct dentry *host_identity;
+static struct dentry *sealed;
+static struct dentry *forensics;
+static struct dentry *measurement_file;
+
+/* Identity of host. */
+static char host_id[WP256_DIGEST_SIZE];
+char *hostid = host_id;
+
+/*
+ * Variables for managing and providing forensic information on the
+ * sealed dimensionality of the system measurement state.
+ */
+static bool domain_sealed;
+
+static unsigned int forensics_count;
+static unsigned int max_forensics_count = 5;
+
+struct forensic_event {
+	struct list_head list;
+	int function;
+	char *process;
+	char *pathname;
+	struct identity_elements identity;
+};
+
+static DEFINE_MUTEX(forensic_event_list_mutex);
+static LIST_HEAD(forensic_event_list);
+
+/*
+ * Definitions, locks and variables for the linked lists implementing
+ * the iso-identity contour points.
+ */
+struct contour {
+	struct list_head list;
+	char identity[WP256_DIGEST_SIZE];
+};
+
+static DEFINE_MUTEX(contour_list_mutex);
+static LIST_HEAD(contour_list);
+static unsigned int contour_count;
+
+/* Iso-identity measurement value. */
+static char measurement[WP256_DIGEST_SIZE];
+
+static atomic_t map_opencount = ATOMIC_INIT(1);
+
+
+/**
+ *	get_identity - Obtain user identity factors.
+ *	*id: A pointer to the user identity structure to be populated.
+ *
+ *	This function populates the provided structure with the
+ *	elements used to define an actor's identity state.
+ */
+
+static void get_identity(struct identity_elements *id)
+
+{
+	kernel_cap_t eff, per, inh;
+
+	id->uid = from_kuid(&init_user_ns, current_uid());
+	id->euid = from_kuid(&init_user_ns, current_euid());
+	id->suid = from_kuid(&init_user_ns, current_suid());
+
+	id->gid = from_kgid(&init_user_ns, current_gid());
+	id->egid = from_kgid(&init_user_ns, current_egid());
+	id->sgid = from_kgid(&init_user_ns, current_sgid());
+
+	id->fsuid = from_kuid(&init_user_ns, current_fsuid());
+	id->fsgid = from_kgid(&init_user_ns, current_fsgid());
+
+	if (security_capget(current, &eff, &inh, &per) != 0 ) {
+		eff = CAP_FULL_SET;
+		per = CAP_FULL_SET;
+	}
+	id->capability.mask = cap_combine(eff, per);
+
+	return;
+}
+
+/**
+ *	have_contour - Search contour list for a given point.
+ *	@point: buffer containing the contour point to search for.
+ *
+ *	Search the current contour list attempting to find the
+ *	point specified by the caller.  Return true if the point
+ *	is located.
+ */
+
+static int have_contour(char *point)
+{
+	int retn = 0;
+	struct contour *entry;
+
+	mutex_lock(&contour_list_mutex);
+	list_for_each_entry(entry, &contour_list, list) {
+		if (memcmp(entry->identity, point, WP256_DIGEST_SIZE) == 0) {
+			retn = 1;
+			goto done;
+		}
+	}
+
+ done:
+	mutex_unlock(&contour_list_mutex);
+	return retn;
+}
+
+/**
+ *	add_countour_point - Add a point to the contour list.
+ *	@point: buffer containing the contour point to add..
+ *
+ *	Returns a non-zero value on a failure to add a point.
+ */
+
+static int add_contour_point(char *point)
+{
+	int retn = 1;
+	struct contour *entry;
+
+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
+	if (!entry)
+		goto done;
+
+	mutex_lock(&contour_list_mutex);
+	memcpy(entry->identity, point, WP256_DIGEST_SIZE);
+	list_add_tail(&entry->list, &contour_list);
+	++contour_count;
+	mutex_unlock(&contour_list_mutex);
+	retn = 0;
+
+ done:
+	return retn;
+}
+
+static void *ima_contours_start(struct seq_file *c, loff_t *pos)
+{
+	if (*pos >= contour_count)
+		return NULL;
+
+	mutex_lock(&contour_list_mutex);
+	return seq_list_start(&contour_list, *pos);
+}
+
+static void *ima_contours_next(struct seq_file *c, void *p, loff_t *pos)
+{
+	return seq_list_next(p, &contour_list, pos);
+}
+
+static void ima_contours_stop(struct seq_file *c, void *pos)
+{
+	mutex_unlock(&contour_list_mutex);
+}
+
+static int ima_contours_show(struct seq_file *c, void *identity)
+{
+	struct contour *id;
+
+	id = list_entry(identity, struct contour, list);
+	seq_printf(c, "%*phN\n", WP256_DIGEST_SIZE, id->identity);
+	return 0;
+}
+
+static const struct seq_operations ima_contours_seqops = {
+	.start = ima_contours_start,
+	.next = ima_contours_next,
+	.stop = ima_contours_stop,
+	.show = ima_contours_show
+};
+
+static int ima_contours_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &ima_contours_seqops);
+}
+
+static const struct file_operations ima_contours_ops = {
+	.open = ima_contours_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = seq_release,
+};
+
+static int ima_open_map(struct inode * inode, struct file * filp)
+{
+	if (!(filp->f_flags & O_WRONLY))
+		return -EACCES;
+	if (atomic_dec_and_test(&map_opencount))
+		return 0;
+	return -EBUSY;
+}
+
+static ssize_t ima_write_map(struct file *file, const char __user *buf,
+			     size_t datalen, loff_t *ppos)
+{
+	char *p, idbufr[WP256_DIGEST_SIZE*2 + 1], mapping[WP256_DIGEST_SIZE];
+	ssize_t retn;
+
+	if (datalen != sizeof(idbufr)) {
+		retn = -EINVAL;
+		goto done;
+	}
+
+	if (*ppos != 0) {
+		retn = -EINVAL;
+		goto done;
+	}
+
+	memset(idbufr, '\0', sizeof(idbufr));
+	if (copy_from_user(idbufr, buf, datalen)) {
+		retn = -EFAULT;
+		goto done;
+	}
+
+	p = strchr(idbufr, '\n');
+	if (!p) {
+		retn = -EINVAL;
+		goto done;
+	}
+	*p = '\0';
+	if (hex2bin(mapping, idbufr, sizeof(mapping))) {
+		retn = -EINVAL;
+		goto done;
+	}
+
+	if (have_contour(mapping)) {
+		retn = datalen;
+		goto done;
+	}
+	if (add_contour_point(mapping)) {
+		retn = -ENOMEM;
+		goto done;
+	}
+	retn = datalen;
+
+done:
+	return retn;
+}
+
+static int ima_release_map(struct inode *inode, struct file *file)
+{
+	atomic_set(&map_opencount, 1);
+	return 0;
+}
+
+static const struct file_operations ima_map_ops = {
+	.open = ima_open_map,
+	.write = ima_write_map,
+	.release = ima_release_map,
+	.llseek = generic_file_llseek,
+};
+
+static int ima_open_pseudonym(struct inode * inode, struct file * filp)
+{
+	if (!(filp->f_flags & O_WRONLY))
+		return -EACCES;
+	return 0;
+}
+
+static ssize_t ima_write_pseudonym(struct file *file, const char __user *buf,
+				   size_t datalen, loff_t *ppos)
+{
+	size_t amt;
+	char *p, bufr[PATH_MAX];
+	ssize_t retn;
+	struct inode *inode;
+	struct path path;
+	struct integrity_iint_cache *iint;
+
+	if (datalen > sizeof(bufr)) {
+		retn = -EINVAL;
+		goto done;
+	}
+
+	if (*ppos != 0) {
+		retn = -EINVAL;
+		goto done;
+	}
+
+	memset(bufr, '\0', sizeof(bufr));
+	if (copy_from_user(bufr, buf, datalen)) {
+		retn = -EFAULT;
+		goto done;
+	}
+
+	p = strchr(bufr, '\n');
+	if (!p) {
+		retn = -EINVAL;
+		goto done;
+	}
+	*p = '\0';
+
+	retn = kern_path(bufr, LOOKUP_FOLLOW, &path);
+	if (retn)
+		goto done;
+	inode = path.dentry->d_inode;
+
+	mutex_lock(&inode->i_mutex);
+	iint = integrity_inode_get(inode);
+	mutex_unlock(&inode->i_mutex);
+	if (!iint) {
+		retn = -ENOENT;
+		goto done;
+	}
+	pr_info("[%s]: Mapped pseudonym for %s, iint=%p, inum=%ld\n",
+		__func__, bufr, iint, inode->i_ino);
+	iint->flags |= (IMA_PSEUDONYM | IMA_COLLECTED);
+	iint->version = inode->i_version;
+
+	amt = sizeof(struct ima_digest_data) + WP256_DIGEST_SIZE;
+	iint->ima_hash = kzalloc(amt, GFP_KERNEL);
+	if (iint->ima_hash == NULL) {
+		retn = -ENOMEM;
+		goto done;
+	}
+	iint->ima_hash->algo = HASH_ALGO_SHA256;
+	iint->ima_hash->length = WP256_DIGEST_SIZE;
+
+	retn = datalen;
+
+done:
+	return retn;
+}
+
+static int ima_release_pseudonym(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static const struct file_operations ima_pseudonym_ops = {
+	.open = ima_open_pseudonym,
+	.write = ima_write_pseudonym,
+	.release = ima_release_pseudonym,
+	.llseek = generic_file_llseek,
+};
+
+static int ima_open_host_identity(struct inode * inode, struct file * filp)
+{
+	if (!(filp->f_flags & O_WRONLY))
+		return -EACCES;
+	return 0;
+}
+
+static ssize_t ima_write_host_identity(struct file *file,
+				       const char __user *buf, size_t datalen,
+				       loff_t *ppos)
+{
+	char *p, id[WP256_DIGEST_SIZE*2 + 1];
+	ssize_t retn;
+
+	if (datalen != sizeof(id)) {
+		retn = -EINVAL;
+		goto done;
+	}
+
+	if (*ppos != 0) {
+		retn = -EINVAL;
+		goto done;
+	}
+
+	if (copy_from_user(id, buf, datalen)) {
+		retn = -EFAULT;
+		goto done;
+	}
+
+	p = strchr(id, '\n');
+	if (!p) {
+		retn = -EINVAL;
+		goto done;
+	}
+	*p = '\0';
+
+	hostid = kzalloc(WP256_DIGEST_SIZE, GFP_KERNEL);
+	if (hostid == NULL) {
+		retn = -ENOMEM;
+		goto done;
+	}
+	if (hex2bin(hostid, id, WP256_DIGEST_SIZE)) {
+		retn = -EINVAL;
+		goto done;
+	}
+	pr_info("[%s]: Setting host identity to %*phN\n", __func__,
+		(int) WP256_DIGEST_SIZE, hostid);
+	retn = datalen;
+
+done:
+	return retn;
+}
+
+static int ima_release_host_identity(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static const struct file_operations ima_host_identity_ops = {
+	.open = ima_open_host_identity,
+	.write = ima_write_host_identity,
+	.release = ima_release_host_identity,
+	.llseek = generic_file_llseek,
+};
+
+static int ima_open_sealed(struct inode * inode, struct file * filp)
+{
+	if (!(filp->f_flags & O_WRONLY))
+		return -EACCES;
+	return 0;
+}
+
+static ssize_t ima_write_sealed(struct file *file,
+				const char __user *buf, size_t datalen,
+				loff_t *ppos)
+{
+	char sealed[2];
+	ssize_t retn;
+
+	if (datalen != 2) {
+		retn = -EINVAL;
+		goto done;
+	}
+
+	if (*ppos != 0) {
+		retn = -EINVAL;
+		goto done;
+	}
+
+	if (copy_from_user(sealed, buf, sizeof(sealed))) {
+		retn = -EFAULT;
+		goto done;
+	}
+
+	if (sealed[1] != '\n') {
+		retn = -EINVAL;
+		goto done;
+	}
+	if (sealed[0] != '1') {
+		retn = -EINVAL;
+		goto done;
+	}
+	domain_sealed = true;
+	pr_info("[%s]: Sealed identity domain.\n", __func__);
+	retn = datalen;
+
+done:
+	return retn;
+}
+
+static int ima_release_sealed(struct inode *inode, struct file *file)
+{
+	if (domain_sealed) {
+		securityfs_remove(contours);
+		securityfs_remove(map);
+		securityfs_remove(pseudonym);
+		securityfs_remove(host_identity);
+	}
+	return 0;
+}
+
+static const struct file_operations ima_sealed_ops = {
+	.open = ima_open_sealed,
+	.write = ima_write_sealed,
+	.release = ima_release_sealed,
+	.llseek = generic_file_llseek,
+};
+
+static void *ima_forensics_start(struct seq_file *c, loff_t *pos)
+{
+	if (*pos >= forensics_count)
+		return NULL;
+
+	mutex_lock(&forensic_event_list_mutex);
+	return seq_list_start(&forensic_event_list, *pos);
+}
+
+static void *ima_forensics_next(struct seq_file *c, void *p, loff_t *pos)
+{
+	return seq_list_next(p, &forensic_event_list, pos);
+}
+
+static void ima_forensics_stop(struct seq_file *c, void *pos)
+{
+	mutex_unlock(&forensic_event_list_mutex);
+}
+
+static int ima_forensics_show(struct seq_file *c, void *event)
+{
+	struct forensic_event *p;
+
+	p= list_entry(event, struct forensic_event, list);
+
+	seq_printf(c, "function: %d\n", p->function);
+	seq_printf(c, "process: %s\n", p->process);
+	seq_printf(c, "pathname: %s\n", p->pathname);
+	seq_printf(c, "uid: %d\n", p->identity.uid);
+	seq_printf(c, "euid: %d\n", p->identity.euid);
+	seq_printf(c, "suid: %d\n", p->identity.suid);
+
+	seq_printf(c, "gid: %d\n", p->identity.gid);
+	seq_printf(c, "egid: %d\n", p->identity.egid);
+	seq_printf(c, "sgid: %d\n", p->identity.sgid);
+
+	seq_printf(c, "fsuid: %d\n", p->identity.fsuid);
+	seq_printf(c, "fsgid: %d\n", p->identity.fsgid);
+
+	seq_printf(c, "capabilities: 0x%llx\n\n",
+		   p->identity.capability.value);
+
+	return 0;
+}
+
+static const struct seq_operations ima_forensics_seqops = {
+	.start = ima_forensics_start,
+	.next = ima_forensics_next,
+	.stop = ima_forensics_stop,
+	.show = ima_forensics_show
+};
+
+static int ima_forensics_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &ima_forensics_seqops);
+}
+
+static const struct file_operations ima_forensics_ops = {
+	.open = ima_forensics_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = seq_release,
+};
+
+static void *ima_measurement_start(struct seq_file *c, loff_t *pos)
+{
+	if (*pos > 0)
+		return NULL;
+
+	return measurement;
+}
+
+static void *ima_measurement_next(struct seq_file *c, void *p, loff_t *pos)
+{
+	return NULL;
+}
+
+static void ima_measurement_stop(struct seq_file *c, void *pos)
+{
+	return;
+}
+
+static int ima_measurement_show(struct seq_file *c, void *event)
+{
+	seq_printf(c, "%*phN\n", (int) sizeof(measurement), measurement);
+	return 0;
+}
+
+static const struct seq_operations ima_measurement_seqops = {
+	.start = ima_measurement_start,
+	.next = ima_measurement_next,
+	.stop = ima_measurement_stop,
+	.show = ima_measurement_show
+};
+
+static int ima_measurement_open(struct inode *inode, struct file *file)
+{
+	return seq_open(file, &ima_measurement_seqops);
+}
+
+static const struct file_operations ima_measurement_ops = {
+	.open = ima_measurement_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = seq_release,
+};
+
+static int have_violation(struct file *file, struct integrity_iint_cache *iint,
+			  const char *pathname)
+{
+	bool tomtou = false, writers = false;
+	struct inode *inode = file_inode(file);
+
+	/* Check for possible violation conditions. */
+	if (file->f_mode & FMODE_WRITE) {
+		if (atomic_read(&inode->i_readcount) && IS_IMA(inode))
+			tomtou = true;
+	}
+	if (ima_must_map(inode, MAY_READ, FILE_CHECK) &&
+	    (atomic_read(&inode->i_writecount) > 0))
+		writers = true;
+
+	if (iint->flags & IMA_PSEUDONYM) {
+		if (tomtou)
+			pr_info("[%s]: Pseudonym inhibited TOMTOU violation\n",
+				__func__);
+		if (writers)
+			pr_info("[%s]: Pseudonym inibited writers violation\n",
+				__func__);
+		return 0;
+	}
+
+	if (tomtou || writers) {
+		if (tomtou)
+			ima_add_violation(file, pathname, iint, "invalid_pcr",
+					  "ToMToU");
+		if (writers)
+			ima_add_violation(file, pathname, iint, "invalid_pcr",
+					  "open_writers");
+	}
+
+	return tomtou || writers;
+}
+
+
+static int get_host_measurement(struct crypto_shash *tfm, char *id,
+				size_t idlength, char *digest)
+{
+	int retn;
+	struct {
+		struct shash_desc shash;
+		char ctx[crypto_shash_descsize(tfm)];
+	} desc;
+
+	desc.shash.tfm = tfm;
+	desc.shash.flags = 0;
+	retn = crypto_shash_init(&desc.shash);
+	if (retn != 0)
+		goto done;
+	retn = crypto_shash_update(&desc.shash, hostid, WP256_DIGEST_SIZE);
+	if (retn != 0)
+		goto done;
+	retn = crypto_shash_finup(&desc.shash, id, idlength, digest);
+	if (retn != 0)
+		goto done;
+
+ done:
+	return retn;
+}
+
+static int update_identity_state(struct crypto_shash *tfm, char *id)
+{
+	int retn;
+	char digest[crypto_shash_digestsize(tfm)];
+	struct {
+		struct shash_desc shash;
+		char ctx[crypto_shash_descsize(tfm)];
+	} desc;
+
+	retn = get_host_measurement(tfm, id, WP256_DIGEST_SIZE, digest);
+	if (retn != 0)
+		goto done;
+
+	/* Extend soft state measurement. */
+	desc.shash.tfm = tfm;
+	desc.shash.flags = 0;
+	retn = crypto_shash_init(&desc.shash);
+	if (retn != 0)
+		goto done;
+	retn = crypto_shash_update(&desc.shash, measurement,
+				   WP256_DIGEST_SIZE);
+	if (retn != 0)
+		goto done;
+	retn = crypto_shash_finup(&desc.shash, digest, sizeof(digest),
+				  measurement);
+	if (retn != 0)
+		goto done;
+
+ done:
+	return retn;
+}
+
+int ima_identity_genhash(struct ima_template_entry *entry, char *tpm_digest)
+{
+	int retn;
+	struct {
+		struct ima_digest_data hdr;
+		char digest[WP256_DIGEST_SIZE];
+	} identity;
+	struct crypto_shash *tfm = NULL;
+
+	/* Construct identity. */
+	identity.hdr.algo = HASH_ALGO_SHA256;
+	retn = ima_calc_field_array_hash(&entry->template_data[0],
+					 entry->template_desc,
+					 entry->template_desc->num_fields,
+					 &identity.hdr);
+	if (retn != 0)
+		goto done;
+
+	/* Extend current identity measurement state. */
+	tfm = crypto_alloc_shash("sha256", 0, 0);
+	if (IS_ERR(tfm)) {
+		retn = PTR_ERR(tfm);
+		goto done;
+	}
+	retn = update_identity_state(tfm, identity.hdr.digest);
+	if (retn != 0)
+		goto done;
+	crypto_free_shash(tfm);
+
+	/* Generate a hash suitable for extending TPM 1.x. */
+	tfm = crypto_alloc_shash("sha1", 0, 0);
+	if (IS_ERR(tfm))
+		return PTR_ERR(tfm);
+	retn = get_host_measurement(tfm, identity.hdr.digest,
+				    WP256_DIGEST_SIZE, tpm_digest);
+	if (retn != 0)
+		goto done;
+	retn = 0;
+
+ done:
+	crypto_free_shash(tfm);
+	return retn;
+}
+
+static int ima_get_actor_identity(struct crypto_shash *tfm, char *mapping)
+{
+	int retn = 0;
+	struct {
+		struct shash_desc shash;
+		char ctx[crypto_shash_descsize(tfm)];
+	} desc;
+	struct identity_elements identity;
+
+	desc.shash.tfm = tfm;
+	desc.shash.flags = 0;
+	retn = crypto_shash_init(&desc.shash);
+	if (retn != 0)
+		goto done;
+
+	get_identity(&identity);
+	retn = crypto_shash_finup(&desc.shash, (char *) &identity,
+				  sizeof(identity), mapping);
+#if 0
+	pr_info("IMA[%s]: comm=%s, pid=%d, [ue]id=%d/%d, caps=%llx\n",
+		__func__, current->comm, current->pid, identity.uid,
+		identity.euid, identity.capability.value);
+#endif
+
+ done:
+	return retn;
+}
+
+int ima_get_actor(char *actor)
+{
+	int retn;
+	struct crypto_shash *tfm;
+
+	tfm = crypto_alloc_shash("sha256", 0, 0);
+	if (IS_ERR(tfm))
+		return PTR_ERR(tfm);
+
+	retn = ima_get_actor_identity(tfm, actor);
+	crypto_free_shash(tfm);
+	return retn;
+}
+
+int ima_map_identity(int function, struct integrity_iint_cache *iint,
+		     struct file *file, const char *pathname, char *mapping)
+{
+	int retn, num_fields;
+	struct ima_template_entry *entry;
+	struct {
+		struct ima_digest_data hdr;
+		char digest[WP256_DIGEST_SIZE];
+	} hash;
+	struct ima_event_data event_data = {
+		iint,
+		file,
+		pathname,
+		NULL,
+		0,
+		NULL
+	};
+
+
+	retn = ima_alloc_init_template(&event_data, &entry);
+	if (retn != 0 )
+		goto done;
+
+	num_fields = entry->template_desc->num_fields;
+	hash.hdr.algo = HASH_ALGO_SHA256;
+	retn = ima_calc_field_array_hash(&entry->template_data[0],
+					 entry->template_desc,
+					 num_fields, &hash.hdr);
+	memcpy(mapping, hash.digest, sizeof(hash.digest));
+
+	ima_free_template_entry(entry);
+	retn = ima_alloc_init_template(&event_data, &entry);
+	if (retn != 0 )
+		goto done;
+	ima_free_template_entry(entry);
+	retn = 0;
+
+ done:
+	return retn;
+}
+
+static int register_forensic_violation(int function,
+				       struct integrity_iint_cache *iint,
+				       struct file *file,
+				       const char *pathname)
+{
+	struct forensic_event *event;
+
+	if (forensics_count == max_forensics_count)
+		return 1;
+
+	event = kzalloc(sizeof(*event), GFP_KERNEL);
+	if (event == NULL )
+		return 0;
+
+	event->function = function;
+	get_identity(&event->identity);
+
+	event->process = kmalloc(strlen(current->comm) + 1, GFP_KERNEL);
+	if (event->process == NULL)
+		return 0;
+	strcpy(event->process, current->comm);
+
+	event->pathname = kmalloc(strlen(pathname) + 1, GFP_KERNEL);
+	if (event->pathname == NULL)
+		return 0;
+	strcpy(event->pathname, pathname);
+
+	mutex_lock(&forensic_event_list_mutex);
+	list_add_tail(&event->list, &forensic_event_list);
+	++forensics_count;
+	mutex_unlock(&forensic_event_list_mutex);
+
+	pr_info("[%s]: Registered forensic violation for path=%s, inode=%ld\n",
+			__func__, pathname, iint->inode->i_ino);
+	return 0;
+}
+
+int ima_identity_is_mapped(int function, struct integrity_iint_cache *iint,
+			   struct file *file, const char *pathname)
+{
+	int retn = 0;
+	char mapping[WP256_DIGEST_SIZE];
+
+	if (have_violation(file, iint, pathname))
+		return 1;
+
+	if (ima_map_identity(function, iint, file, pathname, mapping) != 0)
+		return 0;
+
+	if (have_contour(mapping)) {
+#if 0
+		pr_info("[%s]: Contour cache hit path=%s, mapping=%*phN\n",
+			__func__, pathname, WP256_DIGEST_SIZE, mapping);
+#endif
+		return 1;
+	}
+
+	if (domain_sealed) {
+		retn = register_forensic_violation(function, iint, file,
+						   pathname);
+		if (retn == 0 )
+			retn = add_contour_point(mapping);
+	}
+	else
+		retn = add_contour_point(mapping);
+
+#if 0
+	if (!retn)
+		pr_info("[%s]: Mapped entry=%d, comm=%s, pid=%d, func=%d, pathname=%s, fsmagic=%lx, inum=%lu, identity=%*phN\n",
+			__func__, contour_count, current->comm, current->pid,
+			function, pathname, iint->inode->i_sb->s_magic,
+			iint->inode->i_ino, WP256_DIGEST_SIZE, mapping);
+#endif
+	return retn;
+}
+
+int __init ima_identity_init(void)
+{
+	int retn = -1;
+
+	identity_dir = ima_fs_init_identity();
+	if (identity_dir == NULL)
+		goto done;
+
+	contours = securityfs_create_file("contours", S_IRUSR | S_IRGRP,
+					  identity_dir, NULL,
+					  &ima_contours_ops);
+	if (IS_ERR(contours))
+		goto err;
+
+	map = securityfs_create_file("map", S_IWUSR, identity_dir, NULL,
+				     &ima_map_ops);
+	if (IS_ERR(map))
+		goto err;
+
+	pseudonym = securityfs_create_file("pseudonym", S_IWUSR, identity_dir,
+					   NULL, &ima_pseudonym_ops);
+	if (IS_ERR(pseudonym))
+		goto err;
+
+	host_identity = securityfs_create_file("host_identity", S_IWUSR,
+					       identity_dir, NULL,
+					       &ima_host_identity_ops);
+	if (IS_ERR(host_identity))
+		goto err;
+
+	sealed = securityfs_create_file("sealed", S_IWUSR, identity_dir, NULL,
+					&ima_sealed_ops);
+	if (IS_ERR(sealed))
+		goto err;
+
+	forensics = securityfs_create_file("forensics", S_IRUSR | S_IRGRP,
+					   identity_dir, NULL,
+					   &ima_forensics_ops);
+	if (IS_ERR(forensics))
+		goto err;
+
+	measurement_file = securityfs_create_file("measurement",
+						  S_IRUSR | S_IRGRP,
+						  identity_dir, NULL,
+						  &ima_measurement_ops);
+	if (IS_ERR(measurement_file))
+		goto err;
+
+	retn = 0;
+
+ done:
+	return retn;
+
+ err:
+	securityfs_remove(contours);
+	securityfs_remove(map);
+	securityfs_remove(pseudonym);
+	securityfs_remove(host_identity);
+	securityfs_remove(sealed);
+	securityfs_remove(forensics);
+	securityfs_remove(measurement_file);
+
+	return retn;
+}
diff --git a/security/integrity/ima/ima_init.c b/security/integrity/ima/ima_init.c
index e600cadd231c..e4983104517a 100644
--- a/security/integrity/ima/ima_init.c
+++ b/security/integrity/ima/ima_init.c
@@ -133,5 +133,9 @@ int __init ima_init(void)
 
 	ima_init_policy();
 
-	return ima_fs_init();
+	rc = ima_fs_init();
+	if (rc != 0)
+		return rc;
+
+	return ima_identity_init();
 }
-- 
2.11.0

