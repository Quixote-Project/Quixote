From 78443d12af33ebf3063aa2f37ec625f37176848d Mon Sep 17 00:00:00 2001
From: "Dr. Greg Wettstein" <greg@enjellic.com>
Date: Sat, 14 Oct 2017 17:28:28 -0500
Subject: [PATCH 31/37] Add support for export of hardware aggregate
 measurement.

This update provides support for exporting an event of the
following form:

	export SHA256

Where SHA256 is a 256 bit ASCII hexadecimal number which
represents the hardware measurement value.  This value is the
initial measurement taken by the integrity measurement
architecture after the system boots.

With this change the cboot utility now generates a gross system
measurement value consistent with the value maintained by the
in-kernel modeling system.
---
 security/integrity/ima/ima_identity.c | 94 ++++++++++++++++++++++++++++++++++-
 1 file changed, 92 insertions(+), 2 deletions(-)

diff --git a/security/integrity/ima/ima_identity.c b/security/integrity/ima/ima_identity.c
index ef585cb0faf7..cd67059f1d5e 100644
--- a/security/integrity/ima/ima_identity.c
+++ b/security/integrity/ima/ima_identity.c
@@ -63,6 +63,12 @@ struct subject_identity {
 	char digest[WP256_DIGEST_SIZE];
 } __attribute__((__packed__));
 
+/*
+ * The system aggregate measurement for export into canisters.
+ */
+static _Bool have_aggregate;
+static char aggregate[WP256_DIGEST_SIZE];
+
 /*
  * Root dentry for the 'iso-identity' directory and dentries for the
  * pseudo-files in that directory.
@@ -99,7 +105,8 @@ struct trajectory {
 /* Types of events. */
 enum event_types {
 	measurement_event=1,
-	exchange_event
+	exchange_event,
+	aggregate_event
 };
 
 /* Structure defining a model event. */
@@ -492,6 +499,7 @@ static int update_behavior_measurement(struct crypto_shash *tfm, char *id)
 	} desc;
 	struct iso_identity_map *map = current_map();
 
+	/* Map the measurement to a host dimension. */
 	retn = get_host_measurement(tfm, id, WP256_DIGEST_SIZE, digest);
 	if (retn != 0)
 		goto done;
@@ -687,6 +695,11 @@ static ssize_t show_ns_update(struct kobject *kobj,
 	mp = list_first_entry(&map->measurement_list, struct event, list);
 
 	switch ( mp->type ) {
+		case aggregate_event:
+			retn = sprintf(page, "aggregate %*phN\n",
+				       (int) sizeof(aggregate), aggregate);
+			break;
+
 		case measurement_event:
 			retn = sprintf(page, "measurement %*phN\n",
 				       (int) sizeof(mp->u.measurement),
@@ -1235,6 +1248,14 @@ int ima_identity_genhash(struct ima_template_entry *entry, char *tpm_digest)
 	if (retn != 0)
 		goto done;
 
+	/* Save the aggregate measurement. */
+	if (!have_aggregate) {
+		memcpy(aggregate, identity.hdr.digest, WP256_DIGEST_SIZE);
+		have_aggregate = true;
+		pr_info("ima_identity: Saved aggregate: %*phN\n",
+			WP256_DIGEST_SIZE, aggregate);
+	}
+
 	/* Extend current identity measurement state. */
 	tfm = crypto_alloc_shash("sha256", 0, 0);
 	if (IS_ERR(tfm)) {
@@ -1712,6 +1733,67 @@ void ima_free_ns(struct kref *kref)
 	return;
 }
 
+static int add_aggregate(struct crypto_shash *tfm,
+			 struct iso_identity_map *map)
+{
+	int retn = 0;
+	char host_measurement[WP256_DIGEST_SIZE];
+	struct {
+		struct shash_desc shash;
+		char ctx[crypto_shash_descsize(tfm)];
+	} desc;
+	struct event *mp;
+
+	desc.shash.tfm = tfm;
+	desc.shash.flags = 0;
+
+	/* Extend the aggregate measurement into a host domain. */
+	retn = crypto_shash_init(&desc.shash);
+	if (retn != 0)
+		goto done;
+	retn = crypto_shash_update(&desc.shash, map->hostid,
+				   WP256_DIGEST_SIZE);
+	if (retn != 0)
+		goto done;
+	retn = crypto_shash_finup(&desc.shash, aggregate, sizeof(aggregate),
+				  host_measurement);
+	if (retn != 0)
+		goto done;
+
+
+	/* Extend the measurement with the host aggregate measurement. */
+	retn = crypto_shash_init(&desc.shash);
+	if (retn != 0)
+		goto done;
+	retn = crypto_shash_update(&desc.shash, map->measurement,
+				   WP256_DIGEST_SIZE);
+	if (retn != 0)
+		goto done;
+	retn = crypto_shash_finup(&desc.shash, host_measurement,
+				  sizeof(host_measurement), map->measurement);
+	if (retn != 0)
+		goto done;
+
+
+	/* Add the aggregate entry. */
+	mp = kzalloc(sizeof(struct event), GFP_KERNEL);
+	if (!mp) {
+		retn = -ENOMEM;
+		goto done;
+	}
+
+	mp->type = aggregate_event;
+
+	mutex_lock(&map->measurement_mutex);
+	list_add_tail(&mp->list, &map->measurement_list);
+	mutex_unlock(&map->measurement_mutex);
+
+	sysfs_notify(iso_identity_kobject, NULL, map->update.attr.name);
+
+ done:
+	return retn;
+}
+
 struct iso_identity_namespace *ima_copy_behavior_ns(unsigned long flags,
 				    struct user_namespace *user_ns,
 				    struct iso_identity_namespace *behavior_ns)
@@ -1720,6 +1802,7 @@ struct iso_identity_namespace *ima_copy_behavior_ns(unsigned long flags,
 	char bufr[strlen(update) + 10 + 1];
 	int retn = 0;
 	struct iso_identity_namespace *ns;
+	struct crypto_shash *tfm = NULL;
 
 	pr_info("[%s]: New ns = %s\n", __func__,
 		flags & CLONE_BEHAVIOR ? "yes" : "no");
@@ -1774,7 +1857,14 @@ struct iso_identity_namespace *ima_copy_behavior_ns(unsigned long flags,
 	if(retn)
 		goto done;
 
-	retn = 0;
+	tfm = crypto_alloc_shash("sha256", 0, 0);
+	if (IS_ERR(tfm)) {
+		retn = PTR_ERR(tfm);
+		goto done;
+	}
+
+	retn = add_aggregate(tfm, ns->map);
+	crypto_free_shash(tfm);
 
  done:
 	if (retn) {
-- 
2.16.2

