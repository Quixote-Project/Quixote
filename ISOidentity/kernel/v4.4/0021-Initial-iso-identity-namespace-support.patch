From 616738ab0a65cac6780b1e8a97508ff333024169 Mon Sep 17 00:00:00 2001
From: "Dr. Greg Wettstein" <greg@enjellic.com>
Date: Mon, 10 Apr 2017 00:40:01 -0500
Subject: [PATCH 21/24] Initial iso-identity namespace support.

The changes in this commit provide support for creating behavior
namespaces which allow independent behavior environments to be
created which do not affect the measurement status of the parent
environment.

A new behavior namespace is requested with the CLONE_BEHAVIOR
flag which is currently set to the value of 0x00001000 which is
the last CLONE flag which is available.  This value may not be
compatible with subsequent kernels.  The depletion of CLONE_*
flags is a generic problem which will need to be addressed if
additional operating system resources are virtualized.

The current implementation has a regression in that 'sealing' a
behavior domain in a subordinate namespace has the effective
result of sealing the parent namespaces as well.  This will
require that the concept of removing relevant /sysfs nodes be
revisited since the pseudo-files in the iso-identity directory
are not virtualized.
---
 include/linux/ima.h                   | 16 ++++++
 include/uapi/linux/sched.h            |  1 +
 kernel/fork.c                         |  2 +-
 kernel/nsproxy.c                      | 15 +++++-
 security/integrity/ima/ima_identity.c | 98 +++++++++++++++++++++++++++++++++--
 5 files changed, 126 insertions(+), 6 deletions(-)

diff --git a/include/linux/ima.h b/include/linux/ima.h
index 120ccc53fcb7..3fd2cff5492b 100644
--- a/include/linux/ima.h
+++ b/include/linux/ima.h
@@ -14,6 +14,13 @@
 struct linux_binprm;
 
 #ifdef CONFIG_IMA
+struct iso_identity_map;
+
+struct iso_identity_namespace {
+	struct kref kref;
+	struct iso_identity_map *map;
+};
+
 extern int ima_bprm_check(struct linux_binprm *bprm);
 extern int ima_file_check(struct file *file, int mask, int opened);
 extern void ima_file_free(struct file *file);
@@ -21,6 +28,15 @@ extern int ima_file_mmap(struct file *file, unsigned long prot);
 extern int ima_module_check(struct file *file);
 extern int ima_fw_from_file(struct file *file, char *buf, size_t size);
 
+extern struct iso_identity_namespace * ima_copy_behavior_ns(unsigned long,
+					      struct user_namespace *,
+					      struct iso_identity_namespace *);
+extern void ima_free_ns(struct kref *);
+
+static inline void ima_put_ns(struct iso_identity_namespace *ns)
+{
+	kref_put(&ns->kref, ima_free_ns);
+}
 #else
 static inline int ima_bprm_check(struct linux_binprm *bprm)
 {
diff --git a/include/uapi/linux/sched.h b/include/uapi/linux/sched.h
index cc89ddefa926..c7f12e3571a2 100644
--- a/include/uapi/linux/sched.h
+++ b/include/uapi/linux/sched.h
@@ -9,6 +9,7 @@
 #define CLONE_FS	0x00000200	/* set if fs info shared between processes */
 #define CLONE_FILES	0x00000400	/* set if open files shared between processes */
 #define CLONE_SIGHAND	0x00000800	/* set if signal handlers and blocked signals shared */
+#define CLONE_BEHAVIOR	0x00001000	/* Define new behavior dimension. */
 #define CLONE_PTRACE	0x00002000	/* set if we want to let tracing continue on the child too */
 #define CLONE_VFORK	0x00004000	/* set if the parent wants the child to wake it up on mm_release */
 #define CLONE_PARENT	0x00008000	/* set if we want to have the same parent as the cloner */
diff --git a/kernel/fork.c b/kernel/fork.c
index 1155eac61687..d4052628e0c9 100644
--- a/kernel/fork.c
+++ b/kernel/fork.c
@@ -1882,7 +1882,7 @@ static int check_unshare_flags(unsigned long unshare_flags)
 	if (unshare_flags & ~(CLONE_THREAD|CLONE_FS|CLONE_NEWNS|CLONE_SIGHAND|
 				CLONE_VM|CLONE_FILES|CLONE_SYSVSEM|
 				CLONE_NEWUTS|CLONE_NEWIPC|CLONE_NEWNET|
-				CLONE_NEWUSER|CLONE_NEWPID))
+				CLONE_NEWUSER|CLONE_NEWPID|CLONE_BEHAVIOR))
 		return -EINVAL;
 	/*
 	 * Not implemented, but pretend it works if there is nothing
diff --git a/kernel/nsproxy.c b/kernel/nsproxy.c
index 49746c81ad8d..5faa9f0d9ccc 100644
--- a/kernel/nsproxy.c
+++ b/kernel/nsproxy.c
@@ -25,6 +25,7 @@
 #include <linux/proc_ns.h>
 #include <linux/file.h>
 #include <linux/syscalls.h>
+#include <linux/ima.h>
 
 static struct kmem_cache *nsproxy_cachep;
 
@@ -98,8 +99,18 @@ static struct nsproxy *create_new_namespaces(unsigned long flags,
 		goto out_net;
 	}
 
+	new_nsp->behavior_ns = ima_copy_behavior_ns(flags, user_ns,
+						    tsk->nsproxy->behavior_ns);
+	if (IS_ERR(new_nsp->behavior_ns)) {
+		err = PTR_ERR(new_nsp->behavior_ns);
+		goto out_behavior;
+	}
+
 	return new_nsp;
 
+out_behavior:
+	if (new_nsp->net_ns)
+		put_net(new_nsp->net_ns);
 out_net:
 	if (new_nsp->pid_ns_for_children)
 		put_pid_ns(new_nsp->pid_ns_for_children);
@@ -165,6 +176,8 @@ void free_nsproxy(struct nsproxy *ns)
 		put_ipc_ns(ns->ipc_ns);
 	if (ns->pid_ns_for_children)
 		put_pid_ns(ns->pid_ns_for_children);
+	if (ns->behavior_ns)
+		ima_put_ns(ns->behavior_ns);
 	put_net(ns->net_ns);
 	kmem_cache_free(nsproxy_cachep, ns);
 }
@@ -180,7 +193,7 @@ int unshare_nsproxy_namespaces(unsigned long unshare_flags,
 	int err = 0;
 
 	if (!(unshare_flags & (CLONE_NEWNS | CLONE_NEWUTS | CLONE_NEWIPC |
-			       CLONE_NEWNET | CLONE_NEWPID)))
+			       CLONE_NEWNET | CLONE_NEWPID | CLONE_BEHAVIOR)))
 		return 0;
 
 	user_ns = new_cred ? new_cred->user_ns : current_user_ns();
diff --git a/security/integrity/ima/ima_identity.c b/security/integrity/ima/ima_identity.c
index e58719a7764a..2b4768f2b3bb 100644
--- a/security/integrity/ima/ima_identity.c
+++ b/security/integrity/ima/ima_identity.c
@@ -18,6 +18,7 @@
 #include <linux/syscalls.h>
 #include <crypto/hash.h>
 #include <crypto/hash_info.h>
+#include <linux/ima.h>
 
 #include "ima.h"
 
@@ -115,14 +116,15 @@ struct iso_identity_map {
 
 	.trajectory_list_mutex = __MUTEX_INITIALIZER(init_iso_identity_map.trajectory_list_mutex),
 	.trajectory_list = LIST_HEAD_INIT(init_iso_identity_map.trajectory_list),
+	.max_forensics_count = 10,
 	.forensic_event_list = LIST_HEAD_INIT(init_iso_identity_map.forensic_event_list),
 };
 
-struct iso_identity_namespace {
-	struct iso_identity_map *map;
-};
-
 struct iso_identity_namespace init_iso_identity_ns = {
+        .kref = {
+		.refcount = ATOMIC_INIT(2)
+	},
+
 	.map = &init_iso_identity_map,
 };
 
@@ -1422,12 +1424,100 @@ int __init ima_identity_init(void)
 	return retn;
 }
 
+void ima_free_ns(struct kref *kref)
+{
+	struct iso_identity_namespace *ns;
+	struct contour *centry, *tmp_centry;
+	struct trajectory *tentry, *tmp_tentry;
+
+	ns = container_of(kref, struct iso_identity_namespace, kref);
+
+	list_for_each_entry_safe(centry, tmp_centry, &ns->map->contour_list,
+				 list) {
+		list_del(&centry->list);
+		pr_info("[%s]: Freeing contour: %*phN\n", __func__,
+			WP256_DIGEST_SIZE, centry->identity);
+		kfree(centry);
+	}
+
+	list_for_each_entry_safe(tentry, tmp_tentry, &ns->map->trajectory_list,
+				 list) {
+		list_del(&tentry->list);
+		pr_info("[%s]: Removing event: %s:%s\n", __func__,
+			tentry->process, tentry->filename);
+		kfree(tentry->filename);
+		kfree(tentry->process);
+		kfree(tentry);
+	}
+
+	if (ns->map->domain_sealed) {
+		list_for_each_entry_safe(tentry, tmp_tentry,
+					 &ns->map->trajectory_list, list) {
+			list_del(&tentry->list);
+			pr_info("[%s]: Removing event: %s/%s\n", __func__,
+				tentry->process, tentry->filename);
+			kfree(tentry->filename);
+			kfree(tentry->process);
+			kfree(tentry);
+		}
+	}
+
+	kfree(ns->map);
+	kfree(ns);
+
+	return;
+}
+
+struct iso_identity_namespace *ima_copy_behavior_ns(unsigned long flags,
+				    struct user_namespace *user_ns,
+				    struct iso_identity_namespace *behavior_ns)
+{
+	int retn = 0;
+	struct iso_identity_namespace *ns;
+
+	pr_info("[%s]: New ns = %s\n", __func__,
+		flags & CLONE_BEHAVIOR ? "yes" : "no");
+
+	if (!(flags & CLONE_BEHAVIOR))
+		return behavior_ns;
+
+	ns = kzalloc(sizeof(struct iso_identity_namespace), GFP_KERNEL);
+	if (!ns) {
+		retn = -ENOMEM;
+		goto done;
+	}
+	kref_init(&ns->kref);
+
+	ns->map = kzalloc(sizeof(struct iso_identity_map), GFP_KERNEL);
+	if (!ns->map) {
+		retn = -ENOMEM;
+		goto done;
+	}
+	mutex_init(&ns->map->contour_list_mutex);
+	INIT_LIST_HEAD(&ns->map->contour_list);
+
+	mutex_init(&ns->map->trajectory_list_mutex);
+	INIT_LIST_HEAD(&ns->map->trajectory_list);
+
+	ns->map->max_forensics_count = 10;
+	INIT_LIST_HEAD(&ns->map->forensic_event_list);
+
+	retn = 0;
+
+ done:
+	if (retn)
+		return ERR_PTR(-ENOMEM);
+	return ns;
+}
+
 SYSCALL_DEFINE3(set_behavior, unsigned char *, bufr, size_t, cnt,
 		unsigned long, flags)
 {
 	int retn = -EINVAL;
 
+#if 0
 	pr_info("[%s]: Called: cnt=%zu, flags=%lu.\n", __func__, cnt, flags);
+#endif
 
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
-- 
2.11.0

