From 42f9ccf1828b35089167af32ff27daba662cb3e3 Mon Sep 17 00:00:00 2001
From: "Dr. Greg Wettstein" <greg@enjellic.com>
Date: Sun, 23 Sep 2018 22:13:06 -0500
Subject: [PATCH 37/37] Implement configurable AI introspection hooks.

This update adds an additional AI introspection hook designed to
regulate the behavior of a request to listen on a socket.

In addition the sys_set_behavior system call was modified in
order to set the type of response for any introspection event.
This was implemented by specifying a value of four for the flags
arguement to the system call.

An arguement of four causes the pointer arguement to the system
call to be interpreted as a two member structure.  One member
specifies the introspect event whose behavior is to be set and
the second member specifies response to be applied if the
introspection event is triggered by a bad actor process.

The update also makes the introspection behavior a per behavioral
namespace action.  This is implemented by embedding a point to an
array of AIevent structures in the behavioral namespace
structure.

These changes also implement a change in how privilege checking
is done for the system call.  Previously the CAP_SYS_ADMIN
capability was required to execute the system call.  This is now
only enforced for the root behavioral namespace.

In the case of a process running in a behavioral namespace a
check is implemented to see if the effective UID for the calling
process is zero.
---
 security/ai/ai.c                      | 26 +++++++++++-
 security/integrity/ima/ima_identity.c | 80 +++++++++++++++++++++++++++++------
 2 files changed, 90 insertions(+), 16 deletions(-)

diff --git a/security/ai/ai.c b/security/ai/ai.c
index 3a2e6f68ffb9..bba953f28c2d 100644
--- a/security/ai/ai.c
+++ b/security/ai/ai.c
@@ -25,6 +25,7 @@
 enum AIevent_type {
 	AI_file_open=0,
 	AI_socket_connect,
+	AI_socket_listen,
 	AI_undefined
 };
 
@@ -62,7 +63,7 @@ static int ai_file_open(struct file *f, const struct cred *cred)
 
 
 /**
- * ai_socket_open - Introspection hook to intercept socket connections.
+ * ai_socket_connect - Introspection hook to intercept socket connections.
  *
  * @sock:	A pointer to the socket structure being used to
  *	        implement the connection.
@@ -87,13 +88,34 @@ static int ai_socket_connect(struct socket *sock, struct sockaddr *addr,
 }
 
 
+/**
+ * ai_socket_open - Introspection hook to intercept socket listen requests.
+ *
+ * @sock:	A pointer to the socket that will be listened on.
+ * @backlog:	The connection backlog depth that will be allowed.
+ *
+ * Returns 0 on success, negative value otherwise.
+ */
+
+static int ai_socket_listen(struct socket *sock, int backlog)
+
+{
+	if ( !current->bad_actor )
+		return 0;
+
+	pr_info("%s: Refused socket listen, backlog=%d\n", __func__, backlog);
+	return ima_identity_process_ai(AI_socket_listen);
+}
+
+
 /*
  * The following array holds the introspection hooks which are
  * implemented.
  */
 static struct security_hook_list ai_hooks[] = {
 	LSM_HOOK_INIT(file_open, ai_file_open),
-	LSM_HOOK_INIT(socket_connect, ai_socket_connect)
+	LSM_HOOK_INIT(socket_connect, ai_socket_connect),
+	LSM_HOOK_INIT(socket_listen, ai_socket_listen)
 };
 
 
diff --git a/security/integrity/ima/ima_identity.c b/security/integrity/ima/ima_identity.c
index be44708b4ae2..77ca7132b07f 100644
--- a/security/integrity/ima/ima_identity.c
+++ b/security/integrity/ima/ima_identity.c
@@ -28,6 +28,7 @@
 /* System call definitions. */
 #define IMA_SET_CONTOUR		0x1
 #define IMA_SET_PSEUDONYM	0x2
+#define IMA_SET_AI		0x4
 
 /* Structure defining actor identity elements. */
 struct actor_identity {
@@ -92,6 +93,7 @@ static struct kobject *iso_identity_kobject;
 enum AIevent_type {
 	AI_file_open=0,
 	AI_socket_connect,
+	AI_socket_listen,
 	AI_undefined
 };
 
@@ -106,7 +108,7 @@ const char *AI_actions[] = {
 };
 
 struct AIevent {
-	enum AIevent_type action;
+	enum AIevent_action action;
 	char *description;
 };
 
@@ -118,7 +120,8 @@ struct AIdescription {
 /* Array of structures defining the possible events. */
 struct AIevent AI_events[] = {
 	{AI_action_log, "file_open"},
-	{AI_action_eperm, "socket_connect"}
+	{AI_action_log, "socket_connect"},
+	{AI_action_log, "socket_listen"}
 };
 
 
@@ -187,6 +190,8 @@ struct iso_identity_map {
 	struct mutex measurement_mutex;
 	struct list_head measurement_list;
 
+	struct AIevent *AI_events;
+
 	struct kobj_attribute update;
 } init_iso_identity_map = {
 	.contour_list_mutex = __MUTEX_INITIALIZER(init_iso_identity_map.contour_list_mutex),
@@ -199,6 +204,8 @@ struct iso_identity_map {
 
 	.measurement_mutex = __MUTEX_INITIALIZER(init_iso_identity_map.measurement_mutex),
 	.measurement_list = LIST_HEAD_INIT(init_iso_identity_map.measurement_list),
+
+	.AI_events = AI_events
 };
 
 struct iso_identity_namespace init_iso_identity_ns = {
@@ -1929,6 +1936,13 @@ struct iso_identity_namespace *ima_copy_behavior_ns(unsigned long flags,
 	mutex_init(&ns->map->measurement_mutex);
 	INIT_LIST_HEAD(&ns->map->measurement_list);
 
+	ns->map->AI_events = kzalloc(sizeof(AI_events), GFP_KERNEL);
+	if (!ns->map->AI_events) {
+		retn = -ENOMEM;
+		goto done;
+	}
+	memcpy(ns->map->AI_events, AI_events, sizeof(AI_events));
+
 	if (snprintf(bufr, sizeof(bufr), "%s%u", update, ns->ns.inum) >=
 	    sizeof(bufr)) {
 		retn = -ENOMEM;
@@ -1959,6 +1973,7 @@ struct iso_identity_namespace *ima_copy_behavior_ns(unsigned long flags,
 	if (retn) {
 		if (ns && ns->map) {
 			kfree(ns->map->update.attr.name);
+			kfree(ns->map->AI_events);
 			kfree(ns->map);
 		}
 		kfree(ns);
@@ -1982,7 +1997,7 @@ int ima_identity_process_ai(unsigned int event)
 {
 	int retn = 0;
 
-	struct iso_identity_map *map;
+	struct iso_identity_map *map = current_map();
 
 	struct event *ep;
 
@@ -1992,29 +2007,22 @@ int ima_identity_process_ai(unsigned int event)
 		goto done;
 	}
 
-	if (!current->nsproxy->behavior_ns)
-		goto done;
-
-
 	/* Add the event to the list. */
-	map = current_map();
 	ep = kzalloc(sizeof(struct event), GFP_KERNEL);
 	if (!ep)
 		return -ENOMEM;
 
 	ep->type = ai_event;
-	ep->u.ai.descn = &AI_events[event];
+	ep->u.ai.descn = &map->AI_events[event];
 	strcpy(ep->u.ai.process, current->comm);
 
-	switch ( AI_events[event].action ) {
+	switch ( map->AI_events[event].action ) {
 		case AI_action_log:
 			retn = 0;
 			break;
 		case AI_action_eperm:
 			retn = -EPERM;
 			break;
-		case AI_undefined:
-			break;
 	}
 
 	mutex_lock(&map->measurement_mutex);
@@ -2062,14 +2070,28 @@ SYSCALL_DEFINE3(set_behavior, unsigned char *, bufr, size_t, cnt,
 {
 	int retn = -EINVAL;
 	struct iso_identity_map *map = current_map();
+	struct ai_control {
+		unsigned int hook;
+		unsigned int action;
+	} ctl;
+	kuid_t root_uid;
 
 #if 0
 	pr_info("[%s]: Called: cnt=%zu, flags=%lu.\n", __func__, cnt, flags);
 #endif
 
-	if (!capable(CAP_SYS_ADMIN))
+	/* Verify permissions for system call. */
+	if (!current->nsproxy->behavior_ns && !capable(CAP_SYS_ADMIN))
 		return -EPERM;
-	if (flags & ~(IMA_SET_CONTOUR | IMA_SET_PSEUDONYM))
+
+	if (current->nsproxy->behavior_ns) {
+		root_uid = make_kuid(current_cred()->user_ns, 0);
+		if ( !uid_eq(current_euid(), root_uid) )
+			return -EPERM;
+	}
+
+	/* Verify valid system call control flags. */
+	if (flags & ~(IMA_SET_CONTOUR | IMA_SET_PSEUDONYM | IMA_SET_AI))
 		return -EINVAL;
 
 
@@ -2087,6 +2109,36 @@ SYSCALL_DEFINE3(set_behavior, unsigned char *, bufr, size_t, cnt,
 		goto done;
 	}
 
+	if (flags & IMA_SET_AI) {
+		if (map->domain_sealed) {
+			retn = -EPERM;
+			goto done;
+		}
+		if (cnt != sizeof(ctl)) {
+			retn = -EINVAL;
+			goto done;
+		}
+		if (copy_from_user(&ctl, bufr, sizeof(ctl))) {
+			retn = -EFAULT;
+			goto done;
+		}
+
+		if (ctl.hook >= AI_undefined) {
+			retn = -EINVAL;
+			goto done;
+		}
+		if (ctl.action > AI_action_eperm) {
+			retn = -EINVAL;
+			goto done;
+		}
+
+		map->AI_events[ctl.hook].action = ctl.action;
+		pr_info("%s modified ai hook %s, action=%s\n", __func__,
+			map->AI_events[ctl.hook].description,
+			AI_actions[ctl.action]);
+		retn = 0;
+	}
+
  done:
 	return retn;
 }
-- 
2.16.2

