From 1d30e2c0d137dfeffc4d201b3c7960709ef64581 Mon Sep 17 00:00:00 2001
From: "Dr. Greg Wettstein" <greg@enjellic.com>
Date: Fri, 31 Mar 2017 10:58:03 -0500
Subject: [PATCH 17/24] Convert forensic tracking to trajectory infrastructure.

The information which is registered in an execution trajectory
point is a superset of the information which was being saved in
the forensic tracking infrastructure.  Given that it made little
sense to support separate support for tracking information which
would document a forensic event.

The code which creates a trajectory point was consolidated into a
single helper function.  The add_forensic_point() and
add_trajectory_point() functions use this function to create
entries which are added to either the forensic or trajectory
lists.
---
 security/integrity/ima/ima_identity.c | 189 ++++++++++++++++++----------------
 1 file changed, 101 insertions(+), 88 deletions(-)

diff --git a/security/integrity/ima/ima_identity.c b/security/integrity/ima/ima_identity.c
index 36e10a979c11..bf9a44fbd21d 100644
--- a/security/integrity/ima/ima_identity.c
+++ b/security/integrity/ima/ima_identity.c
@@ -73,26 +73,6 @@ static char host_id[WP256_DIGEST_SIZE];
 char *hostid = host_id;
 
 /*
- * Variables for managing and providing forensic information on the
- * sealed dimensionality of the system measurement state.
- */
-static bool domain_sealed;
-
-static unsigned int forensics_count;
-static unsigned int max_forensics_count = 5;
-
-struct forensic_event {
-	struct list_head list;
-	int function;
-	char *process;
-	char *pathname;
-	struct actor_identity identity;
-};
-
-static DEFINE_MUTEX(forensic_event_list_mutex);
-static LIST_HEAD(forensic_event_list);
-
-/*
  * Definitions, locks and variables for the linked lists implementing
  * the iso-identity contour points.
  */
@@ -117,6 +97,18 @@ static DEFINE_MUTEX(trajectory_list_mutex);
 static LIST_HEAD(trajectory_list);
 static unsigned int trajectory_count;
 
+/*
+ * Variables for managing and providing forensic information on the
+ * sealed dimensionality of the system measurement state.
+ */
+static bool domain_sealed;
+
+static unsigned int forensics_count;
+static unsigned int max_forensics_count = 5;
+
+static DEFINE_MUTEX(forensic_event_list_mutex);
+static LIST_HEAD(forensic_event_list);
+
 /* Iso-identity measurement value. */
 static char measurement[WP256_DIGEST_SIZE];
 
@@ -211,21 +203,20 @@ static int add_contour_point(char *point)
 }
 
 /**
- *	add_trajectory_point - Add a point to the system behavior trajectory.
- *	@filename: The name of the event.
- *	@actor: The actor identity elements.
- *	@subject: The subject identity elements.
- *
- *	Returns a non-zero value on a failure to add a point.
+ *	create_point - This function is a helper function for the
+ *	add add_contour_point() and add_forensic_point() functions.  It
+ *	consolidates all of the functionality needed to create the
+ *	list entry leaving the addition of the entry to the calling
+ *	functions.
  */
 
-static int add_trajectory_point(const char *filename,
-				struct actor_identity *actor,
-				struct subject_identity *subject)
+static struct trajectory * create_point(const char *filename,
+					struct actor_identity *actor,
+					struct subject_identity *subject)
 {
-	int retn = 1;
+	bool err = true;
 	char *fname = NULL, *process = NULL;
-	struct trajectory *entry;
+	struct trajectory *entry = NULL;
 
 	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
 	if (!entry)
@@ -244,6 +235,36 @@ static int add_trajectory_point(const char *filename,
 	entry->actor = *actor;
 	entry->subject = *subject;
 
+	err = false;
+
+ done:
+	if ( err )
+		kfree(entry);
+
+	return entry;
+}
+
+/**
+ *	add_trajectory_point - Add a point to the system behavior trajectory.
+ *	@filename: The name of the event.
+ *	@actor: The actor identity elements.
+ *	@subject: The subject identity elements.
+ *
+ *	Returns a non-zero value on a failure to add a point.
+ */
+
+static int add_trajectory_point(const char *filename,
+				struct actor_identity *actor,
+				struct subject_identity *subject)
+{
+	int retn = 1;
+	char *fname = NULL, *process = NULL;
+	struct trajectory *entry;
+
+	entry = create_point(filename, actor, subject);
+	if ( !entry )
+		goto done;
+
 	mutex_lock(&trajectory_list_mutex);
 	list_add_tail(&entry->list, &trajectory_list);
 	++trajectory_count;
@@ -259,6 +280,43 @@ static int add_trajectory_point(const char *filename,
 	return retn;
 }
 
+/**
+ *	add_forensic_point - Add a point which documents a forensic
+ *	event on the trajectory surface.
+ *	@filename: The name of the event.
+ *	@actor: The actor identity elements.
+ *	@subject: The subject identity elements.
+ *
+ *	Returns a non-zero value on a failure to add a point.
+ */
+
+static int add_forensic_point(const char *filename,
+			      struct actor_identity *actor,
+			      struct subject_identity *subject)
+{
+	int retn = 1;
+	struct trajectory *entry;
+
+	if (forensics_count == max_forensics_count)
+		return 1;
+
+	entry = create_point(filename, actor, subject);
+	if ( !entry )
+		goto done;
+
+	mutex_lock(&forensic_event_list_mutex);
+	list_add_tail(&entry->list, &forensic_event_list);
+	++forensics_count;
+	mutex_unlock(&forensic_event_list_mutex);
+
+	pr_info("[%s]: Registered forensic violation for path=%s\n",
+		__func__, filename);
+	retn = 0;
+
+ done:
+	return retn;
+}
+
 static int get_host_measurement(struct crypto_shash *tfm, char *id,
 				size_t idlength, char *digest)
 {
@@ -754,26 +812,19 @@ static void ima_forensics_stop(struct seq_file *c, void *pos)
 
 static int ima_forensics_show(struct seq_file *c, void *event)
 {
-	struct forensic_event *p;
-
-	p= list_entry(event, struct forensic_event, list);
-
-	seq_printf(c, "function: %d\n", p->function);
-	seq_printf(c, "process: %s\n", p->process);
-	seq_printf(c, "pathname: %s\n", p->pathname);
-	seq_printf(c, "uid: %d\n", p->identity.uid);
-	seq_printf(c, "euid: %d\n", p->identity.euid);
-	seq_printf(c, "suid: %d\n", p->identity.suid);
-
-	seq_printf(c, "gid: %d\n", p->identity.gid);
-	seq_printf(c, "egid: %d\n", p->identity.egid);
-	seq_printf(c, "sgid: %d\n", p->identity.sgid);
+	struct trajectory *pt;
 
-	seq_printf(c, "fsuid: %d\n", p->identity.fsuid);
-	seq_printf(c, "fsgid: %d\n", p->identity.fsgid);
+	pt = list_entry(event, struct trajectory, list);
 
-	seq_printf(c, "capabilities: 0x%llx\n\n",
-		   p->identity.capability.value);
+	seq_printf(c, "event{%s:%s} actor{uid=%d, euid=%d, suid=%d, gid=%d, egid=%d, sgid=%d, fsuid=%d, fsgid=%d, cap=0x%llx} subject{uid=%d, gid=%d, mode=0%o, name_length=%u, name=%*phN, s_id=%s, s_uuid=%*phN, digest=%*phN}\n",
+		   pt->process, pt->filename, pt->actor.uid, pt->actor.euid,
+		   pt->actor.suid, pt->actor.gid, pt->actor.egid,
+		   pt->actor.sgid, pt->actor.fsuid, pt->actor.fsgid,
+		   pt->actor.capability.value, pt->subject.uid,
+		   pt->subject.gid, pt->subject.mode, pt->subject.name_length,
+		   WP256_DIGEST_SIZE, pt->subject.name, pt->subject.s_id,
+		   (int) sizeof(pt->subject.s_uuid), pt->subject.s_uuid,
+		   WP256_DIGEST_SIZE, pt->subject.digest);
 
 	return 0;
 }
@@ -1127,43 +1178,6 @@ static int ima_map_identity(int function, struct integrity_iint_cache *iint,
 	return retn;
 }
 
-static int register_forensic_violation(int function,
-				       struct integrity_iint_cache *iint,
-				       struct file *file,
-				       const char *pathname)
-{
-	struct forensic_event *event;
-
-	if (forensics_count == max_forensics_count)
-		return 1;
-
-	event = kzalloc(sizeof(*event), GFP_KERNEL);
-	if (event == NULL )
-		return 0;
-
-	event->function = function;
-	get_identity(&event->identity);
-
-	event->process = kmalloc(strlen(current->comm) + 1, GFP_KERNEL);
-	if (event->process == NULL)
-		return 0;
-	strcpy(event->process, current->comm);
-
-	event->pathname = kmalloc(strlen(pathname) + 1, GFP_KERNEL);
-	if (event->pathname == NULL)
-		return 0;
-	strcpy(event->pathname, pathname);
-
-	mutex_lock(&forensic_event_list_mutex);
-	list_add_tail(&event->list, &forensic_event_list);
-	++forensics_count;
-	mutex_unlock(&forensic_event_list_mutex);
-
-	pr_info("[%s]: Registered forensic violation for path=%s, inode=%ld\n",
-			__func__, pathname, iint->inode->i_ino);
-	return 0;
-}
-
 int ima_identity_is_mapped(int function, struct integrity_iint_cache *iint,
 			   struct file *file, const char *pathname)
 {
@@ -1199,8 +1213,7 @@ int ima_identity_is_mapped(int function, struct integrity_iint_cache *iint,
 #endif
 
 	if (domain_sealed) {
-		retn = register_forensic_violation(function, iint, file,
-						   pathname);
+		retn = add_forensic_point(pathname, &actor, &subject);
 		if (retn == 0 )
 			retn = add_contour_point(mapping);
 	}
-- 
2.11.0

