From 440aea5e5a93561a7b6fd9ccdfb01199c6369bf6 Mon Sep 17 00:00:00 2001
From: "Dr. Greg" <greg@enjellic.com>
Date: Sat, 10 Jul 2021 16:58:28 -0500
Subject: [PATCH 43/50] Properly implement initial event namespace.

Testing indicated that is not possible to use a modified copy of
the nsenter utility to enter an alternate event namespace.  This
regression was caused by the use of a null pointer for the
initial event namespace rather then the actual address of the
root event namespace.

This commit addresses the issue by setting the event_ns member of
the init_nsproxy to the address of the structure containing the
root event namespace definition.

The code that was testing for a null pointer for the initial event
namespace definition was removed.  The test for whether or
not the current namespace is a cloned event namespace was changed
to check for the address of the initial event namespace
definition.

With these changes a modified version of nsenter will properly
access a namespace and its influence on the namespace will be
reflected in the security state of the namespace.
---
 include/linux/ima.h                 |  2 ++
 kernel/nsproxy.c                    |  3 +++
 security/integrity/ima/ima_events.c | 34 +++++++++++------------------
 3 files changed, 18 insertions(+), 21 deletions(-)

diff --git a/include/linux/ima.h b/include/linux/ima.h
index 7b040c18c938..307570c05020 100644
--- a/include/linux/ima.h
+++ b/include/linux/ima.h
@@ -22,6 +22,8 @@ struct ima_events_namespace {
 	struct ns_common ns;
 };
 
+extern struct ima_events_namespace init_ima_events_ns;
+
 extern int ima_bprm_check(struct linux_binprm *bprm);
 extern int ima_file_check(struct file *file, int mask);
 extern void ima_post_create_tmpfile(struct inode *inode);
diff --git a/kernel/nsproxy.c b/kernel/nsproxy.c
index b500c7997d99..32946e66ba9a 100644
--- a/kernel/nsproxy.c
+++ b/kernel/nsproxy.c
@@ -41,6 +41,9 @@ struct nsproxy init_nsproxy = {
 #ifdef CONFIG_CGROUPS
 	.cgroup_ns		= &init_cgroup_ns,
 #endif
+#ifdef CONFIG_IMA
+	.events_ns	        = &init_ima_events_ns,
+#endif
 };
 
 static inline struct nsproxy *create_nsproxy(void)
diff --git a/security/integrity/ima/ima_events.c b/security/integrity/ima/ima_events.c
index d7546f4b97d8..b965ac01826b 100644
--- a/security/integrity/ima/ima_events.c
+++ b/security/integrity/ima/ima_events.c
@@ -240,6 +240,7 @@ struct ima_events_namespace init_ima_events_ns = {
 
 	.map = &init_ima_events_map,
 
+	.user_ns = &init_user_ns,
 	.ns.inum = PROC_EVENTS_INIT_INO,
 	.ns.ops = &events_operations
 };
@@ -253,7 +254,7 @@ static atomic_t map_opencount = ATOMIC_INIT(1);
 
 static bool is_ns(void)
 {
-	return current->nsproxy->events_ns != NULL;
+	return current->nsproxy->events_ns != &init_ima_events_ns;
 }
 
 static struct ima_events_map *current_map(void)
@@ -2182,12 +2183,10 @@ struct ima_events_namespace *ima_copy_events_ns(unsigned long flags,
 	int retn = 0;
 	struct ima_events_namespace *ns;
 
-	pr_debug("[%s]: New ns = %s\n", __func__,
+	pr_debug("Current event ns=%p, cloning=%s\n", events_ns,
 		 flags & CLONE_EVENTS ? "yes" : "no");
 
-	if (events_ns)
-		ima_get_ns(events_ns);
-
+	ima_get_ns(events_ns);
 	if (!(flags & CLONE_EVENTS))
 		return events_ns;
 
@@ -2232,16 +2231,9 @@ struct ima_events_namespace *ima_copy_events_ns(unsigned long flags,
 	}
 	memcpy(ns->map->AI_events, AI_events, sizeof(AI_events));
 
-	if (events_ns) {
-		ns->map->external = events_ns->map->external;
-		memcpy(ns->map->base, events_ns->map->base, WP256_DIGEST_SIZE);
-	}
-	else {
-		ns->map->emit_aggregate = true;
-		ns->map->external = init_ima_events_ns.map->external;
-		memcpy(ns->map->base, init_ima_events_ns.map->base,
-		       WP256_DIGEST_SIZE);
-	}
+	ns->map->emit_aggregate = true;
+	ns->map->external = events_ns->map->external;
+	memcpy(ns->map->base, events_ns->map->base, WP256_DIGEST_SIZE);
 
 	/* Setup the update pseudo-file for this namespace. */
 	if (snprintf(bufr, sizeof(bufr), "%s%u", update, ns->ns.inum) >=
@@ -2273,8 +2265,10 @@ struct ima_events_namespace *ima_copy_events_ns(unsigned long flags,
 	kref_init(&ns->kref);
 	ns->ns.ops = &events_operations;
 	ns->user_ns = get_user_ns(user_ns);
-	if (events_ns)
-		ima_put_ns(events_ns);
+
+	ima_put_ns(events_ns);
+
+	pr_debug("New event ns=%p\n", ns);
 	return ns;
 }
 
@@ -2470,10 +2464,8 @@ static int events_install(struct nsproxy *nsproxy, struct ns_common *new)
 	if (!capable(CAP_TRUST))
 		return -EPERM;
 
-	if (events_ns) {
-		ima_get_ns(events_ns);
-		ima_put_ns(nsproxy->events_ns);
-	}
+	ima_get_ns(events_ns);
+	ima_put_ns(nsproxy->events_ns);
 
 	nsproxy->events_ns = events_ns;
 	return 0;
-- 
2.31.1

