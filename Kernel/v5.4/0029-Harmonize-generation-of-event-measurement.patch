From d6a43e09d2c1cb51102db0d0f5ea0c3eeed521a0 Mon Sep 17 00:00:00 2001
From: "Dr. Greg" <greg@enjellic.com>
Date: Wed, 17 Feb 2021 18:58:50 -0600
Subject: [PATCH 29/50] Harmonize generation of event measurement.

It was noted that in an event container the measurement that was
maintained by the kernel and presented in the measurement
pseudo-file was not consistent with the measurement that was
being maintained by the cboot daemon.

This was traced to the fact that the measurement was being
accumulated in the ima_events_genhash() function.  As a result
the measurement was only being extended when the
ima_store_measurement() function was called.

The ima_store_measurement() function only extends the measurement
if the integrity inode has not had an indication that the inode
has been measured.  As a result multiple invocations of a
container do not generate the same measurement.

The request to extend the measurement of an event namespace was
moved to the ima_events_is_mapped() function and is called once
for each time an event point is populated in a namespace.  The
exception to this is the addition of the aggregate measurement to
a namespace which is still done in the ima_events_genhash()
function for the root namespace.
---
 security/integrity/ima/ima_events.c | 30 +++++++++++++++++++----------
 1 file changed, 20 insertions(+), 10 deletions(-)

diff --git a/security/integrity/ima/ima_events.c b/security/integrity/ima/ima_events.c
index 4044c4dfccd7..91deada20d94 100644
--- a/security/integrity/ima/ima_events.c
+++ b/security/integrity/ima/ima_events.c
@@ -1356,18 +1356,18 @@ int ima_events_genhash(struct ima_template_entry *entry, char *tpm_digest)
 		have_aggregate = true;
 		pr_debug("%s: Saved aggregate: %*phN\n", __FILE__,
 			 WP256_DIGEST_SIZE, aggregate);
-	}
 
-	/* Extend current event measurement value. */
-	tfm = crypto_alloc_shash("sha256", 0, 0);
-	if (IS_ERR(tfm)) {
-		retn = PTR_ERR(tfm);
-		goto done;
+		/* Extend current event measurement value. */
+		tfm = crypto_alloc_shash("sha256", 0, 0);
+		if (IS_ERR(tfm)) {
+			retn = PTR_ERR(tfm);
+			goto done;
+		}
+		retn = update_events_measurement(tfm, measurement.hdr.digest);
+		if (retn != 0)
+			goto done;
+		crypto_free_shash(tfm);
 	}
-        retn = update_events_measurement(tfm, measurement.hdr.digest);
-	if (retn != 0)
-		goto done;
-	crypto_free_shash(tfm);
 
 	/* Generate a hash suitable for extending TPM 1.x. */
 	tfm = crypto_alloc_shash("sha1", 0, 0);
@@ -1609,6 +1609,7 @@ int ima_events_is_mapped(int function, struct integrity_iint_cache *iint,
 	char mapping[WP256_DIGEST_SIZE];
 	struct event_actor actor;
 	struct event_subject subject;
+	struct crypto_shash *sha256 = NULL;
 	struct ima_events_map *map = current_map();
 
 	if (have_violation(file, iint, pathname))
@@ -1628,6 +1629,14 @@ int ima_events_is_mapped(int function, struct integrity_iint_cache *iint,
 		return 1;
 	}
 
+	/* Update the measurement. */
+	sha256 = crypto_alloc_shash("sha256", 0, 0);
+	if (IS_ERR(sha256)) {
+		return 0;
+	}
+	update_events_measurement(sha256, mapping);
+	crypto_free_shash(sha256);
+
 	pr_debug("[%s] actor uid=%d, euid=%d, suid=%d, gid=%d, egid=%d, sgid=%d, fsuid=%d, fsgid=%d, cap=%llx\n", __func__, actor.uid, actor.euid,
 		actor.suid, actor.gid, actor.egid, actor.sgid, actor.fsuid,
 		actor.fsgid, actor.capability.value);
@@ -1657,6 +1666,7 @@ int ima_events_is_mapped(int function, struct integrity_iint_cache *iint,
 			__func__, current->comm, current->pid, function,
 			 pathname, iint->inode->i_sb->s_magic,
 			 iint->inode->i_ino, WP256_DIGEST_SIZE, mapping);
+
 	return retn;
 }
 
-- 
2.31.1

