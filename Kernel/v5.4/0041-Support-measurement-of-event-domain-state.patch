From 3af8e3dec0a7a7f790824848b01c21703c612528 Mon Sep 17 00:00:00 2001
From: "Dr. Greg" <greg@enjellic.com>
Date: Thu, 15 Apr 2021 03:37:41 -0500
Subject: [PATCH 41/50] Support measurement of event domain state.

The measurement of a trusted system has been classically defined
as the extension sum of measurement values from a known point.
This measurement value has been clasically maintained in an
externally trusted device such as a TPM.

In modeling terms this is a time dependent value since the
terminal measurement value reflects a strict ordering of the
events as they occured.  This makes the classic measurement value
extremely fungible with respect to being useful as an independent
sentinel value of the trust statement of the platform.

The mathematical 'state' of an event domain is defined as the
extension sum of the domain event points that have been sorted in
natural hash (big-endian) format.  This provides a time invariant
measurement of the security state of a system.

This commit implements the following pseudo-file for
interrogating the state of of a security event domain:

/sys/kernel/security/integrity/events/state

The state of the event domain is computed each time this
pseudo-file is read with an obvious optimization being to use a
flag value in the event namespace to indicate whether or not an
event has occurred in the domain since the last computation.

A separate list is maintained in each event domain that is
specific to the state computation.  Each member of the state list
contains a pointer to an event in the primary event list which
avoids replication of the actual event point for the purposes of
the state computation.
---
 security/integrity/ima/ima_events.c | 141 +++++++++++++++++++++++++++-
 1 file changed, 137 insertions(+), 4 deletions(-)

diff --git a/security/integrity/ima/ima_events.c b/security/integrity/ima/ima_events.c
index d92472279359..ee04fe99d7c4 100644
--- a/security/integrity/ima/ima_events.c
+++ b/security/integrity/ima/ima_events.c
@@ -20,6 +20,7 @@
 #include <linux/user_namespace.h>
 #include <linux/proc_ns.h>
 #include <linux/iversion.h>
+#include <linux/list_sort.h>
 #include <crypto/hash.h>
 #include <crypto/hash_info.h>
 
@@ -84,6 +85,7 @@ static struct dentry *external;
 static struct dentry *forensics;
 static struct dentry *measurement_file;
 static struct dentry *trajectory;
+static struct dentry *state;
 
 static struct kobject *ima_events_kobject;
 
@@ -126,13 +128,18 @@ struct AIevent AI_events[] = {
 };
 
 
-/* Structure defining an event point. */
+/* Structures defining event points. */
 struct event_point {
 	struct list_head list;
-	char point[WP256_DIGEST_SIZE];
+	unsigned char point[WP256_DIGEST_SIZE];
 	bool valid;
 };
 
+struct state_point {
+	struct list_head list;
+	struct event_point *point;
+};
+
 /* Structure defining an execution trajectory point. */
 struct trajectory {
 	struct list_head list;
@@ -182,11 +189,13 @@ struct ima_events_map {
 
 	char base[WP256_DIGEST_SIZE];
 	char measurement[WP256_DIGEST_SIZE];
+	unsigned char state[WP256_DIGEST_SIZE];
 
 	struct event_point cp;
 	unsigned int point_count;
 	struct mutex point_list_mutex;
 	struct list_head point_list;
+	struct list_head state_list;
 
 	unsigned int trajectory_count;
 	struct mutex trajectory_list_mutex;
@@ -210,6 +219,7 @@ struct ima_events_map {
 	.emit_aggregate = true,
 	.point_list_mutex = __MUTEX_INITIALIZER(init_ima_events_map.point_list_mutex),
 	.point_list = LIST_HEAD_INIT(init_ima_events_map.point_list),
+	.state_list = LIST_HEAD_INIT(init_ima_events_map.state_list),
 
 	.trajectory_list_mutex = __MUTEX_INITIALIZER(init_ima_events_map.trajectory_list_mutex),
 	.trajectory_list = LIST_HEAD_INIT(init_ima_events_map.trajectory_list),
@@ -390,16 +400,23 @@ static int add_event_point(char *point, bool valid)
 {
 	int retn = 1;
 	struct event_point *entry;
+	struct state_point *state;
 	struct ima_events_map *map = current_map();
 
 	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
 	if (!entry)
 		goto done;
 
+	state = kzalloc(sizeof(*state), GFP_KERNEL);
+	if (!state)
+		goto done;
+	state->point = entry;
+
 	mutex_lock(&map->point_list_mutex);
 	memcpy(entry->point, point, WP256_DIGEST_SIZE);
 	entry->valid = valid;
 	list_add_tail(&entry->list, &map->point_list);
+	list_add_tail(&state->list, &map->state_list);
 	++map->point_count;
 	mutex_unlock(&map->point_list_mutex);
 	retn = 0;
@@ -1379,6 +1396,103 @@ static const struct file_operations ima_measurement_ops = {
 	.release = seq_release,
 };
 
+static int state_sort(void *priv, struct list_head *a, struct list_head *b)
+{
+	unsigned int lp, retn;
+	struct state_point *ap = container_of(a, struct state_point, list);
+	struct state_point *bp = container_of(b, struct state_point, list);
+
+	for (lp= 0; lp < WP256_DIGEST_SIZE - 1; ++lp) {
+		if (ap->point->point[lp] == bp->point->point[lp])
+			continue;
+		retn = ap->point->point[lp] > bp->point->point[lp];
+		goto done;
+	}
+	retn = ap->point->point[lp] > bp->point->point[lp];
+
+ done:
+	return retn;
+}
+
+static void compute_state(void)
+{
+	unsigned char state[WP256_DIGEST_SIZE];
+	struct state_point *entry;
+	struct ima_events_map *map = current_map();
+	struct crypto_shash *sha256 = NULL;
+	SHASH_DESC_ON_STACK(shash, tfm);
+
+	/* Initialize state with host/aggregate value. */
+	sha256 = crypto_alloc_shash("sha256", 0, 0);
+	if (IS_ERR(sha256))
+		return;
+
+	shash->tfm = sha256;
+	if (crypto_shash_init(shash))
+		goto done;
+
+	memset(state, '\0', sizeof(state));
+	if (crypto_shash_update(shash, state, WP256_DIGEST_SIZE))
+		goto done;
+
+	if (get_host_measurement(sha256, aggregate, WP256_DIGEST_SIZE, state))
+		goto done;
+
+	if (crypto_shash_finup(shash, state, sizeof(state), state))
+		goto done;
+
+	/* Add the event points in sorted order. */
+	mutex_lock(&map->point_list_mutex);
+	list_sort(NULL, &map->state_list, state_sort);
+
+	memcpy(map->state, state, sizeof(map->state));
+	list_for_each_entry(entry, &map->state_list, list) {
+		if (get_host_measurement(sha256, entry->point->point,
+					 WP256_DIGEST_SIZE, state))
+			goto unlock_done;
+
+		if (crypto_shash_init(shash))
+			goto unlock_done;
+		if (crypto_shash_update(shash, map->state, WP256_DIGEST_SIZE))
+			goto unlock_done;
+		if (crypto_shash_finup(shash, state, WP256_DIGEST_SIZE,
+				       map->state))
+			goto unlock_done;
+	}
+
+ unlock_done:
+	mutex_unlock(&map->point_list_mutex);
+ done:
+	if (sha256)
+		crypto_free_shash(sha256);
+}
+
+static int ima_state_show(struct seq_file *m, void *v)
+{
+	struct ima_events_map *map = current_map();
+
+	compute_state();
+	seq_printf(m, "%*phN\n", WP256_DIGEST_SIZE, map->state);
+	return 0;
+}
+
+static int ima_state_open(struct inode *inode, struct file *file)
+{
+	struct ima_events_map *map = current_map();
+
+	if (map->domain_sealed || map->external)
+		return -EACCES;
+
+	return single_open(file, &ima_state_show, NULL);
+}
+
+static const struct file_operations ima_state_ops = {
+	.open = ima_state_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = seq_release,
+};
+
 int ima_events_genhash(struct ima_template_entry *entry, char *tpm_digest)
 {
 	int retn;
@@ -1847,6 +1961,11 @@ int __init ima_events_init(void)
 	if (IS_ERR(trajectory))
 		goto err;
 
+	state = securityfs_create_file("state", 0400, events_dir, NULL,
+				       &ima_state_ops);
+	if (IS_ERR(state))
+		goto err;
+
 	ima_events_kobject = kobject_create_and_add("integrity-events",
 						    fs_kobj);
 	if (!ima_events_kobject)
@@ -1867,6 +1986,7 @@ int __init ima_events_init(void)
 	securityfs_remove(forensics);
 	securityfs_remove(measurement_file);
 	securityfs_remove(trajectory);
+	securityfs_remove(state);
 
 	if (ima_events_kobject)
 		kobject_put(ima_events_kobject);
@@ -1974,6 +2094,7 @@ void ima_free_ns(struct kref *kref)
 	unsigned int cnt;
 	struct ima_events_namespace *ns;
 	struct event_point *centry, *tmp_centry;
+	struct state_point *state, *tmp_state;
 	struct trajectory *tentry, *tmp_tentry;
 	struct pseudonym *sentry, *tmp_sentry;
 
@@ -1983,12 +2104,23 @@ void ima_free_ns(struct kref *kref)
 	list_for_each_entry_safe(centry, tmp_centry, &ns->map->point_list,
 				 list) {
 		list_del(&centry->list);
-		pr_debug("[%s]: Removing point: %*phN\n", __func__,
+		pr_debug("[%s]: Removing event point: %*phN\n", __func__,
 			WP256_DIGEST_SIZE, centry->point);
 		kfree(centry);
 		++cnt;
 	}
-	pr_debug("[%s]: Released %d points.\n", __func__, cnt);
+	pr_debug("[%s]: Released %d event points.\n", __func__, cnt);
+
+	cnt = 0;
+	list_for_each_entry_safe(state, tmp_state, &ns->map->state_list,
+				 list) {
+		list_del(&state->list);
+		pr_debug("[%s]: Removing state point: %*phN\n", __func__,
+			WP256_DIGEST_SIZE, state->point->point);
+		kfree(state);
+		++cnt;
+	}
+	pr_debug("[%s]: Released %d state points.\n", __func__, cnt);
 
 	cnt = 0;
 	list_for_each_entry_safe(tentry, tmp_tentry, &ns->map->trajectory_list,
@@ -2076,6 +2208,7 @@ struct ima_events_namespace *ima_copy_events_ns(unsigned long flags,
 	}
 	mutex_init(&ns->map->point_list_mutex);
 	INIT_LIST_HEAD(&ns->map->point_list);
+	INIT_LIST_HEAD(&ns->map->state_list);
 
 	mutex_init(&ns->map->trajectory_list_mutex);
 	INIT_LIST_HEAD(&ns->map->trajectory_list);
-- 
2.31.1

