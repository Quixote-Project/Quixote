From 0433682152285d2f10c2e1e2842a97843a164676 Mon Sep 17 00:00:00 2001
From: "Dr. Greg" <greg@enjellic.com>
Date: Sat, 17 Apr 2021 17:38:32 -0500
Subject: [PATCH 42/50] Implement CAP_TRUST capability.

The objective for the Quixote userspace is to ultimately only
have a single entity that controls the trust state of the
platform.  In preparation for this a new capability named
CAP_TRUST is implemented in this patch.

The event namespace creation code was modified to require that a
process unsharing the event namespace posess the CAP_TRUST
capability.

The system calls for configuring an event domain and for
modifying the bad actor status of a process were modified to gate
permission based on posession of the CAP_TRUST attribute.

Since this patch is outside the kernel the userspace will need to
be wedded to the specific kernel in so that the numeric value of
the CAP_TRUST attribute is consistent between the two.
---
 include/uapi/linux/capability.h     |  6 +++++-
 security/integrity/ima/ima_events.c | 21 ++++++---------------
 2 files changed, 11 insertions(+), 16 deletions(-)

diff --git a/include/uapi/linux/capability.h b/include/uapi/linux/capability.h
index 240fdb9a60f6..44636b43470d 100644
--- a/include/uapi/linux/capability.h
+++ b/include/uapi/linux/capability.h
@@ -366,8 +366,12 @@ struct vfs_ns_cap_data {
 
 #define CAP_AUDIT_READ		37
 
+/* Allow modifications to the trust status of the system */
 
-#define CAP_LAST_CAP         CAP_AUDIT_READ
+#define CAP_TRUST	38
+
+
+#define CAP_LAST_CAP         CAP_TRUST
 
 #define cap_valid(x) ((x) >= 0 && (x) <= CAP_LAST_CAP)
 
diff --git a/security/integrity/ima/ima_events.c b/security/integrity/ima/ima_events.c
index ee04fe99d7c4..d7546f4b97d8 100644
--- a/security/integrity/ima/ima_events.c
+++ b/security/integrity/ima/ima_events.c
@@ -2191,6 +2191,9 @@ struct ima_events_namespace *ima_copy_events_ns(unsigned long flags,
 	if (!(flags & CLONE_EVENTS))
 		return events_ns;
 
+	if (!capable(CAP_TRUST))
+		return ERR_PTR(-EPERM);
+
 	ns = kzalloc(sizeof(struct ima_events_namespace), GFP_KERNEL);
 	if (!ns) {
 		retn = -ENOMEM;
@@ -2328,7 +2331,7 @@ SYSCALL_DEFINE2(set_bad_actor, pid_t, pid, unsigned long, flags)
 	int retn = -ESRCH;
 	struct task_struct *actor;
 
-	if (!capable(CAP_SYS_ADMIN))
+	if (!capable(CAP_TRUST))
 		return -EPERM;
 
 	rcu_read_lock();
@@ -2369,25 +2372,14 @@ SYSCALL_DEFINE3(config_events_ns, unsigned char *, bufr, size_t, cnt,
 		unsigned int hook;
 		unsigned int action;
 	} ctl;
-	kuid_t root_uid;
 
 	pr_debug("[%s]: Called: cnt=%zu, flags=%lu.\n", __func__, cnt, flags);
 
-	/* Verify permissions for system call. */
-	if (!is_ns() && !capable(CAP_SYS_ADMIN))
+	if (!capable(CAP_TRUST))
 		return -EPERM;
-
-	if (is_ns()) {
-		root_uid = make_kuid(current_cred()->user_ns, 0);
-		if ( !uid_eq(current_euid(), root_uid) )
-			return -EPERM;
-	}
-
-	/* Verify valid system call control flags. */
 	if (flags & ~(IMA_SET_CONTOUR | IMA_SET_PSEUDONYM | IMA_SET_AI))
 		return -EINVAL;
 
-
 	if (flags & IMA_SET_PSEUDONYM) {
 		if (map->domain_sealed)
 			return -EPERM;
@@ -2475,8 +2467,7 @@ static int events_install(struct nsproxy *nsproxy, struct ns_common *new)
 	struct ima_events_namespace *events_ns =
 		container_of(new, struct ima_events_namespace, ns);
 
-	if (!ns_capable(events_ns->user_ns, CAP_SYS_ADMIN) ||
-	    !ns_capable(current_user_ns(), CAP_SYS_ADMIN))
+	if (!capable(CAP_TRUST))
 		return -EPERM;
 
 	if (events_ns) {
-- 
2.31.1

