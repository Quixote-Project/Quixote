diff -urNp v2.66/libcap-2.66/libcap/include/uapi/linux/capability.h libcap-2.66/libcap/include/uapi/linux/capability.h
--- v2.66/libcap-2.66/libcap/include/uapi/linux/capability.h	2022-01-24 00:02:32.000000001 -0600
+++ libcap-2.66/libcap/include/uapi/linux/capability.h	2022-12-02 14:00:53.000000001 -0600
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
 /*
  * This is <linux/capability.h>
  *
@@ -7,16 +8,13 @@
  *
  * See here for the libcap library ("POSIX draft" compliance):
  *
- * https://git.kernel.org/pub/scm/libs/libcap/libcap.git/refs/
- * http://www.kernel.org/pub/linux/libs/security/linux-privs/
+ * ftp://www.kernel.org/pub/linux/libs/security/linux-privs/kernel-2.6/
  */
 
 #ifndef _UAPI_LINUX_CAPABILITY_H
 #define _UAPI_LINUX_CAPABILITY_H
 
-#include <stdint.h>
-#define __u32 uint32_t
-#define __le32 __u32
+#include <linux/types.h>
 
 /* User-level do most of the mapping between kernel and user
    capabilities based on the version tag given by the kernel. The
@@ -41,13 +39,13 @@
 typedef struct __user_cap_header_struct {
 	__u32 version;
 	int pid;
-} *cap_user_header_t;
+} __user *cap_user_header_t;
 
 typedef struct __user_cap_data_struct {
         __u32 effective;
         __u32 permitted;
         __u32 inheritable;
-} *cap_user_data_t;
+} __user *cap_user_data_t;
 
 
 #define VFS_CAP_REVISION_MASK	0xFF000000
@@ -64,30 +62,30 @@ typedef struct __user_cap_data_struct {
 #define XATTR_CAPS_SZ_2         (sizeof(__le32)*(1 + 2*VFS_CAP_U32_2))
 
 #define VFS_CAP_REVISION_3	0x03000000
-#define VFS_CAP_U32_3           VFS_CAP_U32_2
-#define XATTR_CAPS_SZ_3         (sizeof(__le32)+XATTR_CAPS_SZ_2)
+#define VFS_CAP_U32_3           2
+#define XATTR_CAPS_SZ_3         (sizeof(__le32)*(2 + 2*VFS_CAP_U32_3))
 
-/*
- * Kernel capabilities default to v2. The v3 VFS caps are only used,
- * at present, for namespace specific filesystem capabilities.
- */
-#define XATTR_CAPS_SZ           XATTR_CAPS_SZ_2
-#define VFS_CAP_U32             VFS_CAP_U32_2
-#define VFS_CAP_REVISION	VFS_CAP_REVISION_2
-
-#define _VFS_CAP_DATA_HEAD \
-	__le32 magic_etc;            /* Little endian */ \
-	struct {                                         \
-		__le32 permitted;    /* Little endian */ \
-		__le32 inheritable;  /* Little endian */ \
-	} data[VFS_CAP_U32]
+#define XATTR_CAPS_SZ           XATTR_CAPS_SZ_3
+#define VFS_CAP_U32             VFS_CAP_U32_3
+#define VFS_CAP_REVISION	VFS_CAP_REVISION_3
 
 struct vfs_cap_data {
-	_VFS_CAP_DATA_HEAD;
+	__le32 magic_etc;            /* Little endian */
+	struct {
+		__le32 permitted;    /* Little endian */
+		__le32 inheritable;  /* Little endian */
+	} data[VFS_CAP_U32];
 };
 
+/*
+ * same as vfs_cap_data but with a rootid at the end
+ */
 struct vfs_ns_cap_data {
-	_VFS_CAP_DATA_HEAD;
+	__le32 magic_etc;
+	struct {
+		__le32 permitted;    /* Little endian */
+		__le32 inheritable;  /* Little endian */
+	} data[VFS_CAP_U32];
 	__le32 rootid;
 };
 
@@ -245,7 +243,6 @@ struct vfs_ns_cap_data {
 /* Allow examination and configuration of disk quotas */
 /* Allow setting the domainname */
 /* Allow setting the hostname */
-/* Allow calling bdflush() */
 /* Allow mount() and umount(), setting up new smb connection */
 /* Allow some autofs root ioctls */
 /* Allow nfsservctl */
@@ -276,6 +273,7 @@ struct vfs_ns_cap_data {
    arbitrary SCSI commands */
 /* Allow setting encryption key on loopback filesystem */
 /* Allow setting zone reclaim policy */
+/* Allow everything under CAP_BPF and CAP_PERFMON for backward compatibility */
 
 #define CAP_SYS_ADMIN        21
 
@@ -289,6 +287,8 @@ struct vfs_ns_cap_data {
    processes and setting the scheduling algorithm used by another
    process. */
 /* Allow setting cpu affinity on other processes */
+/* Allow setting realtime ioprio class */
+/* Allow setting ioprio class on other processes */
 
 #define CAP_SYS_NICE         23
 
@@ -303,6 +303,7 @@ struct vfs_ns_cap_data {
 /* Allow more than 64hz interrupts from the real-time clock */
 /* Override max number of consoles on console allocation */
 /* Override max number of keymaps */
+/* Control memory reclaim behavior */
 
 #define CAP_SYS_RESOURCE     24
 
@@ -333,7 +334,8 @@ struct vfs_ns_cap_data {
 
 #define CAP_AUDIT_CONTROL    30
 
-/* Set capabilities on files. */
+/* Set or remove capabilities on files.
+   Map uid=0 into a child user namespace. */
 
 #define CAP_SETFCAP	     31
 
@@ -368,12 +370,14 @@ struct vfs_ns_cap_data {
 
 /* Allow reading the audit log via multicast netlink socket */
 
-#define CAP_AUDIT_READ       37
+#define CAP_AUDIT_READ		37
 
-/* Allow system performance and observability privileged operations using
- * perf_events, i915_perf and other kernel subsystems. */
+/*
+ * Allow system performance and observability privileged operations
+ * using perf_events, i915_perf and other kernel subsystems
+ */
 
-#define CAP_PERFMON	     38
+#define CAP_PERFMON		38
 
 /*
  * CAP_BPF allows the following BPF operations:
@@ -404,16 +408,20 @@ struct vfs_ns_cap_data {
  * CAP_PERFMON and CAP_BPF are required to load tracing programs.
  * CAP_NET_ADMIN and CAP_BPF are required to load networking programs.
  */
+#define CAP_BPF			39
 
-#define CAP_BPF		     39
 
 /* Allow checkpoint/restore related operations */
 /* Allow PID selection during clone3() */
 /* Allow writing to ns_last_pid */
 
-#define CAP_CHECKPOINT_RESTORE 40
+#define CAP_CHECKPOINT_RESTORE	40
+
+/* Allow modifications to the trust status of the system */
 
-#define CAP_LAST_CAP         CAP_CHECKPOINT_RESTORE
+#define CAP_ML	41
+
+#define CAP_LAST_CAP         CAP_ML
 
 #define cap_valid(x) ((x) >= 0 && (x) <= CAP_LAST_CAP)
 
@@ -422,6 +430,7 @@ struct vfs_ns_cap_data {
  */
 
 #define CAP_TO_INDEX(x)     ((x) >> 5)        /* 1 << 5 == bits in __u32 */
-#define CAP_TO_MASK(x)      (1u << ((x) & 31)) /* mask for indexed __u32 */
+#define CAP_TO_MASK(x)      (1U << ((x) & 31)) /* mask for indexed __u32 */
+
 
 #endif /* _UAPI_LINUX_CAPABILITY_H */
