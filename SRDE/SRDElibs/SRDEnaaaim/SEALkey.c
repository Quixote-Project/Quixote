/** \file
 * This file contains the implementation of an object that is used to
 * generate enclave specific sealing keys.  The following two major
 * sealing keys are generated:
 *
 *	MRENCLAVE
 *
 *	MRSIGNER
 *
 * MRENCLAVE based seal keys are specific to the measurement of the
 * enclave and thus are extremely fungible and only have usefulness
 * within a specific execution envelope of an enclave.
 *
 * The MRSIGNER based seal keys are specific to the identity of the
 * enclave signer.  These keys are typically used to persist data in
 * between invocations of an enclave.
 *
 * The enclave sealing keys dependent on the CPU security version as
 * well as the security version of the enclave.  Newer versions of an
 * enclave, with respect to those identity elements, can re-generate
 * keys that were generated by previous versions of the enclave.  The
 * older enclaves cannot generate sealing keys that are relevant in
 * later versions of the enclave.
 *
 * This construct prevents sealed data elements from being accessed by
 * enclaves or a platform with known security vulnerabilities.
 */

/**************************************************************************
 * Copyright (c) Enjellic Systems Development, LLC. All rights reserved.
 *
 * Please refer to the file named Documentation/COPYRIGHT in the top of
 * the source tree for copyright and licensing information.
 **************************************************************************/

/* Include files. */
#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

#include <openssl/asn1.h>
#include <openssl/asn1t.h>

#include <Origin.h>
#include <HurdLib.h>
#include <Buffer.h>

#include <SRDE.h>
#include <SRDEfusion.h>

#include "NAAAIM.h"
#include "RandomBuffer.h"
#include "SHA256.h"
#include "Report.h"
#include "SEALkey.h"


/* Object state extraction macro. */
#define STATE(var) CO(SEALkey_State, var) = this->state

/* Verify library/object header file inclusions. */
#if !defined(NAAAIM_LIBID)
#error Library identifier not defined.
#endif

#if !defined(NAAAIM_SEALkey_OBJID)
#error Object identifier not defined.
#endif


/**
 * The following definitions define the ASN1 encoding sequence for
 * the DER encoding of the key request that will be saved as a
 * preamble to the encrypted payload.
 */
typedef struct {
	ASN1_INTEGER *isv_svn;
	ASN1_INTEGER *config_svn;
	ASN1_INTEGER *key_policy;
	ASN1_OCTET_STRING *cpu_svn;
	ASN1_OCTET_STRING *key_id;
} keyrequest_payload;

ASN1_SEQUENCE(keyrequest_payload) = {
	ASN1_SIMPLE(keyrequest_payload, isv_svn,	ASN1_INTEGER),
	ASN1_SIMPLE(keyrequest_payload, config_svn,	ASN1_INTEGER),
	ASN1_SIMPLE(keyrequest_payload, key_policy,	ASN1_INTEGER),
	ASN1_SIMPLE(keyrequest_payload, cpu_svn,	ASN1_OCTET_STRING),
	ASN1_SIMPLE(keyrequest_payload, key_id,		ASN1_OCTET_STRING),
} ASN1_SEQUENCE_END(keyrequest_payload)

IMPLEMENT_ASN1_FUNCTIONS(keyrequest_payload)


/** SEALkey private state information. */
struct NAAAIM_SEALkey_State
{
	/* The root object. */
	Origin root;

	/* Library identifier. */
	uint32_t libid;

	/* Object identifier. */
	uint32_t objid;

	/* Object status. */
	_Bool poisoned;

	/* The object containing an initialization vector for the key. */
	Buffer keyiv;

	/* The object containing the generated key. */
	Buffer key;

	/* Boolean to indicate that key requests are available. */
	_Bool have_shroud;
	_Bool have_request;

	/* Structure used to define the shroud key request. */
	struct SGX_keyrequest shroud_request;

	/* Structure used to define the keyrequest. */
	struct SGX_keyrequest keyrequest;
};


/**
 * Internal private method.
 *
 * This method is responsible for initializing the NAAAIM_SEALkey_State
 * structure which holds state information for each instantiated object.
 *
 * \param S A pointer to the object containing the state information which
 *        is to be initialized.
 */

static void _init_state(CO(SEALkey_State, S))

{

	S->libid = NAAAIM_LIBID;
	S->objid = NAAAIM_SEALkey_OBJID;

	S->poisoned = false;

	S->keyiv = NULL;
	S->key	 = NULL;

	S->have_shroud	= NULL;
	S->have_request = NULL;

	return;
}


/**
 * Internal private method.
 *
 * This method implements the generation of a shroud key based on
 * an MRENCLAVE derived key.  This key is used as an XOR cloak for
 * the generated key.
 *
 * \param S	A pointer to the state of the object generating the
 *		key.
 *
 * \param key	The buffer containing the key to be processed by
 *		the shouding request.
 *
 * \return	A boolean value is used to indicate the status of
 *		the cloaking request.  A false value indicates
 *		an error was encountered the key was not cloaked.  A
 *		true value indicates the key was properly cloaked.
 */

_Bool _shroud_key(CO(SEALkey_State, S), CO(Buffer, key))

{
	_Bool retn = false;

	uint8_t lp;

	uint8_t __attribute__((aligned(128))) keydata[16];
	unsigned char *p1,
		      *p2;

	struct SGX_keyrequest __attribute__((aligned(512))) keyrequest;

	struct SGX_report report;

	Buffer rbp,
	       bufr = NULL;

	RandomBuffer randbufr = NULL;

	Sha256 sha256 = NULL;

	Report rpt = NULL;


	/* Verify we are working with a valid key. */
	if ( key == NULL )
		ERR(goto done);
	if ( key->poisoned == NULL )
		ERR(goto done);
	if ( key->size(key) != SGX_HASH_SIZE )
		ERR(goto done);


	/* Request a self report to get the measurement. */
	INIT(NAAAIM, Report, rpt, ERR(goto done));
	if ( !rpt->get_report(rpt, &report) )
		ERR(goto done);


	/* Initialize the key request. */
	if ( S->have_shroud )
		keyrequest = S->shroud_request;
	else {
		memset(&keyrequest, '\0', sizeof(struct SGX_keyrequest));

		INIT(NAAAIM, RandomBuffer, randbufr, ERR(goto done));
		if ( !randbufr->generate(randbufr, 32) )
			ERR(goto done);
		rbp = randbufr->get_Buffer(randbufr);
		memcpy(keyrequest.keyid, rbp->get(rbp), \
		       sizeof(keyrequest.keyid));

		keyrequest.keyname   = SRDE_KEYSELECT_SEAL;
		keyrequest.keypolicy = SRDE_KEYPOLICY_ENCLAVE;

		keyrequest.isvsvn     = report.body.isvsvn;
		keyrequest.config_svn = report.body.config_svn;

		memcpy(keyrequest.cpusvn, report.body.cpusvn, \
		       sizeof(keyrequest.cpusvn));

		/* Set the key type and security attribute masks. */
		keyrequest.attributes.flags = 0xFF0000000000000BULL;
		keyrequest.attributes.xfrm  = 0x0ULL;

		keyrequest.miscselect = 0xF0000000;

		S->have_shroud	  = true;
		S->shroud_request = keyrequest;
	}


	/* Generate the derived base key. */
	memset(keydata, '\0', sizeof(keydata));
	if ( enclu_egetkey(&keyrequest, keydata) != 0 )
		ERR(goto done);


	/* Hash the derived base key to obtain the cloaking key. */
	INIT(HurdLib, Buffer, bufr, ERR(goto done));
	INIT(NAAAIM, Sha256, sha256, ERR(goto done));

	if ( !bufr->add(bufr, keydata, sizeof(keydata)) )
		ERR(goto done);

	sha256->add(sha256, bufr);
	if ( !sha256->compute(sha256) )
		ERR(goto done);
	rbp = sha256->get_Buffer(sha256);


	/* XOR the key being shrouded with the shrouding key. */
	p1 = key->get(key);
	p2 = rbp->get(rbp);
	for (lp= 0; lp < key->size(key); ++lp)
		*p1++ ^= *p2++;

	retn = true;


 done:
	if ( !retn )
		S->poisoned = true;

	WHACK(bufr);
	WHACK(randbufr);
	WHACK(sha256);
	WHACK(rpt);

	return retn;
}


/**
 * Internal private method.
 *
 * This method implements the fundamentals of generating a 128 bit
 * initialization vector and a 256 bit encryption key based on a
 * particular sealing key type.  This translates the external
 * methods into a simple wrapper that sets the key type.
 *
 * \param S	A pointer to the state of the object generating the
 *		key.
 *
 * \param type	The type of the key to be generated.
 *
 * \param iv	The object that the initialization vector is to
 *		be copied into.
 *
 * \param key	The object that the encryption key will be copied
 *		into.
 *
 * \return	A boolean value is used to indicate the status of
 *		the requested key generation.  A false value indicates
 *		an error was encountered and neither the iv or key
 *		objects can be expected to contain valid values.  A
 *		true value indicates the objects contain valid keying
 *		elements
 */

_Bool _generate_iv_key(CO(SEALkey_State, S), int type)

{
	_Bool retn = false;

	uint8_t __attribute__((aligned(128))) keydata[16];

	struct SGX_report report;

	struct SGX_keyrequest __attribute__((aligned(512))) keyrequest;

	Buffer rbp,
	       bufr = NULL;

	RandomBuffer randbufr = NULL;

	Sha256 sha256 = NULL;

	Report rpt = NULL;


	/* Request a self report to get the measurement. */
	INIT(NAAAIM, Report, rpt, ERR(goto done));
	if ( !rpt->get_report(rpt, &report) )
		ERR(goto done);


	/* Initialize the key request. */
	memset(&keyrequest, '\0', sizeof(struct SGX_keyrequest));

	if ( S->have_request )
		keyrequest = S->keyrequest;
	else {
		INIT(NAAAIM, RandomBuffer, randbufr, ERR(goto done));

		if ( !randbufr->generate(randbufr, 32) )
			ERR(goto done);
		rbp = randbufr->get_Buffer(randbufr);
		memcpy(keyrequest.keyid, rbp->get(rbp), \
		       sizeof(keyrequest.keyid));

		keyrequest.keypolicy  = type;

		keyrequest.isvsvn     = report.body.isvsvn;
		keyrequest.config_svn = report.body.config_svn;

		memcpy(keyrequest.cpusvn, report.body.cpusvn, \
		       sizeof(keyrequest.cpusvn));

		S->keyrequest = keyrequest;
	}


	/* Set the key type and security attribute masks. */
	keyrequest.keyname = SRDE_KEYSELECT_SEAL;

	keyrequest.attributes.flags = 0xFF0000000000000BULL;
	keyrequest.attributes.xfrm  = 0x0ULL;

	keyrequest.miscselect = 0xF0000000;


	/* Generate the derived base key. */
	memset(keydata, '\0', sizeof(keydata));
	if ( enclu_egetkey(&keyrequest, keydata) != 0 )
		ERR(goto done);


	/* Hash the derived base key to obtain the encryption key. */
	INIT(HurdLib, Buffer, bufr, ERR(goto done));
	INIT(NAAAIM, Sha256, sha256, ERR(goto done));

	if ( !bufr->add(bufr, keydata, sizeof(keydata)) )
		ERR(goto done);
	sha256->add(sha256, bufr);
	if ( !sha256->compute(sha256) )
		ERR(goto done);

	S->key->reset(S->key);
	rbp = sha256->get_Buffer(sha256);
	if ( !S->key->add_Buffer(S->key, rbp) )
		ERR(goto done);

	/* Hash the symmetric key to obtain the initialization vector. */
	if ( !sha256->rehash(sha256, 512) )
		ERR(goto done);

	S->keyiv->reset(S->keyiv);
	if ( !S->keyiv->add(S->keyiv, rbp->get(rbp), 16) )
		ERR(goto done);

	retn = true;


 done:
	WHACK(bufr);
	WHACK(randbufr);
	WHACK(sha256);
	WHACK(rpt);

	return retn;
}


/**
 * External public method.
 *
 * This method implements the generation of a sealing key based on
 * the MRSIGNER value.
 *
 * \param this		A pointer to the object generating the key.
 *
 * \return	A boolean value is used to indicate the status of
 *		the requested key generation.  A false value indicates
 *		the the generation of the key failed and the object
 *		is poisoned.  A true value indicates the object is
 *		in posession of valid keying material.
 */

static _Bool generate_mrsigner(CO(SEALkey, this))

{
	STATE(S);

	_Bool retn = false;


	/* Verify object and arguement status. */
	if ( S->poisoned )
		ERR(goto done);

	/* Call key generator. */
	if ( !_generate_iv_key(S, SRDE_KEYPOLICY_SIGNER) )
		ERR(goto done);

	/* Shroud the key. */
	if ( !_shroud_key(S, S->key) )
		ERR(goto done);

	retn = true;


 done:
	if ( !retn )
		S->poisoned = true;

	return retn;
}


/**
 * External public method.
 *
 * This method implements the generation of a sealing key based on
 * the MRENCLAVE value.
 *
 * \param this		A pointer to the object generating the key.
 *
 *
 * \return	A boolean value is used to indicate the status of
 *		the requested key generation.  A false value indicates
 *		the the generation of the key failed and the object
 *		is poisoned.  A true value indicates the object is
 *		in posession of valid keying material.
 */

static _Bool generate_mrenclave(CO(SEALkey, this))

{
	STATE(S);

	_Bool retn = false;


	/* Verify object and arguement status. */
	if ( S->poisoned )
		ERR(goto done);

	/* Call key generator. */
	if ( !_generate_iv_key(S, SRDE_KEYPOLICY_ENCLAVE) )
		ERR(goto done);

	/* Shroud the key. */
	if ( !_shroud_key(S, S->key) )
		ERR(goto done);

	retn = true;


 done:
	if ( !retn )
		S->poisoned = true;

	return retn;
}


/**
 * External public method.
 *
 * This method implements the ability to generate a static key of
 * either major type (MRSIGNER OR MRENCLAVE) using a keyid supplied by
 * the caller.  A static is one that has all elements of keying
 * elements set to null values except for a key identifier.  These
 * keys should used with caution since they are not tied to the
 * trusted computing base of the platform, ie any enclave can
 * generate them.
 *
 * \param this	A pointer to the object generating the key.
 *
 * \param type	The type of key to be generated.
 *
 * \param keyid	An object containing the key identifier to be used
 *		to generate the key.
 *
 * \return	A boolean value is used to indicate the status of
 *		the requested key generation.  A false value indicates
 *		the the generation of the key failed and the object
 *		is poisoned.  A true value indicates the object is
 *		in posession of valid keying material.
 */

static _Bool generate_static_key(CO(SEALkey, this), int type, \
				 CO(Buffer, keyid))

{
	STATE(S);

	_Bool retn = false;

	struct SGX_keyrequest __attribute__((aligned(512))) keyrequest;


	/* Verify object and arguement status. */
	if ( S->poisoned )
		ERR(goto done);
	if ( keyid == NULL )
		ERR(goto done);
	if ( keyid->poisoned(keyid) )
		ERR(goto done);
	if ( (type != SRDE_KEYPOLICY_SIGNER) && \
	     (type != SRDE_KEYPOLICY_ENCLAVE) )
		ERR(goto done);


	/* Setup a null key request with a keyid value set. */
	memset(&S->keyrequest, '\0', sizeof(keyrequest));
	memcpy(&S->keyrequest.keyid, keyid->get(keyid), \
	       sizeof(keyrequest.keyid));

	S->have_request = true;


	/* Call key generator. */
	if ( !_generate_iv_key(S, type) )
		ERR(goto done);


	/* Shroud the key. */
	if ( !_shroud_key(S, S->key) )
		ERR(goto done);

	retn = true;


 done:
	if ( !retn )
		S->poisoned = true;

	return retn;
}


/**
 * External public method.
 *
 * This method implements an accessor method for retrieving the
 * initialization vector and key that were generated.
 *
 * \param this		A pointer to the object that will have its
 *			its keying components retrieved.
 *
 * \param iv		A pointer to the object that the
 *			initialization vector will be loaded into.
 *
 * \param key		A pointer to the object that the encryption
 *			key will be loaded into.
 *
 * \return	A boolean value is used to indicate the status of
 *		fetching the keying elements.  A false value
 *		indicates an error was encountered and neither of
 *		the supplied objects can be considered to have
 *		valid data in them.  A true value idnicates that the
 *		keying elements were successfully returned.
 */

static _Bool get_iv_key(CO(SEALkey, this), CO(Buffer, iv), CO(Buffer, key))

{
	STATE(S);

	_Bool retn = false;


	/* Check object status. */
	if ( S->poisoned )
		ERR(goto done);
	if ( S->keyiv == NULL )
		ERR(goto done);
	if ( S->key == NULL )
		ERR(goto done);

	if ( iv == NULL )
		ERR(goto done);
	if ( iv->poisoned(iv) )
		ERR(goto done);

	if ( key == NULL )
		ERR(goto done);
	if ( key->poisoned(key) )
		ERR(goto done);


	/* Load the necessary elements. */
	if ( !iv->add_Buffer(iv, S->keyiv) )
		ERR(goto done);
	if ( !key->add_Buffer(key, S->key) )
		ERR(goto done);

	/* Unshroud the key being returned. */
	if ( !_shroud_key(S, key) )
		ERR(goto done);

	retn = true;


 done:
	if ( !retn )
		S->poisoned = true;

	return retn;
}


/**
 * External public method.
 *
 * This method implements an accessor method for retrieving the
 * DER encoded keyrequest that the derived key is based on.
 *
 * \param this		A pointer to the object that will have its
 *			its key request components retrieved.
 *
 * \param req		A pointer to the object that the DER
 *			encoded request is loaded into.
 *
 * \return	A boolean value is used to indicate the status of
 *		fetching the key request components.  A false value
 *		indicates an error was encountered and the request
 *		object does not have a valid key request encoding.
 *		A true value idnicates that the keying elements were
 *		successfully returned in the provided object.
 */

static _Bool get_request(CO(SEALkey, this), CO(Buffer, req))

{
	STATE(S);

	_Bool retn = false;

        unsigned char *asn = NULL;

        unsigned char **p = &asn;

	int asn_size;

	keyrequest_payload *keyreq = NULL;


	/* Check object status. */
	if ( S->poisoned )
		ERR(goto done);
	if ( req == NULL )
		ERR(goto done);
	if ( req->poisoned(req) )
		ERR(goto done);


	/* Encode the keying request elements. */
	if ( (keyreq = keyrequest_payload_new()) == NULL )
		goto done;

	if ( ASN1_INTEGER_set(keyreq->isv_svn, S->keyrequest.isvsvn) != 1 )
		goto done;
	if ( ASN1_INTEGER_set(keyreq->config_svn, S->keyrequest.config_svn) \
	     != 1 )
		goto done;
	if ( ASN1_INTEGER_set(keyreq->key_policy, S->keyrequest.keypolicy) \
	     != 1 )
		goto done;

	if ( ASN1_OCTET_STRING_set(keyreq->cpu_svn, S->keyrequest.cpusvn, \
				   sizeof(S->keyrequest.cpusvn)) != 1 )
		goto done;
	if ( ASN1_OCTET_STRING_set(keyreq->key_id, S->keyrequest.keyid, \
				   sizeof(S->keyrequest.keyid)) != 1 )
		goto done;

        asn_size = i2d_keyrequest_payload(keyreq, p);
        if ( asn_size < 0 )
                goto done;
	if ( !req->add(req, asn, asn_size) )
		goto done;

	retn = true;


 done:
	if ( !retn )
		S->poisoned = true;
	if ( keyreq != NULL )
		keyrequest_payload_free(keyreq);
	if ( asn != NULL )
		OPENSSL_free(asn);

	return retn;
}


/**
 * External public method.
 *
 * This method implements a method for setting the key request
 * attributes from a previously encoded key request.
 *
 * \param this		A pointer to the object that will have its
 *			its key request components retrieved.
 *
 * \param req		A pointer to the object containing the
 *			DER encoded key request.
 *
 * \return	A boolean value is used to indicate the status of
 *		setting the  key request components.  A false value
 *		indicates an error was encountered and the object
 *		does not have a correctly defined key request
 *		structure.  A true value indicates that the keying
 *		elements were successfully decoded and the
 *		key request structure has been initialized.
 */

static _Bool set_request(CO(SEALkey, this), CO(Buffer, req))

{
	STATE(S);

	_Bool retn = false;

        unsigned char *asn = NULL;

        unsigned const char *p = asn;

	int asn_size;

	keyrequest_payload *keyreq = NULL;


	/* Verify object status. */
	if ( S->poisoned )
		ERR(goto done);
	if ( req == NULL )
		ERR(goto done);
	if ( req->poisoned(req) )
		ERR(goto done);


	/* Unmarshall the key elements. */
	p	 = req->get(req);
	asn_size = req->size(req);

        if ( !d2i_keyrequest_payload(&keyreq, &p, asn_size) )
                ERR(goto done);

	S->keyrequest.isvsvn	 = ASN1_INTEGER_get(keyreq->isv_svn);
	S->keyrequest.config_svn = ASN1_INTEGER_get(keyreq->config_svn);
	S->keyrequest.keypolicy	 = ASN1_INTEGER_get(keyreq->key_policy);

	memcpy(S->keyrequest.cpusvn, ASN1_STRING_get0_data(keyreq->cpu_svn), \
	       ASN1_STRING_length(keyreq->cpu_svn));
	memcpy(S->keyrequest.keyid, ASN1_STRING_get0_data(keyreq->key_id), \
	       ASN1_STRING_length(keyreq->key_id));

	retn = true;
	S->have_request = true;


 done:
	if ( !retn )
		S->poisoned = true;
	if ( keyreq != NULL )
		keyrequest_payload_free(keyreq);

	return retn;
}


/**
 * External public method.
 *
 * This method implements the output of the various key elements.
 *
 * \param this	A pointer to the object whose key elements are
 *		to be output.
 */

static void print(CO(SEALkey, this))

{
	STATE(S);


	/* Verify object status. */
	if ( S->poisoned ) {
		fputs("*POISONED*\n", stderr);
		return;
	}


	/* Output elements. */
	fputs("IV:\n", stdout);
	S->keyiv->hprint(S->keyiv);

	fputs("Key:\n", stdout);
	S->key->hprint(S->key);

	return;
}


/**
 * External public method.
 *
 * This method implements resetting the object so that it can be
 * used for a new key generation cycle.
 *
 * \param this	A pointer to the object which is to be reset.
 */

static void reset(CO(SEALkey, this))

{
	STATE(S);


	S->have_shroud  = false;
	S->have_request = false;

	memset(&S->shroud_request, '\0', sizeof(S->keyrequest));
	memset(&S->keyrequest,	   '\0', sizeof(S->keyrequest));

	if ( S->keyiv != NULL )
		S->keyiv->reset(S->keyiv);
	if ( S->key != NULL )
		S->key->reset(S->key);


	return;
}


/**
 * External public method.
 *
 * This method implements a destructor for a SEALkey object.
 *
 * \param this	A pointer to the object which is to be destroyed.
 */

static void whack(CO(SEALkey, this))

{
	STATE(S);


	WHACK(S->keyiv);
	WHACK(S->key);

	S->root->whack(S->root, this, S);
	return;
}


/**
 * External constructor call.
 *
 * This function implements a constructor call for a SEALkey object.
 *
 * \return	A pointer to the initialized SEALkey.  A null value
 *		indicates an error was encountered in object generation.
 */

extern SEALkey NAAAIM_SEALkey_Init(void)

{
	Origin root;

	SEALkey this = NULL;

	struct HurdLib_Origin_Retn retn;


	/* Get the root object. */
	root = HurdLib_Origin_Init();

	/* Allocate the object and internal state. */
	retn.object_size  = sizeof(struct NAAAIM_SEALkey);
	retn.state_size   = sizeof(struct NAAAIM_SEALkey_State);
	if ( !root->init(root, NAAAIM_LIBID, NAAAIM_SEALkey_OBJID, &retn) )
		return NULL;
	this	    	  = retn.object;
	this->state 	  = retn.state;
	this->state->root = root;

	/* Initialize object state. */
	_init_state(this->state);

	/* Initialize aggregate objects. */
	INIT(HurdLib, Buffer, this->state->keyiv, goto fail);
	INIT(HurdLib, Buffer, this->state->key,	  goto fail);

	/* Method initialization. */
	this->generate_mrsigner	  = generate_mrsigner;
	this->generate_mrenclave  = generate_mrenclave;
	this->generate_static_key = generate_static_key;

	this->get_iv_key  = get_iv_key;

	this->get_request = get_request;
	this->set_request = set_request;

	this->print = print;
	this->reset = reset;
	this->whack = whack;

	return this;


 fail:
	if ( this->state->keyiv != NULL )
		this->state->keyiv->whack(this->state->keyiv);
	if ( this->state->key != NULL )
		this->state->key->whack(this->state->key);

	root->whack(root, this, this->state);
	return NULL;
}
